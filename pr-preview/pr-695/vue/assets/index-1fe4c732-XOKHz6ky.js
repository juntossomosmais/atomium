import{d as x}from"./index-d9a82e80-B2PaWDFh.js";import{MENU_BACK_BUTTON_PRIORITY as k}from"./hardware-back-button-90972cd5-CjsNwcSH.js";import{p as T}from"./index-1e38abc5-CfLTl0tl.js";import{e as B}from"./helpers-4047ce7f-ZS1Xs9E2.js";import{b as O}from"./index-DE-xml85.js";import{c as f}from"./animation-aa17f0ca-uhoxsK6h.js";/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */const X=t=>f().duration(t?400:300);/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */const P=t=>{let o,r;const l=t.width+8,a=f(),m=f();t.isEndSide?(o=l+"px",r="0px"):(o=-l+"px",r="0px"),a.addElement(t.menuInnerEl).fromTo("transform",`translateX(${o})`,`translateX(${r})`);const p=O(t)==="ios",y=p?.2:.25;return m.addElement(t.backdropEl).fromTo("opacity",.01,y),X(p).addAnimation([a,m])};/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */const q=t=>{let o,r;const l=O(t),a=t.width;t.isEndSide?(o=-a+"px",r=a+"px"):(o=a+"px",r=-a+"px");const m=f().addElement(t.menuInnerEl).fromTo("transform",`translateX(${r})`,"translateX(0px)"),w=f().addElement(t.contentEl).fromTo("transform","translateX(0px)",`translateX(${o})`),p=f().addElement(t.backdropEl).fromTo("opacity",.01,.32);return X(l==="ios").addAnimation([m,w,p])};/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */const U=t=>{const o=O(t),r=t.width*(t.isEndSide?-1:1)+"px",l=f().addElement(t.contentEl).fromTo("transform","translateX(0px)",`translateX(${r})`);return X(o==="ios").addAnimation(l)};/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */const D=()=>{const t=new Map,o=[],r=async n=>{const e=await d(n,!0);return e?e.open():!1},l=async n=>{const e=await(n!==void 0?d(n,!0):h());return e!==void 0?e.close():!1},a=async n=>{const e=await d(n,!0);return e?e.toggle():!1},m=async(n,e)=>{const s=await d(e);return s&&(s.disabled=!n),s},w=async(n,e)=>{const s=await d(e);return s&&(s.swipeGesture=n),s},p=async n=>{if(n!=null){const e=await d(n);return e!==void 0&&e.isOpen()}else return await h()!==void 0},y=async n=>{const e=await d(n);return e?!e.disabled:!1},d=async(n,e=!1)=>{if(await g(),n==="start"||n==="end"){const i=o.filter(u=>u.side===n&&!u.disabled);if(i.length>=1)return i.length>1&&e&&T(`menuController queried for a menu on the "${n}" side, but ${i.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`,i.map(u=>u.el)),i[0].el;const c=o.filter(u=>u.side===n);if(c.length>=1)return c.length>1&&e&&T(`menuController queried for a menu on the "${n}" side, but ${c.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`,c.map(u=>u.el)),c[0].el}else if(n!=null)return b(i=>i.menuId===n);const s=b(i=>!i.disabled);return s||(o.length>0?o[0].el:void 0)},h=async()=>(await g(),A()),_=async()=>(await g(),S()),$=async()=>(await g(),I()),E=(n,e)=>{t.set(n,e)},v=n=>{o.indexOf(n)<0&&o.push(n)},M=n=>{const e=o.indexOf(n);e>-1&&o.splice(e,1)},R=async(n,e,s,i)=>{if(I())return!1;if(e){const c=await h();c&&n.el!==c&&await c.setOpen(!1,!1)}return n._setOpen(e,s,i)},C=(n,e)=>{const s=t.get(n);if(!s)throw new Error("animation not registered");return s(e)},A=()=>b(n=>n._isOpen),S=()=>o.map(n=>n.el),I=()=>o.some(n=>n.isAnimating),b=n=>{const e=o.find(n);if(e!==void 0)return e.el},g=()=>Promise.all(Array.from(document.querySelectorAll("ion-menu")).map(n=>new Promise(e=>B(n,e))));return E("reveal",U),E("push",q),E("overlay",P),x===null||x===void 0||x.addEventListener("ionBackButton",n=>{const e=A();e&&n.detail.register(k,()=>e.close())}),{registerAnimation:E,get:d,getMenus:_,getOpen:h,isEnabled:y,swipeGesture:w,isAnimating:$,isOpen:p,enable:m,toggle:a,close:l,open:r,_getOpenSync:A,_createAnimation:C,_register:v,_unregister:M,_setOpen:R}},j=D();export{j as m};
