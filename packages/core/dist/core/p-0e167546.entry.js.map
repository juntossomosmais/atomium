{"version":3,"names":["reorderGroupCss","ReorderGroup","constructor","hostRef","this","lastToIndex","cachedHeights","scrollElTop","scrollElBottom","scrollElInitial","containerTop","containerBottom","state","disabled","disabledChanged","gesture","enable","async","contentEl","findClosestIonContent","el","scrollEl","getScrollElement","import","createGesture","gestureName","gesturePriority","threshold","direction","passive","canStart","detail","onStart","ev","onMove","onEnd","disconnectedCallback","destroy","undefined","complete","listOrReorder","Promise","resolve","completeReorder","selectedItemEl","target","event","reorderEl","closest","item","findReorderItem","data","preventDefault","heights","length","children","sum","i","child","offsetHeight","push","$ionIndex","box","getBoundingClientRect","top","bottom","scrollBox","scrollTop","AUTO_SCROLL_MARGIN","indexForItem","selectedItemHeight","classList","add","ITEM_REORDER_SELECTED","hapticSelectionStart","selectedItem","scroll","autoscroll","currentY","Math","max","min","deltaY","startY","normalizedY","toIndex","itemIndexForTop","fromIndex","hapticSelectionChanged","reorderMove","style","transform","ionItemReorder","emit","from","to","bind","hapticSelectionEnd","len","raf","ref","insertBefore","Array","isArray","reorderArray","transition","remove","itemHeight","value","posY","amount","SCROLL_JUMP","scrollBy","render","mode","getIonMode","h","Host","class","element","node","container","parent","parentElement","array","splice","slice"],"sources":["../../node_modules/@ionic/core/dist/collection/components/reorder-group/reorder-group.css?tag=ion-reorder-group","../../node_modules/@ionic/core/dist/collection/components/reorder-group/reorder-group.js"],"sourcesContent":[".reorder-list-active > * {\n  display: block;\n  transition: transform 300ms;\n  will-change: transform;\n}\n\n.reorder-enabled {\n  user-select: none;\n}\n\n.reorder-enabled ion-reorder {\n  display: block;\n  cursor: grab;\n  pointer-events: all;\n  touch-action: none;\n}\n\n.reorder-selected,\n.reorder-selected ion-reorder {\n  cursor: grabbing;\n}\n\n.reorder-selected {\n  position: relative;\n  /* stylelint-disable-next-line declaration-no-important */\n  transition: none !important;\n  box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);\n  opacity: 0.8;\n  z-index: 100;\n}\n\n.reorder-visible ion-reorder .reorder-icon {\n  transform: translate3d(0,  0,  0);\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, h } from '@stencil/core';\nimport { getIonMode } from '../../global/ionic-global';\nimport { findClosestIonContent, getScrollElement } from '../../utils/content';\nimport { raf } from '../../utils/helpers';\nimport { hapticSelectionChanged, hapticSelectionEnd, hapticSelectionStart } from '../../utils/native/haptic';\nexport class ReorderGroup {\n  constructor() {\n    this.lastToIndex = -1;\n    this.cachedHeights = [];\n    this.scrollElTop = 0;\n    this.scrollElBottom = 0;\n    this.scrollElInitial = 0;\n    this.containerTop = 0;\n    this.containerBottom = 0;\n    this.state = 0 /* ReorderGroupState.Idle */;\n    this.disabled = true;\n  }\n  disabledChanged() {\n    if (this.gesture) {\n      this.gesture.enable(!this.disabled);\n    }\n  }\n  async connectedCallback() {\n    const contentEl = findClosestIonContent(this.el);\n    if (contentEl) {\n      this.scrollEl = await getScrollElement(contentEl);\n    }\n    this.gesture = (await import('../../utils/gesture')).createGesture({\n      el: this.el,\n      gestureName: 'reorder',\n      gesturePriority: 110,\n      threshold: 0,\n      direction: 'y',\n      passive: false,\n      canStart: (detail) => this.canStart(detail),\n      onStart: (ev) => this.onStart(ev),\n      onMove: (ev) => this.onMove(ev),\n      onEnd: () => this.onEnd(),\n    });\n    this.disabledChanged();\n  }\n  disconnectedCallback() {\n    this.onEnd();\n    if (this.gesture) {\n      this.gesture.destroy();\n      this.gesture = undefined;\n    }\n  }\n  /**\n   * Completes the reorder operation. Must be called by the `ionItemReorder` event.\n   *\n   * If a list of items is passed, the list will be reordered and returned in the\n   * proper order.\n   *\n   * If no parameters are passed or if `true` is passed in, the reorder will complete\n   * and the item will remain in the position it was dragged to. If `false` is passed,\n   * the reorder will complete and the item will bounce back to its original position.\n   *\n   * @param listOrReorder A list of items to be sorted and returned in the new order or a\n   * boolean of whether or not the reorder should reposition the item.\n   */\n  complete(listOrReorder) {\n    return Promise.resolve(this.completeReorder(listOrReorder));\n  }\n  canStart(ev) {\n    if (this.selectedItemEl || this.state !== 0 /* ReorderGroupState.Idle */) {\n      return false;\n    }\n    const target = ev.event.target;\n    const reorderEl = target.closest('ion-reorder');\n    if (!reorderEl) {\n      return false;\n    }\n    const item = findReorderItem(reorderEl, this.el);\n    if (!item) {\n      return false;\n    }\n    ev.data = item;\n    return true;\n  }\n  onStart(ev) {\n    ev.event.preventDefault();\n    const item = (this.selectedItemEl = ev.data);\n    const heights = this.cachedHeights;\n    heights.length = 0;\n    const el = this.el;\n    const children = el.children;\n    if (!children || children.length === 0) {\n      return;\n    }\n    let sum = 0;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      sum += child.offsetHeight;\n      heights.push(sum);\n      child.$ionIndex = i;\n    }\n    const box = el.getBoundingClientRect();\n    this.containerTop = box.top;\n    this.containerBottom = box.bottom;\n    if (this.scrollEl) {\n      const scrollBox = this.scrollEl.getBoundingClientRect();\n      this.scrollElInitial = this.scrollEl.scrollTop;\n      this.scrollElTop = scrollBox.top + AUTO_SCROLL_MARGIN;\n      this.scrollElBottom = scrollBox.bottom - AUTO_SCROLL_MARGIN;\n    }\n    else {\n      this.scrollElInitial = 0;\n      this.scrollElTop = 0;\n      this.scrollElBottom = 0;\n    }\n    this.lastToIndex = indexForItem(item);\n    this.selectedItemHeight = item.offsetHeight;\n    this.state = 1 /* ReorderGroupState.Active */;\n    item.classList.add(ITEM_REORDER_SELECTED);\n    hapticSelectionStart();\n  }\n  onMove(ev) {\n    const selectedItem = this.selectedItemEl;\n    if (!selectedItem) {\n      return;\n    }\n    // Scroll if we reach the scroll margins\n    const scroll = this.autoscroll(ev.currentY);\n    // // Get coordinate\n    const top = this.containerTop - scroll;\n    const bottom = this.containerBottom - scroll;\n    const currentY = Math.max(top, Math.min(ev.currentY, bottom));\n    const deltaY = scroll + currentY - ev.startY;\n    const normalizedY = currentY - top;\n    const toIndex = this.itemIndexForTop(normalizedY);\n    if (toIndex !== this.lastToIndex) {\n      const fromIndex = indexForItem(selectedItem);\n      this.lastToIndex = toIndex;\n      hapticSelectionChanged();\n      this.reorderMove(fromIndex, toIndex);\n    }\n    // Update selected item position\n    selectedItem.style.transform = `translateY(${deltaY}px)`;\n  }\n  onEnd() {\n    const selectedItemEl = this.selectedItemEl;\n    this.state = 2 /* ReorderGroupState.Complete */;\n    if (!selectedItemEl) {\n      this.state = 0 /* ReorderGroupState.Idle */;\n      return;\n    }\n    const toIndex = this.lastToIndex;\n    const fromIndex = indexForItem(selectedItemEl);\n    if (toIndex === fromIndex) {\n      this.completeReorder();\n    }\n    else {\n      this.ionItemReorder.emit({\n        from: fromIndex,\n        to: toIndex,\n        complete: this.completeReorder.bind(this),\n      });\n    }\n    hapticSelectionEnd();\n  }\n  completeReorder(listOrReorder) {\n    const selectedItemEl = this.selectedItemEl;\n    if (selectedItemEl && this.state === 2 /* ReorderGroupState.Complete */) {\n      const children = this.el.children;\n      const len = children.length;\n      const toIndex = this.lastToIndex;\n      const fromIndex = indexForItem(selectedItemEl);\n      /**\n       * insertBefore and setting the transform\n       * needs to happen in the same frame otherwise\n       * there will be a duplicate transition. This primarily\n       * impacts Firefox where insertBefore and transform operations\n       * are happening in two separate frames.\n       */\n      raf(() => {\n        if (toIndex !== fromIndex && (listOrReorder === undefined || listOrReorder === true)) {\n          const ref = fromIndex < toIndex ? children[toIndex + 1] : children[toIndex];\n          this.el.insertBefore(selectedItemEl, ref);\n        }\n        for (let i = 0; i < len; i++) {\n          children[i].style['transform'] = '';\n        }\n      });\n      if (Array.isArray(listOrReorder)) {\n        listOrReorder = reorderArray(listOrReorder, fromIndex, toIndex);\n      }\n      selectedItemEl.style.transition = '';\n      selectedItemEl.classList.remove(ITEM_REORDER_SELECTED);\n      this.selectedItemEl = undefined;\n      this.state = 0 /* ReorderGroupState.Idle */;\n    }\n    return listOrReorder;\n  }\n  itemIndexForTop(deltaY) {\n    const heights = this.cachedHeights;\n    for (let i = 0; i < heights.length; i++) {\n      if (heights[i] > deltaY) {\n        return i;\n      }\n    }\n    return heights.length - 1;\n  }\n  /********* DOM WRITE ********* */\n  reorderMove(fromIndex, toIndex) {\n    const itemHeight = this.selectedItemHeight;\n    const children = this.el.children;\n    for (let i = 0; i < children.length; i++) {\n      const style = children[i].style;\n      let value = '';\n      if (i > fromIndex && i <= toIndex) {\n        value = `translateY(${-itemHeight}px)`;\n      }\n      else if (i < fromIndex && i >= toIndex) {\n        value = `translateY(${itemHeight}px)`;\n      }\n      style['transform'] = value;\n    }\n  }\n  autoscroll(posY) {\n    if (!this.scrollEl) {\n      return 0;\n    }\n    let amount = 0;\n    if (posY < this.scrollElTop) {\n      amount = -SCROLL_JUMP;\n    }\n    else if (posY > this.scrollElBottom) {\n      amount = SCROLL_JUMP;\n    }\n    if (amount !== 0) {\n      this.scrollEl.scrollBy(0, amount);\n    }\n    return this.scrollEl.scrollTop - this.scrollElInitial;\n  }\n  render() {\n    const mode = getIonMode(this);\n    return (h(Host, { class: {\n        [mode]: true,\n        'reorder-enabled': !this.disabled,\n        'reorder-list-active': this.state !== 0 /* ReorderGroupState.Idle */,\n      } }));\n  }\n  static get is() { return \"ion-reorder-group\"; }\n  static get originalStyleUrls() {\n    return {\n      \"$\": [\"reorder-group.scss\"]\n    };\n  }\n  static get styleUrls() {\n    return {\n      \"$\": [\"reorder-group.css\"]\n    };\n  }\n  static get properties() {\n    return {\n      \"disabled\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, the reorder will be hidden.\"\n        },\n        \"attribute\": \"disabled\",\n        \"reflect\": false,\n        \"defaultValue\": \"true\"\n      }\n    };\n  }\n  static get states() {\n    return {\n      \"state\": {}\n    };\n  }\n  static get events() {\n    return [{\n        \"method\": \"ionItemReorder\",\n        \"name\": \"ionItemReorder\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Event that needs to be listened to in order to complete the reorder action.\\nOnce the event has been emitted, the `complete()` method then needs\\nto be called in order to finalize the reorder action.\"\n        },\n        \"complexType\": {\n          \"original\": \"ItemReorderEventDetail\",\n          \"resolved\": \"ItemReorderEventDetail\",\n          \"references\": {\n            \"ItemReorderEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"./reorder-group-interface\"\n            }\n          }\n        }\n      }];\n  }\n  static get methods() {\n    return {\n      \"complete\": {\n        \"complexType\": {\n          \"signature\": \"(listOrReorder?: boolean | any[]) => Promise<any>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"listOrReorder A list of items to be sorted and returned in the new order or a\\nboolean of whether or not the reorder should reposition the item.\"\n                }],\n              \"text\": \"A list of items to be sorted and returned in the new order or a\\nboolean of whether or not the reorder should reposition the item.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<any>\"\n        },\n        \"docs\": {\n          \"text\": \"Completes the reorder operation. Must be called by the `ionItemReorder` event.\\n\\nIf a list of items is passed, the list will be reordered and returned in the\\nproper order.\\n\\nIf no parameters are passed or if `true` is passed in, the reorder will complete\\nand the item will remain in the position it was dragged to. If `false` is passed,\\nthe reorder will complete and the item will bounce back to its original position.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"listOrReorder A list of items to be sorted and returned in the new order or a\\nboolean of whether or not the reorder should reposition the item.\"\n            }]\n        }\n      }\n    };\n  }\n  static get elementRef() { return \"el\"; }\n  static get watchers() {\n    return [{\n        \"propName\": \"disabled\",\n        \"methodName\": \"disabledChanged\"\n      }];\n  }\n}\nconst indexForItem = (element) => {\n  return element['$ionIndex'];\n};\nconst findReorderItem = (node, container) => {\n  let parent;\n  while (node) {\n    parent = node.parentElement;\n    if (parent === container) {\n      return node;\n    }\n    node = parent;\n  }\n  return undefined;\n};\nconst AUTO_SCROLL_MARGIN = 60;\nconst SCROLL_JUMP = 10;\nconst ITEM_REORDER_SELECTED = 'reorder-selected';\nconst reorderArray = (array, from, to) => {\n  const element = array[from];\n  array.splice(from, 1);\n  array.splice(to, 0, element);\n  return array.slice();\n};\n"],"mappings":"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"}