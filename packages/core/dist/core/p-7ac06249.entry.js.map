{"version":3,"names":["contentCss","Content","constructor","hostRef","this","watchDog","isScrolling","lastScroll","queued","cTop","cBottom","isMainContent","resizeTimeout","detail","scrollTop","scrollLeft","type","event","undefined","startX","startY","startTime","currentX","currentY","velocityX","velocityY","deltaX","deltaY","currentTime","data","color","fullscreen","forceOverscroll","scrollX","scrollY","scrollEvents","connectedCallback","el","closest","disconnectedCallback","onScrollEnd","onAppLoad","resize","onResize","clearTimeout","setTimeout","offsetParent","shouldForceOverscroll","mode","getIonMode","isPlatform","readTask","readDimensions","forceUpdate","page","getPageElement","top","Math","max","offsetTop","bottom","offsetHeight","dirty","onScroll","ev","timeStamp","Date","now","shouldStart","onScrollStart","ts","updateScrollDetail","scrollEl","ionScroll","emit","async","Promise","resolve","componentOnReady","backgroundContentEl","scrollToTop","duration","scrollToPoint","getScrollElement","y","scrollHeight","clientHeight","x","promise","r","fromY","fromX","step","linearTime","min","easedT","pow","floor","requestAnimationFrame","ionScrollStart","clearInterval","setInterval","ionScrollEnd","render","rtl","isRTL","transitionShadow","TagType","h","Host","class","createColorClasses","hostContext","overscroll","style","ref","id","part","name","getParentElement","_a","parentElement","parentNode","host","tabs","timestamp","prevX","prevY","prevT","timeDelta"],"sources":["../../node_modules/@ionic/core/dist/collection/components/content/content.css?tag=ion-content&encapsulation=shadow","../../node_modules/@ionic/core/dist/collection/components/content/content.js"],"sourcesContent":[":host {\n  /**\n   * @prop --background: Background of the content\n   *\n   * @prop --color: Color of the content\n   *\n   * @prop --padding-top: Top padding of the content\n   * @prop --padding-end: Right padding if direction is left-to-right, and left padding if direction is right-to-left of the content\n   * @prop --padding-bottom: Bottom padding of the content\n   * @prop --padding-start: Left padding if direction is left-to-right, and right padding if direction is right-to-left of the content\n   *\n   * @prop --keyboard-offset: Keyboard offset of the content\n   *\n   * @prop --offset-top: Offset top of the content\n   * @prop --offset-bottom: Offset bottom of the content\n   */\n  --background: var(--ion-background-color, #fff);\n  --color: var(--ion-text-color, #000);\n  --padding-top: 0px;\n  --padding-bottom: 0px;\n  --padding-start: 0px;\n  --padding-end: 0px;\n  --keyboard-offset: 0px;\n  --offset-top: 0px;\n  --offset-bottom: 0px;\n  --overflow: auto;\n  display: block;\n  position: relative;\n  flex: 1;\n  width: 100%;\n  height: 100%;\n  /* stylelint-disable */\n  margin: 0 !important;\n  padding: 0 !important;\n  /* stylelint-enable */\n  font-family: var(--ion-font-family, inherit);\n  contain: size style;\n}\n\n:host(.ion-color) .inner-scroll {\n  background: var(--ion-color-base);\n  color: var(--ion-color-contrast);\n}\n\n:host(.outer-content) {\n  --background: var(--ion-color-step-50, #f2f2f2);\n}\n\n#background-content {\n  left: 0px;\n  right: 0px;\n  top: calc(var(--offset-top) * -1);\n  bottom: calc(var(--offset-bottom) * -1);\n  position: absolute;\n  background: var(--background);\n}\n\n.inner-scroll {\n  left: 0px;\n  right: 0px;\n  top: calc(var(--offset-top) * -1);\n  bottom: calc(var(--offset-bottom) * -1);\n  -webkit-padding-start: var(--padding-start);\n  padding-inline-start: var(--padding-start);\n  -webkit-padding-end: var(--padding-end);\n  padding-inline-end: var(--padding-end);\n  padding-top: calc(var(--padding-top) + var(--offset-top));\n  padding-bottom: calc(var(--padding-bottom) + var(--keyboard-offset) + var(--offset-bottom));\n  position: absolute;\n  color: var(--color);\n  box-sizing: border-box;\n  overflow: hidden;\n  /**\n   * touch-action: manipulation is an alias\n   * for this, but WebKit has an issue\n   * where pointercancel events are not fired\n   * when scrolling: https://bugs.webkit.org/show_bug.cgi?id=240917\n   * Using the long form below avoids the issue.\n   */\n  touch-action: pan-x pan-y pinch-zoom;\n}\n\n.scroll-y,\n.scroll-x {\n  -webkit-overflow-scrolling: touch;\n  /**\n   * This adds `.inner-scroll` as part of the\n   * stacking context in WebKit. Without it,\n   * children of ion-content are treated as\n   * siblings rather than descendants. This\n   * can result in the children being put\n   * into their own layers, degrading\n   * scrolling performance.\n   *\n   * An optimization called \"layer backing\n   * sharing\" usually kicks in to prevent\n   * this, but having translate3d defeats\n   * this optimization.\n   *\n   * See: https://bugs.webkit.org/show_bug.cgi?id=216701\n   */\n  z-index: 0;\n  will-change: scroll-position;\n}\n\n.scroll-y {\n  overflow-y: var(--overflow);\n  overscroll-behavior-y: contain;\n}\n\n.scroll-x {\n  overflow-x: var(--overflow);\n  overscroll-behavior-x: contain;\n}\n\n.overscroll::before,\n.overscroll::after {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  content: \"\";\n}\n\n.overscroll::before {\n  bottom: -1px;\n}\n\n.overscroll::after {\n  top: -1px;\n}\n\n:host(.content-sizing) {\n  display: flex;\n  flex-direction: column;\n  /**\n   * This resolves a sizing issue in popovers where extra long content\n   * would overflow the popover's height, preventing scrolling. It's a\n   * quirk of flexbox that forces the content to shrink to fit.\n   *\n   * overflow: hidden can't be used here because it prevents the visual\n   * effect from showing on translucent headers.\n   */\n  min-height: 0;\n  contain: none;\n}\n\n:host(.content-sizing) .inner-scroll {\n  position: relative;\n  /**\n   * Because the outer content has display: flex here (to help enable\n   * scrolling in a popover), offsetting via `top` (such as when using\n   * a translucent header) creates white space under the content. Use\n   * a negative margin instead to keep the bottom in place. (A similar\n   * thing happens with `bottom` and footers.)\n   */\n  top: 0;\n  bottom: 0;\n  margin-top: calc(var(--offset-top) * -1);\n  margin-bottom: calc(var(--offset-bottom) * -1);\n}\n\n.transition-effect {\n  display: none;\n  position: absolute;\n  width: 100%;\n  height: 100vh;\n  opacity: 0;\n  pointer-events: none;\n}\n\n:host(.content-ltr) .transition-effect {\n  /* stylelint-disable property-disallowed-list */\n  left: -100%;\n  /* stylelint-enable property-disallowed-list */\n}\n\n:host(.content-rtl) .transition-effect {\n  /* stylelint-disable property-disallowed-list */\n  right: -100%;\n  /* stylelint-enable property-disallowed-list */\n}\n\n.transition-cover {\n  position: absolute;\n  /* stylelint-disable property-disallowed-list */\n  right: 0;\n  /* stylelint-enable property-disallowed-list */\n  width: 100%;\n  height: 100%;\n  background: black;\n  opacity: 0.1;\n}\n\n.transition-shadow {\n  display: block;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  box-shadow: inset -9px 0 9px 0 rgba(0, 0, 100, 0.03);\n}\n\n:host(.content-ltr) .transition-shadow {\n  /* stylelint-disable property-disallowed-list */\n  right: 0;\n  /* stylelint-enable property-disallowed-list */\n}\n\n:host(.content-rtl) .transition-shadow {\n  /* stylelint-disable property-disallowed-list */\n  left: 0;\n  /* stylelint-enable property-disallowed-list */\n  transform: scaleX(-1);\n}\n\n::slotted([slot=fixed]) {\n  position: absolute;\n  /**\n   * When presenting ion-content inside of an ion-modal, the .inner-scroll\n   * element is composited. In WebKit, the fixed content is not composited\n   * causing it to appear under the main scrollable content as a result.\n   * The fixed content is correctly composited in other browsers. Adding\n   * the translateZ forces the fixed content to be composited so it correctly\n   * shows on top of the scrollable content. Setting a negative z-index will\n   * still allow the fixed content to appear under the scroll content if specified.\n   */\n  transform: translateZ(0);\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, forceUpdate, h, readTask } from '@stencil/core';\nimport { getIonMode } from '../../global/ionic-global';\nimport { componentOnReady } from '../../utils/helpers';\nimport { isPlatform } from '../../utils/platform';\nimport { isRTL } from '../../utils/rtl';\nimport { createColorClasses, hostContext } from '../../utils/theme';\n/**\n * @slot - Content is placed in the scrollable area if provided without a slot.\n * @slot fixed - Should be used for fixed content that should not scroll.\n *\n * @part background - The background of the content.\n * @part scroll - The scrollable container of the content.\n */\nexport class Content {\n  constructor() {\n    this.watchDog = null;\n    this.isScrolling = false;\n    this.lastScroll = 0;\n    this.queued = false;\n    this.cTop = -1;\n    this.cBottom = -1;\n    this.isMainContent = true;\n    this.resizeTimeout = null;\n    // Detail is used in a hot loop in the scroll event, by allocating it here\n    // V8 will be able to inline any read/write to it since it's a monomorphic class.\n    // https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html\n    this.detail = {\n      scrollTop: 0,\n      scrollLeft: 0,\n      type: 'scroll',\n      event: undefined,\n      startX: 0,\n      startY: 0,\n      startTime: 0,\n      currentX: 0,\n      currentY: 0,\n      velocityX: 0,\n      velocityY: 0,\n      deltaX: 0,\n      deltaY: 0,\n      currentTime: 0,\n      data: undefined,\n      isScrolling: true,\n    };\n    this.color = undefined;\n    this.fullscreen = false;\n    this.forceOverscroll = undefined;\n    this.scrollX = false;\n    this.scrollY = true;\n    this.scrollEvents = false;\n  }\n  connectedCallback() {\n    this.isMainContent = this.el.closest('ion-menu, ion-popover, ion-modal') === null;\n  }\n  disconnectedCallback() {\n    this.onScrollEnd();\n  }\n  onAppLoad() {\n    this.resize();\n  }\n  /**\n   * Rotating certain devices can update\n   * the safe area insets. As a result,\n   * the fullscreen feature on ion-content\n   * needs to be recalculated.\n   *\n   * We listen for \"resize\" because we\n   * do not care what the orientation of\n   * the device is. Other APIs\n   * such as ScreenOrientation or\n   * the deviceorientation event must have\n   * permission from the user first whereas\n   * the \"resize\" event does not.\n   *\n   * We also throttle the callback to minimize\n   * thrashing when quickly resizing a window.\n   */\n  onResize() {\n    if (this.resizeTimeout) {\n      clearTimeout(this.resizeTimeout);\n      this.resizeTimeout = null;\n    }\n    this.resizeTimeout = setTimeout(() => {\n      /**\n       * Resize should only happen\n       * if the content is visible.\n       * When the content is hidden\n       * then offsetParent will be null.\n       */\n      if (this.el.offsetParent === null) {\n        return;\n      }\n      this.resize();\n    }, 100);\n  }\n  shouldForceOverscroll() {\n    const { forceOverscroll } = this;\n    const mode = getIonMode(this);\n    return forceOverscroll === undefined ? mode === 'ios' && isPlatform('ios') : forceOverscroll;\n  }\n  resize() {\n    if (this.fullscreen) {\n      readTask(() => this.readDimensions());\n    }\n    else if (this.cTop !== 0 || this.cBottom !== 0) {\n      this.cTop = this.cBottom = 0;\n      forceUpdate(this);\n    }\n  }\n  readDimensions() {\n    const page = getPageElement(this.el);\n    const top = Math.max(this.el.offsetTop, 0);\n    const bottom = Math.max(page.offsetHeight - top - this.el.offsetHeight, 0);\n    const dirty = top !== this.cTop || bottom !== this.cBottom;\n    if (dirty) {\n      this.cTop = top;\n      this.cBottom = bottom;\n      forceUpdate(this);\n    }\n  }\n  onScroll(ev) {\n    const timeStamp = Date.now();\n    const shouldStart = !this.isScrolling;\n    this.lastScroll = timeStamp;\n    if (shouldStart) {\n      this.onScrollStart();\n    }\n    if (!this.queued && this.scrollEvents) {\n      this.queued = true;\n      readTask((ts) => {\n        this.queued = false;\n        this.detail.event = ev;\n        updateScrollDetail(this.detail, this.scrollEl, ts, shouldStart);\n        this.ionScroll.emit(this.detail);\n      });\n    }\n  }\n  /**\n   * Get the element where the actual scrolling takes place.\n   * This element can be used to subscribe to `scroll` events or manually modify\n   * `scrollTop`. However, it's recommended to use the API provided by `ion-content`:\n   *\n   * i.e. Using `ionScroll`, `ionScrollStart`, `ionScrollEnd` for scrolling events\n   * and `scrollToPoint()` to scroll the content into a certain point.\n   */\n  async getScrollElement() {\n    /**\n     * If this gets called in certain early lifecycle hooks (ex: Vue onMounted),\n     * scrollEl won't be defined yet with the custom elements build, so wait for it to load in.\n     */\n    if (!this.scrollEl) {\n      await new Promise((resolve) => componentOnReady(this.el, resolve));\n    }\n    return Promise.resolve(this.scrollEl);\n  }\n  /**\n   * Returns the background content element.\n   * @internal\n   */\n  async getBackgroundElement() {\n    if (!this.backgroundContentEl) {\n      await new Promise((resolve) => componentOnReady(this.el, resolve));\n    }\n    return Promise.resolve(this.backgroundContentEl);\n  }\n  /**\n   * Scroll to the top of the component.\n   *\n   * @param duration The amount of time to take scrolling to the top. Defaults to `0`.\n   */\n  scrollToTop(duration = 0) {\n    return this.scrollToPoint(undefined, 0, duration);\n  }\n  /**\n   * Scroll to the bottom of the component.\n   *\n   * @param duration The amount of time to take scrolling to the bottom. Defaults to `0`.\n   */\n  async scrollToBottom(duration = 0) {\n    const scrollEl = await this.getScrollElement();\n    const y = scrollEl.scrollHeight - scrollEl.clientHeight;\n    return this.scrollToPoint(undefined, y, duration);\n  }\n  /**\n   * Scroll by a specified X/Y distance in the component.\n   *\n   * @param x The amount to scroll by on the horizontal axis.\n   * @param y The amount to scroll by on the vertical axis.\n   * @param duration The amount of time to take scrolling by that amount.\n   */\n  async scrollByPoint(x, y, duration) {\n    const scrollEl = await this.getScrollElement();\n    return this.scrollToPoint(x + scrollEl.scrollLeft, y + scrollEl.scrollTop, duration);\n  }\n  /**\n   * Scroll to a specified X/Y location in the component.\n   *\n   * @param x The point to scroll to on the horizontal axis.\n   * @param y The point to scroll to on the vertical axis.\n   * @param duration The amount of time to take scrolling to that point. Defaults to `0`.\n   */\n  async scrollToPoint(x, y, duration = 0) {\n    const el = await this.getScrollElement();\n    if (duration < 32) {\n      if (y != null) {\n        el.scrollTop = y;\n      }\n      if (x != null) {\n        el.scrollLeft = x;\n      }\n      return;\n    }\n    let resolve;\n    let startTime = 0;\n    const promise = new Promise((r) => (resolve = r));\n    const fromY = el.scrollTop;\n    const fromX = el.scrollLeft;\n    const deltaY = y != null ? y - fromY : 0;\n    const deltaX = x != null ? x - fromX : 0;\n    // scroll loop\n    const step = (timeStamp) => {\n      const linearTime = Math.min(1, (timeStamp - startTime) / duration) - 1;\n      const easedT = Math.pow(linearTime, 3) + 1;\n      if (deltaY !== 0) {\n        el.scrollTop = Math.floor(easedT * deltaY + fromY);\n      }\n      if (deltaX !== 0) {\n        el.scrollLeft = Math.floor(easedT * deltaX + fromX);\n      }\n      if (easedT < 1) {\n        // do not use DomController here\n        // must use nativeRaf in order to fire in the next frame\n        requestAnimationFrame(step);\n      }\n      else {\n        resolve();\n      }\n    };\n    // chill out for a frame first\n    requestAnimationFrame((ts) => {\n      startTime = ts;\n      step(ts);\n    });\n    return promise;\n  }\n  onScrollStart() {\n    this.isScrolling = true;\n    this.ionScrollStart.emit({\n      isScrolling: true,\n    });\n    if (this.watchDog) {\n      clearInterval(this.watchDog);\n    }\n    // watchdog\n    this.watchDog = setInterval(() => {\n      if (this.lastScroll < Date.now() - 120) {\n        this.onScrollEnd();\n      }\n    }, 100);\n  }\n  onScrollEnd() {\n    if (this.watchDog)\n      clearInterval(this.watchDog);\n    this.watchDog = null;\n    if (this.isScrolling) {\n      this.isScrolling = false;\n      this.ionScrollEnd.emit({\n        isScrolling: false,\n      });\n    }\n  }\n  render() {\n    const { isMainContent, scrollX, scrollY, el } = this;\n    const rtl = isRTL(el) ? 'rtl' : 'ltr';\n    const mode = getIonMode(this);\n    const forceOverscroll = this.shouldForceOverscroll();\n    const transitionShadow = mode === 'ios';\n    const TagType = isMainContent ? 'main' : 'div';\n    this.resize();\n    return (h(Host, { class: createColorClasses(this.color, {\n        [mode]: true,\n        'content-sizing': hostContext('ion-popover', this.el),\n        overscroll: forceOverscroll,\n        [`content-${rtl}`]: true,\n      }), style: {\n        '--offset-top': `${this.cTop}px`,\n        '--offset-bottom': `${this.cBottom}px`,\n      } }, h(\"div\", { ref: (el) => (this.backgroundContentEl = el), id: \"background-content\", part: \"background\" }), h(TagType, { class: {\n        'inner-scroll': true,\n        'scroll-x': scrollX,\n        'scroll-y': scrollY,\n        overscroll: (scrollX || scrollY) && forceOverscroll,\n      }, ref: (scrollEl) => (this.scrollEl = scrollEl), onScroll: this.scrollEvents ? (ev) => this.onScroll(ev) : undefined, part: \"scroll\" }, h(\"slot\", null)), transitionShadow ? (h(\"div\", { class: \"transition-effect\" }, h(\"div\", { class: \"transition-cover\" }), h(\"div\", { class: \"transition-shadow\" }))) : null, h(\"slot\", { name: \"fixed\" })));\n  }\n  static get is() { return \"ion-content\"; }\n  static get encapsulation() { return \"shadow\"; }\n  static get originalStyleUrls() {\n    return {\n      \"$\": [\"content.scss\"]\n    };\n  }\n  static get styleUrls() {\n    return {\n      \"$\": [\"content.css\"]\n    };\n  }\n  static get properties() {\n    return {\n      \"color\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"Color\",\n          \"resolved\": \"\\\"danger\\\" | \\\"dark\\\" | \\\"light\\\" | \\\"medium\\\" | \\\"primary\\\" | \\\"secondary\\\" | \\\"success\\\" | \\\"tertiary\\\" | \\\"warning\\\" | string & Record<never, never> | undefined\",\n          \"references\": {\n            \"Color\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"The color to use from your application's color palette.\\nDefault options are: `\\\"primary\\\"`, `\\\"secondary\\\"`, `\\\"tertiary\\\"`, `\\\"success\\\"`, `\\\"warning\\\"`, `\\\"danger\\\"`, `\\\"light\\\"`, `\\\"medium\\\"`, and `\\\"dark\\\"`.\\nFor more information on colors, see [theming](/docs/theming/basics).\"\n        },\n        \"attribute\": \"color\",\n        \"reflect\": true\n      },\n      \"fullscreen\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, the content will scroll behind the headers\\nand footers. This effect can easily be seen by setting the toolbar\\nto transparent.\"\n        },\n        \"attribute\": \"fullscreen\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      },\n      \"forceOverscroll\": {\n        \"type\": \"boolean\",\n        \"mutable\": true,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean | undefined\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true` and the content does not cause an overflow scroll, the scroll interaction will cause a bounce.\\nIf the content exceeds the bounds of ionContent, nothing will change.\\nNote, this does not disable the system bounce on iOS. That is an OS level setting.\"\n        },\n        \"attribute\": \"force-overscroll\",\n        \"reflect\": false\n      },\n      \"scrollX\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If you want to enable the content scrolling in the X axis, set this property to `true`.\"\n        },\n        \"attribute\": \"scroll-x\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      },\n      \"scrollY\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If you want to disable the content scrolling in the Y axis, set this property to `false`.\"\n        },\n        \"attribute\": \"scroll-y\",\n        \"reflect\": false,\n        \"defaultValue\": \"true\"\n      },\n      \"scrollEvents\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Because of performance reasons, ionScroll events are disabled by default, in order to enable them\\nand start listening from (ionScroll), set this property to `true`.\"\n        },\n        \"attribute\": \"scroll-events\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      }\n    };\n  }\n  static get events() {\n    return [{\n        \"method\": \"ionScrollStart\",\n        \"name\": \"ionScrollStart\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the scroll has started. This event is disabled by default.\\nSet `scrollEvents` to `true` to enable.\"\n        },\n        \"complexType\": {\n          \"original\": \"ScrollBaseDetail\",\n          \"resolved\": \"ScrollBaseDetail\",\n          \"references\": {\n            \"ScrollBaseDetail\": {\n              \"location\": \"import\",\n              \"path\": \"./content-interface\"\n            }\n          }\n        }\n      }, {\n        \"method\": \"ionScroll\",\n        \"name\": \"ionScroll\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted while scrolling. This event is disabled by default.\\nSet `scrollEvents` to `true` to enable.\"\n        },\n        \"complexType\": {\n          \"original\": \"ScrollDetail\",\n          \"resolved\": \"ScrollDetail\",\n          \"references\": {\n            \"ScrollDetail\": {\n              \"location\": \"import\",\n              \"path\": \"./content-interface\"\n            }\n          }\n        }\n      }, {\n        \"method\": \"ionScrollEnd\",\n        \"name\": \"ionScrollEnd\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the scroll has ended. This event is disabled by default.\\nSet `scrollEvents` to `true` to enable.\"\n        },\n        \"complexType\": {\n          \"original\": \"ScrollBaseDetail\",\n          \"resolved\": \"ScrollBaseDetail\",\n          \"references\": {\n            \"ScrollBaseDetail\": {\n              \"location\": \"import\",\n              \"path\": \"./content-interface\"\n            }\n          }\n        }\n      }];\n  }\n  static get methods() {\n    return {\n      \"getScrollElement\": {\n        \"complexType\": {\n          \"signature\": \"() => Promise<HTMLElement>\",\n          \"parameters\": [],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"HTMLElement\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<HTMLElement>\"\n        },\n        \"docs\": {\n          \"text\": \"Get the element where the actual scrolling takes place.\\nThis element can be used to subscribe to `scroll` events or manually modify\\n`scrollTop`. However, it's recommended to use the API provided by `ion-content`:\\n\\ni.e. Using `ionScroll`, `ionScrollStart`, `ionScrollEnd` for scrolling events\\nand `scrollToPoint()` to scroll the content into a certain point.\",\n          \"tags\": []\n        }\n      },\n      \"getBackgroundElement\": {\n        \"complexType\": {\n          \"signature\": \"() => Promise<HTMLElement>\",\n          \"parameters\": [],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"HTMLElement\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<HTMLElement>\"\n        },\n        \"docs\": {\n          \"text\": \"Returns the background content element.\",\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }]\n        }\n      },\n      \"scrollToTop\": {\n        \"complexType\": {\n          \"signature\": \"(duration?: number) => Promise<void>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"duration The amount of time to take scrolling to the top. Defaults to `0`.\"\n                }],\n              \"text\": \"The amount of time to take scrolling to the top. Defaults to `0`.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<void>\"\n        },\n        \"docs\": {\n          \"text\": \"Scroll to the top of the component.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"duration The amount of time to take scrolling to the top. Defaults to `0`.\"\n            }]\n        }\n      },\n      \"scrollToBottom\": {\n        \"complexType\": {\n          \"signature\": \"(duration?: number) => Promise<void>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"duration The amount of time to take scrolling to the bottom. Defaults to `0`.\"\n                }],\n              \"text\": \"The amount of time to take scrolling to the bottom. Defaults to `0`.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<void>\"\n        },\n        \"docs\": {\n          \"text\": \"Scroll to the bottom of the component.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"duration The amount of time to take scrolling to the bottom. Defaults to `0`.\"\n            }]\n        }\n      },\n      \"scrollByPoint\": {\n        \"complexType\": {\n          \"signature\": \"(x: number, y: number, duration: number) => Promise<void>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"x The amount to scroll by on the horizontal axis.\"\n                }],\n              \"text\": \"The amount to scroll by on the horizontal axis.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"y The amount to scroll by on the vertical axis.\"\n                }],\n              \"text\": \"The amount to scroll by on the vertical axis.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"duration The amount of time to take scrolling by that amount.\"\n                }],\n              \"text\": \"The amount of time to take scrolling by that amount.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<void>\"\n        },\n        \"docs\": {\n          \"text\": \"Scroll by a specified X/Y distance in the component.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"x The amount to scroll by on the horizontal axis.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"y The amount to scroll by on the vertical axis.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"duration The amount of time to take scrolling by that amount.\"\n            }]\n        }\n      },\n      \"scrollToPoint\": {\n        \"complexType\": {\n          \"signature\": \"(x: number | undefined | null, y: number | undefined | null, duration?: number) => Promise<void>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"x The point to scroll to on the horizontal axis.\"\n                }],\n              \"text\": \"The point to scroll to on the horizontal axis.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"y The point to scroll to on the vertical axis.\"\n                }],\n              \"text\": \"The point to scroll to on the vertical axis.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"duration The amount of time to take scrolling to that point. Defaults to `0`.\"\n                }],\n              \"text\": \"The amount of time to take scrolling to that point. Defaults to `0`.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<void>\"\n        },\n        \"docs\": {\n          \"text\": \"Scroll to a specified X/Y location in the component.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"x The point to scroll to on the horizontal axis.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"y The point to scroll to on the vertical axis.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"duration The amount of time to take scrolling to that point. Defaults to `0`.\"\n            }]\n        }\n      }\n    };\n  }\n  static get elementRef() { return \"el\"; }\n  static get listeners() {\n    return [{\n        \"name\": \"appload\",\n        \"method\": \"onAppLoad\",\n        \"target\": \"window\",\n        \"capture\": false,\n        \"passive\": false\n      }, {\n        \"name\": \"resize\",\n        \"method\": \"onResize\",\n        \"target\": \"window\",\n        \"capture\": false,\n        \"passive\": true\n      }];\n  }\n}\nconst getParentElement = (el) => {\n  var _a;\n  if (el.parentElement) {\n    // normal element with a parent element\n    return el.parentElement;\n  }\n  if ((_a = el.parentNode) === null || _a === void 0 ? void 0 : _a.host) {\n    // shadow dom's document fragment\n    return el.parentNode.host;\n  }\n  return null;\n};\nconst getPageElement = (el) => {\n  const tabs = el.closest('ion-tabs');\n  if (tabs) {\n    return tabs;\n  }\n  /**\n   * If we're in a popover, we need to use its wrapper so we can account for space\n   * between the popover and the edges of the screen. But if the popover contains\n   * its own page element, we should use that instead.\n   */\n  const page = el.closest('ion-app, ion-page, .ion-page, page-inner, .popover-content');\n  if (page) {\n    return page;\n  }\n  return getParentElement(el);\n};\n// ******** DOM READ ****************\nconst updateScrollDetail = (detail, el, timestamp, shouldStart) => {\n  const prevX = detail.currentX;\n  const prevY = detail.currentY;\n  const prevT = detail.currentTime;\n  const currentX = el.scrollLeft;\n  const currentY = el.scrollTop;\n  const timeDelta = timestamp - prevT;\n  if (shouldStart) {\n    // remember the start positions\n    detail.startTime = timestamp;\n    detail.startX = currentX;\n    detail.startY = currentY;\n    detail.velocityX = detail.velocityY = 0;\n  }\n  detail.currentTime = timestamp;\n  detail.currentX = detail.scrollLeft = currentX;\n  detail.currentY = detail.scrollTop = currentY;\n  detail.deltaX = currentX - detail.startX;\n  detail.deltaY = currentY - detail.startY;\n  if (timeDelta > 0 && timeDelta < 100) {\n    const velocityX = (currentX - prevX) / timeDelta;\n    const velocityY = (currentY - prevY) / timeDelta;\n    detail.velocityX = velocityX * 0.7 + detail.velocityX * 0.3;\n    detail.velocityY = velocityY * 0.7 + detail.velocityY * 0.3;\n  }\n};\n"],"mappings":"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"}