{"version":3,"names":["lastId","activeAnimations","WeakMap","createController","tagName","create","options","createOverlay","dismiss","data","role","id","dismissOverlay","document","async","getOverlay","alertController","actionSheetController","popoverController","prepareOverlay","el","connectListeners","overlayIndex","hasAttribute","opts","window","customElements","whenDefined","then","element","createElement","classList","add","Object","assign","hasController","getAppRoot","appendChild","Promise","resolve","componentOnReady","focusableQueryString","focusFirstDescendant","ref","overlay","firstInput","querySelector","shadowRoot","focusElement","focus","isOverlayHidden","contains","focusLastDescendant","inputs","Array","from","querySelectorAll","lastInput","length","trapKeyboardFocus","ev","doc","lastOverlay","target","trapScopedFocus","lastFocus","undefined","overlayRoot","getElementRoot","overlayWrapper","activeElement","trapShadowFocus","addEventListener","backdropDismiss","detail","register","OVERLAY_BACK_BUTTON_PRIORITY","BACKDROP","key","overlayTag","reject","getOverlays","selector","filter","c","overlays","o","find","setRootAriaHidden","hidden","root","viewContainer","setAttribute","removeAttribute","present","name","iosEnterAnimation","mdEnterAnimation","_a","_b","presented","willPresent","emit","willPresentShorthand","mode","getIonMode","animationBuilder","enterAnimation","config","get","completed","overlayAnimation","didPresent","didPresentShorthand","focusPreviousElementOnDismiss","keyboardClose","overlayEl","previousElement","onDidDismiss","iosLeaveAnimation","mdLeaveAnimation","style","setProperty","willDismiss","willDismissShorthand","leaveAnimation","GESTURE","didDismiss","didDismissShorthand","delete","removeProperty","err","console","error","remove","body","baseEl","aniRoot","animation","animated","getBoolean","duration","beforeAddWrite","ownerDocument","matches","blur","activeAni","set","play","eventMethod","eventName","promise","r","onceEvent","event","callback","handler","removeEventListener","isCancel","defaultGate","h","safeCall","arg","jmp","e","createDelegateController","inline","workingDelegate","coreDelegate","CoreDelegate","getDelegate","force","delegate","parentEl","parentNode","attachViewToDom","component","Error","removeViewFromDom","parentElement","createTriggerController","destroyTriggerInteraction","removeClickListener","addClickListener","trigger","triggerEl","getElementById","printIonWarning","configureTriggerInteraction","targetEl","openOverlay"],"sources":["../../node_modules/@ionic/core/dist/collection/utils/overlays.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { config } from '../global/config';\nimport { getIonMode } from '../global/ionic-global';\nimport { CoreDelegate } from './framework-delegate';\nimport { OVERLAY_BACK_BUTTON_PRIORITY } from './hardware-back-button';\nimport { addEventListener, componentOnReady, focusElement, getElementRoot, removeEventListener } from './helpers';\nimport { printIonWarning } from './logging';\nlet lastId = 0;\nexport const activeAnimations = new WeakMap();\nconst createController = (tagName) => {\n  return {\n    create(options) {\n      return createOverlay(tagName, options);\n    },\n    dismiss(data, role, id) {\n      return dismissOverlay(document, data, role, tagName, id);\n    },\n    async getTop() {\n      return getOverlay(document, tagName);\n    },\n  };\n};\nexport const alertController = /*@__PURE__*/ createController('ion-alert');\nexport const actionSheetController = /*@__PURE__*/ createController('ion-action-sheet');\nexport const loadingController = /*@__PURE__*/ createController('ion-loading');\nexport const modalController = /*@__PURE__*/ createController('ion-modal');\nexport const pickerController = /*@__PURE__*/ createController('ion-picker');\nexport const popoverController = /*@__PURE__*/ createController('ion-popover');\nexport const toastController = /*@__PURE__*/ createController('ion-toast');\nexport const prepareOverlay = (el) => {\n  if (typeof document !== 'undefined') {\n    connectListeners(document);\n  }\n  const overlayIndex = lastId++;\n  el.overlayIndex = overlayIndex;\n  if (!el.hasAttribute('id')) {\n    el.id = `ion-overlay-${overlayIndex}`;\n  }\n};\nexport const createOverlay = (tagName, opts) => {\n  if (typeof window !== 'undefined' && typeof window.customElements !== 'undefined') {\n    return window.customElements.whenDefined(tagName).then(() => {\n      const element = document.createElement(tagName);\n      element.classList.add('overlay-hidden');\n      /**\n       * Convert the passed in overlay options into props\n       * that get passed down into the new overlay.\n       */\n      Object.assign(element, Object.assign(Object.assign({}, opts), { hasController: true }));\n      // append the overlay element to the document body\n      getAppRoot(document).appendChild(element);\n      return new Promise((resolve) => componentOnReady(element, resolve));\n    });\n  }\n  return Promise.resolve();\n};\n/**\n * This query string selects elements that\n * are eligible to receive focus. We select\n * interactive elements that meet the following\n * criteria:\n * 1. Element does not have a negative tabindex\n * 2. Element does not have `hidden`\n * 3. Element does not have `disabled` for non-Ionic components.\n * 4. Element does not have `disabled` or `disabled=\"true\"` for Ionic components.\n * Note: We need this distinction because `disabled=\"false\"` is\n * valid usage for the disabled property on ion-button.\n */\nconst focusableQueryString = '[tabindex]:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), input:not([type=hidden]):not([tabindex^=\"-\"]):not([hidden]):not([disabled]), textarea:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), button:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), select:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), .ion-focusable:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), .ion-focusable[disabled=\"false\"]:not([tabindex^=\"-\"]):not([hidden])';\nexport const focusFirstDescendant = (ref, overlay) => {\n  let firstInput = ref.querySelector(focusableQueryString);\n  const shadowRoot = firstInput === null || firstInput === void 0 ? void 0 : firstInput.shadowRoot;\n  if (shadowRoot) {\n    // If there are no inner focusable elements, just focus the host element.\n    firstInput = shadowRoot.querySelector(focusableQueryString) || firstInput;\n  }\n  if (firstInput) {\n    focusElement(firstInput);\n  }\n  else {\n    // Focus overlay instead of letting focus escape\n    overlay.focus();\n  }\n};\nconst isOverlayHidden = (overlay) => overlay.classList.contains('overlay-hidden');\nconst focusLastDescendant = (ref, overlay) => {\n  const inputs = Array.from(ref.querySelectorAll(focusableQueryString));\n  let lastInput = inputs.length > 0 ? inputs[inputs.length - 1] : null;\n  const shadowRoot = lastInput === null || lastInput === void 0 ? void 0 : lastInput.shadowRoot;\n  if (shadowRoot) {\n    // If there are no inner focusable elements, just focus the host element.\n    lastInput = shadowRoot.querySelector(focusableQueryString) || lastInput;\n  }\n  if (lastInput) {\n    lastInput.focus();\n  }\n  else {\n    // Focus overlay instead of letting focus escape\n    overlay.focus();\n  }\n};\n/**\n * Traps keyboard focus inside of overlay components.\n * Based on https://w3c.github.io/aria-practices/examples/dialog-modal/alertdialog.html\n * This includes the following components: Action Sheet, Alert, Loading, Modal,\n * Picker, and Popover.\n * Should NOT include: Toast\n */\nconst trapKeyboardFocus = (ev, doc) => {\n  const lastOverlay = getOverlay(doc, 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover');\n  const target = ev.target;\n  /**\n   * If no active overlay, ignore this event.\n   *\n   * If this component uses the shadow dom,\n   * this global listener is pointless\n   * since it will not catch the focus\n   * traps as they are inside the shadow root.\n   * We need to add a listener to the shadow root\n   * itself to ensure the focus trap works.\n   */\n  if (!lastOverlay || !target) {\n    return;\n  }\n  /**\n   * If the ion-disable-focus-trap class\n   * is present on an overlay, then this component\n   * instance has opted out of focus trapping.\n   * An example of this is when the sheet modal\n   * has a backdrop that is disabled. The content\n   * behind the sheet should be focusable until\n   * the backdrop is enabled.\n   */\n  if (lastOverlay.classList.contains('ion-disable-focus-trap')) {\n    return;\n  }\n  const trapScopedFocus = () => {\n    /**\n     * If we are focusing the overlay, clear\n     * the last focused element so that hitting\n     * tab activates the first focusable element\n     * in the overlay wrapper.\n     */\n    if (lastOverlay === target) {\n      lastOverlay.lastFocus = undefined;\n      /**\n       * Otherwise, we must be focusing an element\n       * inside of the overlay. The two possible options\n       * here are an input/button/etc or the ion-focus-trap\n       * element. The focus trap element is used to prevent\n       * the keyboard focus from leaving the overlay when\n       * using Tab or screen assistants.\n       */\n    }\n    else {\n      /**\n       * We do not want to focus the traps, so get the overlay\n       * wrapper element as the traps live outside of the wrapper.\n       */\n      const overlayRoot = getElementRoot(lastOverlay);\n      if (!overlayRoot.contains(target)) {\n        return;\n      }\n      const overlayWrapper = overlayRoot.querySelector('.ion-overlay-wrapper');\n      if (!overlayWrapper) {\n        return;\n      }\n      /**\n       * If the target is inside the wrapper, let the browser\n       * focus as normal and keep a log of the last focused element.\n       */\n      if (overlayWrapper.contains(target)) {\n        lastOverlay.lastFocus = target;\n      }\n      else {\n        /**\n         * Otherwise, we must have focused one of the focus traps.\n         * We need to wrap the focus to either the first element\n         * or the last element.\n         */\n        /**\n         * Once we call `focusFirstDescendant` and focus the first\n         * descendant, another focus event will fire which will\n         * cause `lastOverlay.lastFocus` to be updated before\n         * we can run the code after that. We will cache the value\n         * here to avoid that.\n         */\n        const lastFocus = lastOverlay.lastFocus;\n        // Focus the first element in the overlay wrapper\n        focusFirstDescendant(overlayWrapper, lastOverlay);\n        /**\n         * If the cached last focused element is the\n         * same as the active element, then we need\n         * to wrap focus to the last descendant. This happens\n         * when the first descendant is focused, and the user\n         * presses Shift + Tab. The previous line will focus\n         * the same descendant again (the first one), causing\n         * last focus to equal the active element.\n         */\n        if (lastFocus === doc.activeElement) {\n          focusLastDescendant(overlayWrapper, lastOverlay);\n        }\n        lastOverlay.lastFocus = doc.activeElement;\n      }\n    }\n  };\n  const trapShadowFocus = () => {\n    /**\n     * If the target is inside the wrapper, let the browser\n     * focus as normal and keep a log of the last focused element.\n     */\n    if (lastOverlay.contains(target)) {\n      lastOverlay.lastFocus = target;\n    }\n    else {\n      /**\n       * Otherwise, we are about to have focus\n       * go out of the overlay. We need to wrap\n       * the focus to either the first element\n       * or the last element.\n       */\n      /**\n       * Once we call `focusFirstDescendant` and focus the first\n       * descendant, another focus event will fire which will\n       * cause `lastOverlay.lastFocus` to be updated before\n       * we can run the code after that. We will cache the value\n       * here to avoid that.\n       */\n      const lastFocus = lastOverlay.lastFocus;\n      // Focus the first element in the overlay wrapper\n      focusFirstDescendant(lastOverlay, lastOverlay);\n      /**\n       * If the cached last focused element is the\n       * same as the active element, then we need\n       * to wrap focus to the last descendant. This happens\n       * when the first descendant is focused, and the user\n       * presses Shift + Tab. The previous line will focus\n       * the same descendant again (the first one), causing\n       * last focus to equal the active element.\n       */\n      if (lastFocus === doc.activeElement) {\n        focusLastDescendant(lastOverlay, lastOverlay);\n      }\n      lastOverlay.lastFocus = doc.activeElement;\n    }\n  };\n  if (lastOverlay.shadowRoot) {\n    trapShadowFocus();\n  }\n  else {\n    trapScopedFocus();\n  }\n};\nconst connectListeners = (doc) => {\n  if (lastId === 0) {\n    lastId = 1;\n    doc.addEventListener('focus', (ev) => {\n      trapKeyboardFocus(ev, doc);\n    }, true);\n    // handle back-button click\n    doc.addEventListener('ionBackButton', (ev) => {\n      const lastOverlay = getOverlay(doc);\n      if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {\n        ev.detail.register(OVERLAY_BACK_BUTTON_PRIORITY, () => {\n          return lastOverlay.dismiss(undefined, BACKDROP);\n        });\n      }\n    });\n    // handle ESC to close overlay\n    doc.addEventListener('keydown', (ev) => {\n      if (ev.key === 'Escape') {\n        const lastOverlay = getOverlay(doc);\n        if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {\n          lastOverlay.dismiss(undefined, BACKDROP);\n        }\n      }\n    });\n  }\n};\nexport const dismissOverlay = (doc, data, role, overlayTag, id) => {\n  const overlay = getOverlay(doc, overlayTag, id);\n  if (!overlay) {\n    return Promise.reject('overlay does not exist');\n  }\n  return overlay.dismiss(data, role);\n};\nexport const getOverlays = (doc, selector) => {\n  if (selector === undefined) {\n    selector = 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover,ion-toast';\n  }\n  return Array.from(doc.querySelectorAll(selector)).filter((c) => c.overlayIndex > 0);\n};\n/**\n * Returns an overlay element\n * @param doc The document to find the element within.\n * @param overlayTag The selector for the overlay, defaults to Ionic overlay components.\n * @param id The unique identifier for the overlay instance.\n * @returns The overlay element or `undefined` if no overlay element is found.\n */\nexport const getOverlay = (doc, overlayTag, id) => {\n  const overlays = getOverlays(doc, overlayTag).filter((o) => !isOverlayHidden(o));\n  return id === undefined ? overlays[overlays.length - 1] : overlays.find((o) => o.id === id);\n};\n/**\n * When an overlay is presented, the main\n * focus is the overlay not the page content.\n * We need to remove the page content from the\n * accessibility tree otherwise when\n * users use \"read screen from top\" gestures with\n * TalkBack and VoiceOver, the screen reader will begin\n * to read the content underneath the overlay.\n *\n * We need a container where all page components\n * exist that is separate from where the overlays\n * are added in the DOM. For most apps, this element\n * is the top most ion-router-outlet. In the event\n * that devs are not using a router,\n * they will need to add the \"ion-view-container-root\"\n * id to the element that contains all of their views.\n *\n * TODO: If Framework supports having multiple top\n * level router outlets we would need to update this.\n * Example: One outlet for side menu and one outlet\n * for main content.\n */\nexport const setRootAriaHidden = (hidden = false) => {\n  const root = getAppRoot(document);\n  const viewContainer = root.querySelector('ion-router-outlet, ion-nav, #ion-view-container-root');\n  if (!viewContainer) {\n    return;\n  }\n  if (hidden) {\n    viewContainer.setAttribute('aria-hidden', 'true');\n  }\n  else {\n    viewContainer.removeAttribute('aria-hidden');\n  }\n};\nexport const present = async (overlay, name, iosEnterAnimation, mdEnterAnimation, opts) => {\n  var _a, _b;\n  if (overlay.presented) {\n    return;\n  }\n  setRootAriaHidden(true);\n  overlay.presented = true;\n  overlay.willPresent.emit();\n  (_a = overlay.willPresentShorthand) === null || _a === void 0 ? void 0 : _a.emit();\n  const mode = getIonMode(overlay);\n  // get the user's animation fn if one was provided\n  const animationBuilder = overlay.enterAnimation\n    ? overlay.enterAnimation\n    : config.get(name, mode === 'ios' ? iosEnterAnimation : mdEnterAnimation);\n  const completed = await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n  if (completed) {\n    overlay.didPresent.emit();\n    (_b = overlay.didPresentShorthand) === null || _b === void 0 ? void 0 : _b.emit();\n  }\n  /**\n   * When an overlay that steals focus\n   * is dismissed, focus should be returned\n   * to the element that was focused\n   * prior to the overlay opening. Toast\n   * does not steal focus and is excluded\n   * from returning focus as a result.\n   */\n  if (overlay.el.tagName !== 'ION-TOAST') {\n    focusPreviousElementOnDismiss(overlay.el);\n  }\n  /**\n   * If the focused element is already\n   * inside the overlay component then\n   * focus should not be moved from that\n   * to the overlay container.\n   */\n  if (overlay.keyboardClose && (document.activeElement === null || !overlay.el.contains(document.activeElement))) {\n    overlay.el.focus();\n  }\n};\n/**\n * When an overlay component is dismissed,\n * focus should be returned to the element\n * that presented the overlay. Otherwise\n * focus will be set on the body which\n * means that people using screen readers\n * or tabbing will need to re-navigate\n * to where they were before they\n * opened the overlay.\n */\nconst focusPreviousElementOnDismiss = async (overlayEl) => {\n  let previousElement = document.activeElement;\n  if (!previousElement) {\n    return;\n  }\n  const shadowRoot = previousElement === null || previousElement === void 0 ? void 0 : previousElement.shadowRoot;\n  if (shadowRoot) {\n    // If there are no inner focusable elements, just focus the host element.\n    previousElement = shadowRoot.querySelector(focusableQueryString) || previousElement;\n  }\n  await overlayEl.onDidDismiss();\n  previousElement.focus();\n};\nexport const dismiss = async (overlay, data, role, name, iosLeaveAnimation, mdLeaveAnimation, opts) => {\n  var _a, _b;\n  if (!overlay.presented) {\n    return false;\n  }\n  setRootAriaHidden(false);\n  overlay.presented = false;\n  try {\n    // Overlay contents should not be clickable during dismiss\n    overlay.el.style.setProperty('pointer-events', 'none');\n    overlay.willDismiss.emit({ data, role });\n    (_a = overlay.willDismissShorthand) === null || _a === void 0 ? void 0 : _a.emit({ data, role });\n    const mode = getIonMode(overlay);\n    const animationBuilder = overlay.leaveAnimation\n      ? overlay.leaveAnimation\n      : config.get(name, mode === 'ios' ? iosLeaveAnimation : mdLeaveAnimation);\n    // If dismissed via gesture, no need to play leaving animation again\n    if (role !== GESTURE) {\n      await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n    }\n    overlay.didDismiss.emit({ data, role });\n    (_b = overlay.didDismissShorthand) === null || _b === void 0 ? void 0 : _b.emit({ data, role });\n    activeAnimations.delete(overlay);\n    /**\n     * Make overlay hidden again in case it is being reused.\n     * We can safely remove pointer-events: none as\n     * overlay-hidden will set display: none.\n     */\n    overlay.el.classList.add('overlay-hidden');\n    overlay.el.style.removeProperty('pointer-events');\n    /**\n     * Clear any focus trapping references\n     * when the overlay is dismissed.\n     */\n    if (overlay.el.lastFocus !== undefined) {\n      overlay.el.lastFocus = undefined;\n    }\n  }\n  catch (err) {\n    console.error(err);\n  }\n  overlay.el.remove();\n  return true;\n};\nconst getAppRoot = (doc) => {\n  return doc.querySelector('ion-app') || doc.body;\n};\nconst overlayAnimation = async (overlay, animationBuilder, baseEl, opts) => {\n  // Make overlay visible in case it's hidden\n  baseEl.classList.remove('overlay-hidden');\n  const aniRoot = overlay.el;\n  const animation = animationBuilder(aniRoot, opts);\n  if (!overlay.animated || !config.getBoolean('animated', true)) {\n    animation.duration(0);\n  }\n  if (overlay.keyboardClose) {\n    animation.beforeAddWrite(() => {\n      const activeElement = baseEl.ownerDocument.activeElement;\n      if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.matches('input,ion-input, ion-textarea')) {\n        activeElement.blur();\n      }\n    });\n  }\n  const activeAni = activeAnimations.get(overlay) || [];\n  activeAnimations.set(overlay, [...activeAni, animation]);\n  await animation.play();\n  return true;\n};\nexport const eventMethod = (element, eventName) => {\n  let resolve;\n  const promise = new Promise((r) => (resolve = r));\n  onceEvent(element, eventName, (event) => {\n    resolve(event.detail);\n  });\n  return promise;\n};\nexport const onceEvent = (element, eventName, callback) => {\n  const handler = (ev) => {\n    removeEventListener(element, eventName, handler);\n    callback(ev);\n  };\n  addEventListener(element, eventName, handler);\n};\nexport const isCancel = (role) => {\n  return role === 'cancel' || role === BACKDROP;\n};\nconst defaultGate = (h) => h();\n/**\n * Calls a developer provided method while avoiding\n * Angular Zones. Since the handler is provided by\n * the developer, we should throw any errors\n * received so that developer-provided bug\n * tracking software can log it.\n */\nexport const safeCall = (handler, arg) => {\n  if (typeof handler === 'function') {\n    const jmp = config.get('_zoneGate', defaultGate);\n    return jmp(() => {\n      try {\n        return handler(arg);\n      }\n      catch (e) {\n        throw e;\n      }\n    });\n  }\n  return undefined;\n};\nexport const BACKDROP = 'backdrop';\nexport const GESTURE = 'gesture';\n/**\n * Creates a delegate controller.\n *\n * Requires that the component has the following properties:\n * - `el: HTMLElement`\n * - `hasController: boolean`\n * - `delegate?: FrameworkDelegate`\n *\n * @param ref The component class instance.\n */\nexport const createDelegateController = (ref) => {\n  let inline = false;\n  let workingDelegate;\n  const coreDelegate = CoreDelegate();\n  /**\n   * Determines whether or not an overlay is being used\n   * inline or via a controller/JS and returns the correct delegate.\n   * By default, subsequent calls to getDelegate will use\n   * a cached version of the delegate.\n   * This is useful for calling dismiss after present,\n   * so that the correct delegate is given.\n   * @param force `true` to force the non-cached version of the delegate.\n   * @returns The delegate to use and whether or not the overlay is inline.\n   */\n  const getDelegate = (force = false) => {\n    if (workingDelegate && !force) {\n      return {\n        delegate: workingDelegate,\n        inline,\n      };\n    }\n    const { el, hasController, delegate } = ref;\n    /**\n     * If using overlay inline\n     * we potentially need to use the coreDelegate\n     * so that this works in vanilla JS apps.\n     * If a developer has presented this component\n     * via a controller, then we can assume\n     * the component is already in the\n     * correct place.\n     */\n    const parentEl = el.parentNode;\n    inline = parentEl !== null && !hasController;\n    workingDelegate = inline ? delegate || coreDelegate : delegate;\n    return { inline, delegate: workingDelegate };\n  };\n  /**\n   * Attaches a component in the DOM. Teleports the component\n   * to the root of the app.\n   * @param component The component to optionally construct and append to the element.\n   */\n  const attachViewToDom = async (component) => {\n    const { delegate } = getDelegate(true);\n    if (delegate) {\n      return await delegate.attachViewToDom(ref.el, component);\n    }\n    const { hasController } = ref;\n    if (hasController && component !== undefined) {\n      throw new Error('framework delegate is missing');\n    }\n    return null;\n  };\n  /**\n   * Moves a component back to its original location in the DOM.\n   */\n  const removeViewFromDom = () => {\n    const { delegate } = getDelegate();\n    if (delegate && ref.el !== undefined) {\n      delegate.removeViewFromDom(ref.el.parentElement, ref.el);\n    }\n  };\n  return {\n    attachViewToDom,\n    removeViewFromDom,\n  };\n};\n/**\n * Constructs a trigger interaction for an overlay.\n * Presents an overlay when the trigger is clicked.\n *\n * Usage:\n * ```ts\n * triggerController = createTriggerController();\n * triggerController.addClickListener(el, trigger);\n * ```\n */\nexport const createTriggerController = () => {\n  let destroyTriggerInteraction;\n  /**\n   * Removes the click listener from the trigger element.\n   */\n  const removeClickListener = () => {\n    if (destroyTriggerInteraction) {\n      destroyTriggerInteraction();\n      destroyTriggerInteraction = undefined;\n    }\n  };\n  /**\n   * Adds a click listener to the trigger element.\n   * Presents the overlay when the trigger is clicked.\n   * @param el The overlay element.\n   * @param trigger The ID of the element to add a click listener to.\n   */\n  const addClickListener = (el, trigger) => {\n    removeClickListener();\n    const triggerEl = trigger !== undefined ? document.getElementById(trigger) : null;\n    if (!triggerEl) {\n      printIonWarning(`A trigger element with the ID \"${trigger}\" was not found in the DOM. The trigger element must be in the DOM when the \"trigger\" property is set on an overlay component.`, el);\n      return;\n    }\n    const configureTriggerInteraction = (targetEl, overlayEl) => {\n      const openOverlay = () => {\n        overlayEl.present();\n      };\n      targetEl.addEventListener('click', openOverlay);\n      return () => {\n        targetEl.removeEventListener('click', openOverlay);\n      };\n    };\n    destroyTriggerInteraction = configureTriggerInteraction(triggerEl, el);\n  };\n  return {\n    addClickListener,\n    removeClickListener,\n  };\n};\n"],"mappings":";;;GASA,IAAIA,EAAS,EACD,MAACC,EAAmB,IAAIC,QACpC,MAAMC,EAAoBC,IACjB,CACLC,OAAOC,GACL,OAAOC,EAAcH,EAASE,EACpC,EACIE,QAAQC,EAAMC,EAAMC,GAClB,OAAOC,EAAeC,SAAUJ,EAAMC,EAAMN,EAASO,EAC3D,EACIG,eACE,OAAOC,EAAWF,SAAUT,EAClC,IAGY,MAACY,EAAgCb,EAAiB,aAClD,MAACc,EAAsCd,EAAiB,oBAIxD,MAACe,EAAkCf,EAAiB,eAEpD,MAACgB,EAAkBC,IAC7B,UAAWP,WAAa,YAAa,CACnCQ,EAAiBR,SACrB,CACE,MAAMS,EAAetB,IACrBoB,EAAGE,aAAeA,EAClB,IAAKF,EAAGG,aAAa,MAAO,CAC1BH,EAAGT,GAAK,eAAeW,GAC3B,GAEO,MAAMf,EAAgB,CAACH,EAASoB,KACrC,UAAWC,SAAW,oBAAsBA,OAAOC,iBAAmB,YAAa,CACjF,OAAOD,OAAOC,eAAeC,YAAYvB,GAASwB,MAAK,KACrD,MAAMC,EAAUhB,SAASiB,cAAc1B,GACvCyB,EAAQE,UAAUC,IAAI,kBAKtBC,OAAOC,OAAOL,EAASI,OAAOC,OAAOD,OAAOC,OAAO,GAAIV,GAAO,CAAEW,cAAe,QAE/EC,EAAWvB,UAAUwB,YAAYR,GACjC,OAAO,IAAIS,SAASC,GAAYC,EAAiBX,EAASU,IAAS,GAEzE,CACE,OAAOD,QAAQC,SAAS,EAc1B,MAAME,EAAuB,wcACjB,MAACC,EAAuB,CAACC,EAAKC,KACxC,IAAIC,EAAaF,EAAIG,cAAcL,GACnC,MAAMM,EAAaF,IAAe,MAAQA,SAAoB,OAAS,EAAIA,EAAWE,WACtF,GAAIA,EAAY,CAEdF,EAAaE,EAAWD,cAAcL,IAAyBI,CACnE,CACE,GAAIA,EAAY,CACdG,EAAaH,EACjB,KACO,CAEHD,EAAQK,OACZ,GAEA,MAAMC,EAAmBN,GAAYA,EAAQb,UAAUoB,SAAS,kBAChE,MAAMC,EAAsB,CAACT,EAAKC,KAChC,MAAMS,EAASC,MAAMC,KAAKZ,EAAIa,iBAAiBf,IAC/C,IAAIgB,EAAYJ,EAAOK,OAAS,EAAIL,EAAOA,EAAOK,OAAS,GAAK,KAChE,MAAMX,EAAaU,IAAc,MAAQA,SAAmB,OAAS,EAAIA,EAAUV,WACnF,GAAIA,EAAY,CAEdU,EAAYV,EAAWD,cAAcL,IAAyBgB,CAClE,CACE,GAAIA,EAAW,CACbA,EAAUR,OACd,KACO,CAEHL,EAAQK,OACZ,GASA,MAAMU,EAAoB,CAACC,EAAIC,KAC7B,MAAMC,EAAc/C,EAAW8C,EAAK,2EACpC,MAAME,EAASH,EAAGG,OAWlB,IAAKD,IAAgBC,EAAQ,CAC3B,MACJ,CAUE,GAAID,EAAY/B,UAAUoB,SAAS,0BAA2B,CAC5D,MACJ,CACE,MAAMa,EAAkB,KAOtB,GAAIF,IAAgBC,EAAQ,CAC1BD,EAAYG,UAAYC,SAS9B,KACS,CAKH,MAAMC,EAAcC,EAAeN,GACnC,IAAKK,EAAYhB,SAASY,GAAS,CACjC,MACR,CACM,MAAMM,EAAiBF,EAAYrB,cAAc,wBACjD,IAAKuB,EAAgB,CACnB,MACR,CAKM,GAAIA,EAAelB,SAASY,GAAS,CACnCD,EAAYG,UAAYF,CAChC,KACW,CAaH,MAAME,EAAYH,EAAYG,UAE9BvB,EAAqB2B,EAAgBP,GAUrC,GAAIG,IAAcJ,EAAIS,cAAe,CACnClB,EAAoBiB,EAAgBP,EAC9C,CACQA,EAAYG,UAAYJ,EAAIS,aACpC,CACA,GAEE,MAAMC,EAAkB,KAKtB,GAAIT,EAAYX,SAASY,GAAS,CAChCD,EAAYG,UAAYF,CAC9B,KACS,CAcH,MAAME,EAAYH,EAAYG,UAE9BvB,EAAqBoB,EAAaA,GAUlC,GAAIG,IAAcJ,EAAIS,cAAe,CACnClB,EAAoBU,EAAaA,EACzC,CACMA,EAAYG,UAAYJ,EAAIS,aAClC,GAEE,GAAIR,EAAYf,WAAY,CAC1BwB,GACJ,KACO,CACHP,GACJ,GAEA,MAAM3C,EAAoBwC,IACxB,GAAI7D,IAAW,EAAG,CAChBA,EAAS,EACT6D,EAAIW,iBAAiB,SAAUZ,IAC7BD,EAAkBC,EAAIC,EAAI,GACzB,MAEHA,EAAIW,iBAAiB,iBAAkBZ,IACrC,MAAME,EAAc/C,EAAW8C,GAC/B,GAAIC,IAAgB,MAAQA,SAAqB,OAAS,EAAIA,EAAYW,gBAAiB,CACzFb,EAAGc,OAAOC,SAASC,GAA8B,IACxCd,EAAYtD,QAAQ0D,UAAWW,IAEhD,KAGIhB,EAAIW,iBAAiB,WAAYZ,IAC/B,GAAIA,EAAGkB,MAAQ,SAAU,CACvB,MAAMhB,EAAc/C,EAAW8C,GAC/B,GAAIC,IAAgB,MAAQA,SAAqB,OAAS,EAAIA,EAAYW,gBAAiB,CACzFX,EAAYtD,QAAQ0D,UAAWW,EACzC,CACA,IAEA,GAEO,MAAMjE,EAAiB,CAACiD,EAAKpD,EAAMC,EAAMqE,EAAYpE,KAC1D,MAAMiC,EAAU7B,EAAW8C,EAAKkB,EAAYpE,GAC5C,IAAKiC,EAAS,CACZ,OAAON,QAAQ0C,OAAO,yBAC1B,CACE,OAAOpC,EAAQpC,QAAQC,EAAMC,EAAK,EAE7B,MAAMuE,EAAc,CAACpB,EAAKqB,KAC/B,GAAIA,IAAahB,UAAW,CAC1BgB,EAAW,mFACf,CACE,OAAO5B,MAAMC,KAAKM,EAAIL,iBAAiB0B,IAAWC,QAAQC,GAAMA,EAAE9D,aAAe,GAAE,EASzE,MAACP,EAAa,CAAC8C,EAAKkB,EAAYpE,KAC1C,MAAM0E,EAAWJ,EAAYpB,EAAKkB,GAAYI,QAAQG,IAAOpC,EAAgBoC,KAC7E,OAAO3E,IAAOuD,UAAYmB,EAASA,EAAS3B,OAAS,GAAK2B,EAASE,MAAMD,GAAMA,EAAE3E,KAAOA,GAAG,EAwBtF,MAAM6E,EAAoB,CAACC,EAAS,SACzC,MAAMC,EAAOtD,EAAWvB,UACxB,MAAM8E,EAAgBD,EAAK5C,cAAc,wDACzC,IAAK6C,EAAe,CAClB,MACJ,CACE,GAAIF,EAAQ,CACVE,EAAcC,aAAa,cAAe,OAC9C,KACO,CACHD,EAAcE,gBAAgB,cAClC,GAEY,MAACC,EAAUhF,MAAO8B,EAASmD,EAAMC,EAAmBC,EAAkBzE,KAChF,IAAI0E,EAAIC,EACR,GAAIvD,EAAQwD,UAAW,CACrB,MACJ,CACEZ,EAAkB,MAClB5C,EAAQwD,UAAY,KACpBxD,EAAQyD,YAAYC,QACnBJ,EAAKtD,EAAQ2D,wBAA0B,MAAQL,SAAY,OAAS,EAAIA,EAAGI,OAC5E,MAAME,EAAOC,EAAW7D,GAExB,MAAM8D,EAAmB9D,EAAQ+D,eAC7B/D,EAAQ+D,eACRC,EAAOC,IAAId,EAAMS,IAAS,MAAQR,EAAoBC,GAC1D,MAAMa,QAAkBC,EAAiBnE,EAAS8D,EAAkB9D,EAAQxB,GAAII,GAChF,GAAIsF,EAAW,CACblE,EAAQoE,WAAWV,QAClBH,EAAKvD,EAAQqE,uBAAyB,MAAQd,SAAY,OAAS,EAAIA,EAAGG,MAC/E,CASE,GAAI1D,EAAQxB,GAAGhB,UAAY,YAAa,CACtC8G,EAA8BtE,EAAQxB,GAC1C,CAOE,GAAIwB,EAAQuE,gBAAkBtG,SAASyD,gBAAkB,OAAS1B,EAAQxB,GAAG+B,SAAStC,SAASyD,gBAAiB,CAC9G1B,EAAQxB,GAAG6B,OACf,GAYA,MAAMiE,EAAgCpG,MAAOsG,IAC3C,IAAIC,EAAkBxG,SAASyD,cAC/B,IAAK+C,EAAiB,CACpB,MACJ,CACE,MAAMtE,EAAasE,IAAoB,MAAQA,SAAyB,OAAS,EAAIA,EAAgBtE,WACrG,GAAIA,EAAY,CAEdsE,EAAkBtE,EAAWD,cAAcL,IAAyB4E,CACxE,OACQD,EAAUE,eAChBD,EAAgBpE,OAAO,EAEb,MAACzC,EAAUM,MAAO8B,EAASnC,EAAMC,EAAMqF,EAAMwB,EAAmBC,EAAkBhG,KAC5F,IAAI0E,EAAIC,EACR,IAAKvD,EAAQwD,UAAW,CACtB,OAAO,KACX,CACEZ,EAAkB,OAClB5C,EAAQwD,UAAY,MACpB,IAEExD,EAAQxB,GAAGqG,MAAMC,YAAY,iBAAkB,QAC/C9E,EAAQ+E,YAAYrB,KAAK,CAAE7F,OAAMC,UAChCwF,EAAKtD,EAAQgF,wBAA0B,MAAQ1B,SAAY,OAAS,EAAIA,EAAGI,KAAK,CAAE7F,OAAMC,SACzF,MAAM8F,EAAOC,EAAW7D,GACxB,MAAM8D,EAAmB9D,EAAQiF,eAC7BjF,EAAQiF,eACRjB,EAAOC,IAAId,EAAMS,IAAS,MAAQe,EAAoBC,GAE1D,GAAI9G,IAASoH,EAAS,OACdf,EAAiBnE,EAAS8D,EAAkB9D,EAAQxB,GAAII,EACpE,CACIoB,EAAQmF,WAAWzB,KAAK,CAAE7F,OAAMC,UAC/ByF,EAAKvD,EAAQoF,uBAAyB,MAAQ7B,SAAY,OAAS,EAAIA,EAAGG,KAAK,CAAE7F,OAAMC,SACxFT,EAAiBgI,OAAOrF,GAMxBA,EAAQxB,GAAGW,UAAUC,IAAI,kBACzBY,EAAQxB,GAAGqG,MAAMS,eAAe,kBAKhC,GAAItF,EAAQxB,GAAG6C,YAAcC,UAAW,CACtCtB,EAAQxB,GAAG6C,UAAYC,SAC7B,CACA,CACE,MAAOiE,GACLC,QAAQC,MAAMF,EAClB,CACEvF,EAAQxB,GAAGkH,SACX,OAAO,IAAI,EAEb,MAAMlG,EAAcyB,GACXA,EAAIf,cAAc,YAAce,EAAI0E,KAE7C,MAAMxB,EAAmBjG,MAAO8B,EAAS8D,EAAkB8B,EAAQhH,KAEjEgH,EAAOzG,UAAUuG,OAAO,kBACxB,MAAMG,EAAU7F,EAAQxB,GACxB,MAAMsH,EAAYhC,EAAiB+B,EAASjH,GAC5C,IAAKoB,EAAQ+F,WAAa/B,EAAOgC,WAAW,WAAY,MAAO,CAC7DF,EAAUG,SAAS,EACvB,CACE,GAAIjG,EAAQuE,cAAe,CACzBuB,EAAUI,gBAAe,KACvB,MAAMxE,EAAgBkE,EAAOO,cAAczE,cAC3C,GAAIA,IAAkB,MAAQA,SAAuB,OAAS,EAAIA,EAAc0E,QAAQ,iCAAkC,CACxH1E,EAAc2E,MACtB,IAEA,CACE,MAAMC,EAAYjJ,EAAiB4G,IAAIjE,IAAY,GACnD3C,EAAiBkJ,IAAIvG,EAAS,IAAIsG,EAAWR,UACvCA,EAAUU,OAChB,OAAO,IAAI,EAED,MAACC,EAAc,CAACxH,EAASyH,KACnC,IAAI/G,EACJ,MAAMgH,EAAU,IAAIjH,SAASkH,GAAOjH,EAAUiH,IAC9CC,EAAU5H,EAASyH,GAAYI,IAC7BnH,EAAQmH,EAAMhF,OAAO,IAEvB,OAAO6E,CAAO,EAET,MAAME,EAAY,CAAC5H,EAASyH,EAAWK,KAC5C,MAAMC,EAAWhG,IACfiG,EAAoBhI,EAASyH,EAAWM,GACxCD,EAAS/F,EAAG,EAEdY,EAAiB3C,EAASyH,EAAWM,EAAQ,EAEnC,MAACE,EAAYpJ,GAChBA,IAAS,UAAYA,IAASmE,EAEvC,MAAMkF,EAAeC,GAAMA,IAQf,MAACC,EAAW,CAACL,EAASM,KAChC,UAAWN,IAAY,WAAY,CACjC,MAAMO,EAAMvD,EAAOC,IAAI,YAAakD,GACpC,OAAOI,GAAI,KACT,IACE,OAAOP,EAAQM,EACvB,CACM,MAAOE,GACL,MAAMA,CACd,IAEA,CACE,OAAOlG,SAAS,EAEN,MAACW,EAAW,WACZ,MAACiD,EAAU,UAWX,MAACuC,EAA4B1H,IACvC,IAAI2H,EAAS,MACb,IAAIC,EACJ,MAAMC,EAAeC,IAWrB,MAAMC,EAAc,CAACC,EAAQ,SAC3B,GAAIJ,IAAoBI,EAAO,CAC7B,MAAO,CACLC,SAAUL,EACVD,SAER,CACI,MAAMlJ,GAAEA,EAAEe,cAAEA,EAAayI,SAAEA,GAAajI,EAUxC,MAAMkI,EAAWzJ,EAAG0J,WACpBR,EAASO,IAAa,OAAS1I,EAC/BoI,EAAkBD,EAASM,GAAYJ,EAAeI,EACtD,MAAO,CAAEN,SAAQM,SAAUL,EAAiB,EAO9C,MAAMQ,EAAkBjK,MAAOkK,IAC7B,MAAMJ,SAAEA,GAAaF,EAAY,MACjC,GAAIE,EAAU,CACZ,aAAaA,EAASG,gBAAgBpI,EAAIvB,GAAI4J,EACpD,CACI,MAAM7I,cAAEA,GAAkBQ,EAC1B,GAAIR,GAAiB6I,IAAc9G,UAAW,CAC5C,MAAM,IAAI+G,MAAM,gCACtB,CACI,OAAO,IAAI,EAKb,MAAMC,EAAoB,KACxB,MAAMN,SAAEA,GAAaF,IACrB,GAAIE,GAAYjI,EAAIvB,KAAO8C,UAAW,CACpC0G,EAASM,kBAAkBvI,EAAIvB,GAAG+J,cAAexI,EAAIvB,GAC3D,GAEE,MAAO,CACL2J,kBACAG,oBACD,EAYS,MAACE,EAA0B,KACrC,IAAIC,EAIJ,MAAMC,EAAsB,KAC1B,GAAID,EAA2B,CAC7BA,IACAA,EAA4BnH,SAClC,GAQE,MAAMqH,EAAmB,CAACnK,EAAIoK,KAC5BF,IACA,MAAMG,EAAYD,IAAYtH,UAAYrD,SAAS6K,eAAeF,GAAW,KAC7E,IAAKC,EAAW,CACdE,EAAgB,kCAAkCH,kIAAyIpK,GAC3L,MACN,CACI,MAAMwK,EAA8B,CAACC,EAAUzE,KAC7C,MAAM0E,EAAc,KAClB1E,EAAUtB,SAAS,EAErB+F,EAASrH,iBAAiB,QAASsH,GACnC,MAAO,KACLD,EAAShC,oBAAoB,QAASiC,EAAY,CACnD,EAEHT,EAA4BO,EAA4BH,EAAWrK,EAAG,EAExE,MAAO,CACLmK,mBACAD,sBACD,S"}