/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { DatetimeHighlight, DatetimeHighlightCallback, DatetimePresentation, Mode, TextFieldTypes } from "@ionic/core";
import { LocalJSX as IonTypes } from "@ionic/core/dist/types/components";
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { IconProps } from "./icons";
export { DatetimeHighlight, DatetimeHighlightCallback, DatetimePresentation, Mode, TextFieldTypes } from "@ionic/core";
export { LocalJSX as IonTypes } from "@ionic/core/dist/types/components";
export { AtomModal } from "./components/modal/modal";
export { IconProps } from "./icons";
export { LocalJSX as JSX };
export namespace Components {
    interface AtomAlert {
        "actionText"?: string;
        /**
          * @default false
         */
        "close": boolean;
        /**
          * @default 'neutral'
         */
        "color"?: 'info' | 'success' | 'warning' | 'danger' | 'neutral';
        "icon"?: IconProps;
        "messageText"?: string;
        "messageTitle"?: string;
    }
    interface AtomBadge {
        /**
          * @default 'primary'
         */
        "type": | 'primary'
    | 'secondary'
    | 'info'
    | 'success'
    | 'warning'
    | 'danger'
    | 'neutral'
    | 'dark';
    }
    interface AtomBreadcrumb {
        /**
          * @default []
         */
        "items": BreadcrumbItemProp[];
    }
    interface AtomButton {
        /**
          * @default 'primary'
         */
        "color": 'primary' | 'secondary' | 'white' | 'custom';
        "disabled"?: boolean;
        "download"?: string;
        "expand"?: 'block';
        /**
          * @default 'solid'
         */
        "fill": | 'clear'
    | 'outline'
    | 'outline-filled'
    | 'solid';
        "href"?: string;
        "loading"?: boolean;
        /**
          * @default 'md'
         */
        "mode": Mode;
        "rel"?: string;
        /**
          * @default 'round'
         */
        "shape"?: 'round' | 'circle';
        /**
          * @default 'default'
         */
        "size": 'small' | 'default' | 'large';
        "target"?: string;
        /**
          * @default 'button'
         */
        "type": 'submit' | 'reset' | 'button';
    }
    interface AtomCarousel {
        "autoplay": number;
        /**
          * @default true
         */
        "hasNavigation": boolean;
        /**
          * @default true
         */
        "hasPagination": boolean;
        /**
          * @default false
         */
        "loop": boolean;
        "thumbnails": string[];
    }
    interface AtomCarouselItem {
    }
    interface AtomChip {
        /**
          * @default false
         */
        "activated": boolean;
        /**
          * @default false
         */
        "close": boolean;
        /**
          * @default false
         */
        "disabled": boolean;
        "icon"?: IconProps;
        /**
          * @default 'md'
         */
        "mode": 'ios' | 'md';
        /**
          * @default false
         */
        "outline": boolean;
    }
    interface AtomCol {
        "offset"?: string;
        "offsetLg"?: string;
        "offsetMd"?: string;
        "offsetSm"?: string;
        "pull"?: string;
        "push"?: string;
        "size"?: 'auto' | string;
        "sizeLg"?: string;
        "sizeMd"?: string;
        "sizeSm"?: string;
    }
    interface AtomContainer {
        /**
          * @default true
         */
        "hasPadding": boolean;
    }
    interface AtomDatetime {
        "cancelText"?: string;
        "clearText"?: string;
        /**
          * @default 'datetime'
         */
        "datetimeId": string;
        "dayValues"?: number[] | string;
        "disabled"?: boolean;
        "doneText"?: string;
        /**
          * @default {     date: {       month: '2-digit',       day: '2-digit',       year: 'numeric',     },     time: {       hour: '2-digit',       minute: '2-digit',     },   }
         */
        "formatOptions": {
    date?: Intl.DateTimeFormatOptions
    time?: Intl.DateTimeFormatOptions
  };
        "highlightedDates"?: DatetimeHighlight[] | DatetimeHighlightCallback;
        /**
          * @default 'h23'
         */
        "hourCycle": 'h12' | 'h23';
        "hourValues"?: number[] | string;
        "isDateEnabled"?: (dateString: string) => boolean;
        "label"?: string;
        /**
          * @default 'pt-BR'
         */
        "locale": string;
        "max"?: string;
        "min"?: string;
        "minuteValues"?: number[] | string;
        "monthValues"?: number[] | string;
        "multiple"?: boolean;
        "name"?: string;
        /**
          * @default false
         */
        "preferWheel": boolean;
        /**
          * @default 'date'
         */
        "presentation"?: DatetimePresentation;
        "rangeMode"?: boolean;
        "readonly"?: boolean;
        "showClearButton"?: boolean;
        "showDefaultButtons"?: boolean;
        /**
          * @default false
         */
        "showDefaultTimeLabel": boolean;
        /**
          * @default false
         */
        "showDefaultTitle": boolean;
        /**
          * @default 'fixed'
         */
        "size"?: 'cover' | 'fixed';
        /**
          * @default false
         */
        "useButton": boolean;
        "value"?: TValue;
        "yearValues"?: number[] | string;
    }
    interface AtomDivider {
        /**
          * @default 'horizontal'
         */
        "type": 'horizontal' | 'vertical';
    }
    interface AtomGrid {
        "fixed"?: boolean;
    }
    interface AtomIcon {
        "color"?: ColorProps;
        "icon"?: IconProps;
        "size"?: Size;
    }
    interface AtomInput {
        /**
          * @default 'off'
         */
        "autocomplete"?: 'on' | 'off';
        /**
          * @default false
         */
        "autofocus": boolean;
        /**
          * @default false
         */
        "clearInput": boolean;
        /**
          * @default false
         */
        "clearOnEdit": boolean;
        /**
          * @default 'secondary'
         */
        "color"?: 'primary' | 'secondary' | 'danger';
        /**
          * @default false
         */
        "counter": boolean;
        "counterFormatter"?: (
    inputLength: number,
    maxLength: number
  ) => string | undefined;
        "debounce": number;
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default 'enter'
         */
        "enterKeyHint": | 'enter'
    | 'done'
    | 'go'
    | 'next'
    | 'previous'
    | 'search'
    | 'send';
        "errorText"?: string;
        /**
          * @default 'solid'
         */
        "fill": 'solid' | 'outline';
        "getInputElement": () => Promise<HTMLInputElement>;
        /**
          * @default false
         */
        "hasError": boolean;
        "helperText"?: string;
        "icon"?: IconProps;
        "inputmode"?: | 'none'
    | 'text'
    | 'tel'
    | 'url'
    | 'email'
    | 'numeric'
    | 'decimal'
    | 'search';
        "label"?: string;
        /**
          * @default 'floating'
         */
        "labelPlacement"?: 'stacked' | 'floating';
        "max"?: string | number;
        "maxlength"?: number;
        "min"?: string | number;
        "minlength"?: number;
        /**
          * @default 'md'
         */
        "mode": Mode;
        /**
          * @default false
         */
        "multiple": boolean;
        "name"?: string;
        /**
          * @default false
         */
        "passwordToggle": boolean;
        "pattern"?: string;
        "placeholder"?: string;
        /**
          * @default false
         */
        "readonly": boolean;
        /**
          * @default false
         */
        "required": boolean;
        "setFocus": () => Promise<void>;
        "setInputEl": (inputEl: HTMLIonInputElement) => Promise<void>;
        /**
          * @default 'round'
         */
        "shape": 'round' | undefined;
        "step"?: string;
        /**
          * @default 'text'
         */
        "type": TextFieldTypes;
        "value"?: IonTypes.IonInput['value'];
    }
    interface AtomLink {
        /**
          * @default 'secondary'
         */
        "color": 'primary' | 'secondary';
        /**
          * @default false
         */
        "loading"?: boolean;
        /**
          * @default 'medium'
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * @default 'anchor'
         */
        "type": 'anchor' | 'button';
    }
    interface AtomListSlider {
        "centralized": boolean;
        /**
          * @default true
         */
        "hasNavigation": boolean;
        /**
          * @default 1
         */
        "step": number;
    }
    interface AtomListSliderItem {
    }
    interface AtomMeter {
        "actual": number;
        /**
          * @default false
         */
        "hasCenterTitle"?: boolean;
        "max": number;
        "min": number;
        /**
          * @default 'large'
         */
        "size"?: 'small' | 'large';
        "title": string;
        /**
          * @default 'neutral'
         */
        "type"?: 'success' | 'neutral' | 'warning' | 'danger';
    }
    interface AtomModal {
        "alertType"?: 'alert' | 'error';
        "canDismiss"?: boolean;
        /**
          * @default false
         */
        "disablePrimaryButton": boolean;
        /**
          * @default false
         */
        "disableSecondaryButton": boolean;
        /**
          * @default false
         */
        "hasDivider": boolean;
        /**
          * @default true
         */
        "hasFooter": boolean;
        /**
          * @default ''
         */
        "headerTitle": string;
        "idName"?: string;
        /**
          * @default false
         */
        "isOpen": boolean;
        /**
          * @default {}
         */
        "metaData"?: MetaData;
        "primaryButtonText"?: string;
        "progress"?: number;
        "secondaryButtonText"?: string;
        "trigger"?: string;
    }
    interface AtomPagination {
        "count": number;
        "page": number;
    }
    interface AtomPopover {
        /**
          * @default 'hover'
         */
        "action": 'hover' | 'click';
        "actionText"?: string;
        "element": string;
        "label"?: string;
        /**
          * @default false
         */
        "open": boolean;
        /**
          * @default 'top'
         */
        "placement": | 'top'
    | 'top-start'
    | 'top-end'
    | 'bottom'
    | 'bottom-start'
    | 'bottom-end'
    | 'right'
    | 'left';
    }
    interface AtomSelect {
        "disabled"?: boolean;
        "errorText"?: string;
        /**
          * @default 'solid'
         */
        "fill": 'solid' | 'outline';
        "helperText"?: string;
        "icon"?: IconProps;
        "label"?: string;
        /**
          * @default 'md'
         */
        "mode": Mode;
        "multiple"?: boolean;
        "name": string;
        /**
          * @default []
         */
        "options": Array<{
    id: string
    value: string
    label?: string
    selected?: boolean
    disabled?: boolean
    tag?: { color: string; label: string }
  }>;
        "placeholder": string;
        "readonly"?: boolean;
        "setTagInSelectOptions": () => Promise<void>;
        "value"?: IonTypes.IonSelect['value'];
    }
    interface AtomSpinner {
        /**
          * @default 40
         */
        "size": number;
        /**
          * @default 'primary'
         */
        "type": 'primary' | 'secondary' | 'dark';
    }
    interface AtomStepper {
        "activeStep": number;
        /**
          * @default true
         */
        "disabledUnrenderedStep"?: boolean;
        "stepTitle"?: string;
        /**
          * @default []
         */
        "steps": Array<{
    title: string
    completed: boolean
  }>;
    }
    interface AtomStepsModal {
        "closeOnFinish"?: boolean;
        /**
          * @default 1
         */
        "currentStep": number;
        "disablePrimaryButton"?: boolean;
        "disableSecondaryButton"?: boolean;
        /**
          * @default false
         */
        "isOpen": boolean;
        "lockedInitialStep"?: number;
        /**
          * @default {}
         */
        "metaData"?: AtomModal['metaData'];
        "primaryButtonTextsByStep": string;
        "secondaryButtonTextsByStep": string;
        "steps": number;
        "stepsTitles": string;
        "trigger"?: string;
    }
    interface AtomTag {
        "color": 'success' | 'danger' | 'warning' | 'info' | 'dark' | 'light';
        "customBackgroundColor"?: string;
        "customTextColor"?: string;
        "icon"?: IconProps;
    }
    interface AtomTextarea {
        /**
          * @default false
         */
        "autoGrow": boolean;
        /**
          * @default 'off'
         */
        "autocomplete"?: 'on' | 'off';
        /**
          * @default false
         */
        "autofocus": boolean;
        /**
          * @default false
         */
        "clearOnEdit": boolean;
        /**
          * @default 'secondary'
         */
        "color"?: 'primary' | 'secondary' | 'danger';
        "cols"?: number;
        /**
          * @default false
         */
        "counter": boolean;
        "counterFormatter"?: (
    inputLength: number,
    maxLength: number
  ) => string | undefined;
        "debounce": number;
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default 'enter'
         */
        "enterKeyHint": | 'enter'
    | 'done'
    | 'go'
    | 'next'
    | 'previous'
    | 'search'
    | 'send';
        "errorText"?: string;
        /**
          * @default 'solid'
         */
        "fill": 'solid' | 'outline';
        "getInputElement": () => Promise<HTMLTextAreaElement>;
        /**
          * @default false
         */
        "hasError": boolean;
        "helperText"?: string;
        "icon"?: IconProps;
        "inputmode"?: | 'none'
    | 'text'
    | 'tel'
    | 'url'
    | 'email'
    | 'numeric'
    | 'decimal'
    | 'search';
        "label"?: string;
        /**
          * @default 'floating'
         */
        "labelPlacement"?: 'stacked' | 'floating';
        "maxlength"?: number;
        "minlength"?: number;
        /**
          * @default 'md'
         */
        "mode": Mode;
        "name"?: string;
        "pattern"?: string;
        "placeholder"?: string;
        /**
          * @default false
         */
        "readonly": boolean;
        /**
          * @default false
         */
        "required": boolean;
        /**
          * @default 4
         */
        "rows": number;
        "setFocus": () => Promise<void>;
        "setInputEl": (textareaEl: HTMLIonTextareaElement) => Promise<void>;
        /**
          * @default 'round'
         */
        "shape": 'round' | undefined;
        "step"?: string;
        "value"?: IonTypes.IonTextarea['value'];
        "wrap"?: 'hard' | 'soft' | 'off';
    }
    interface AtomTooltip {
        /**
          * @default 'hover'
         */
        "action": 'hover' | 'click';
        "element": string;
        /**
          * @default false
         */
        "open": boolean;
        /**
          * @default 'top'
         */
        "placement": | 'auto'
    | 'auto-start'
    | 'auto-end'
    | 'top'
    | 'top-start'
    | 'top-end'
    | 'bottom'
    | 'bottom-start'
    | 'bottom-end'
    | 'right'
    | 'right-start'
    | 'right-end'
    | 'left'
    | 'left-start'
    | 'left-end';
    }
}
export interface AtomAlertCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAtomAlertElement;
}
export interface AtomButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAtomButtonElement;
}
export interface AtomChipCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAtomChipElement;
}
export interface AtomDatetimeCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAtomDatetimeElement;
}
export interface AtomInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAtomInputElement;
}
export interface AtomLinkCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAtomLinkElement;
}
export interface AtomListSliderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAtomListSliderElement;
}
export interface AtomModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAtomModalElement;
}
export interface AtomPaginationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAtomPaginationElement;
}
export interface AtomPopoverCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAtomPopoverElement;
}
export interface AtomSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAtomSelectElement;
}
export interface AtomStepsModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAtomStepsModalElement;
}
export interface AtomTextareaCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAtomTextareaElement;
}
export interface AtomTooltipCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAtomTooltipElement;
}
declare global {
    interface HTMLAtomAlertElementEventMap {
        "atomClose": any;
        "atomAction": any;
    }
    interface HTMLAtomAlertElement extends Components.AtomAlert, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAtomAlertElementEventMap>(type: K, listener: (this: HTMLAtomAlertElement, ev: AtomAlertCustomEvent<HTMLAtomAlertElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAtomAlertElementEventMap>(type: K, listener: (this: HTMLAtomAlertElement, ev: AtomAlertCustomEvent<HTMLAtomAlertElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAtomAlertElement: {
        prototype: HTMLAtomAlertElement;
        new (): HTMLAtomAlertElement;
    };
    interface HTMLAtomBadgeElement extends Components.AtomBadge, HTMLStencilElement {
    }
    var HTMLAtomBadgeElement: {
        prototype: HTMLAtomBadgeElement;
        new (): HTMLAtomBadgeElement;
    };
    interface HTMLAtomBreadcrumbElement extends Components.AtomBreadcrumb, HTMLStencilElement {
    }
    var HTMLAtomBreadcrumbElement: {
        prototype: HTMLAtomBreadcrumbElement;
        new (): HTMLAtomBreadcrumbElement;
    };
    interface HTMLAtomButtonElementEventMap {
        "click": any;
    }
    interface HTMLAtomButtonElement extends Components.AtomButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAtomButtonElementEventMap>(type: K, listener: (this: HTMLAtomButtonElement, ev: AtomButtonCustomEvent<HTMLAtomButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAtomButtonElementEventMap>(type: K, listener: (this: HTMLAtomButtonElement, ev: AtomButtonCustomEvent<HTMLAtomButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAtomButtonElement: {
        prototype: HTMLAtomButtonElement;
        new (): HTMLAtomButtonElement;
    };
    interface HTMLAtomCarouselElement extends Components.AtomCarousel, HTMLStencilElement {
    }
    var HTMLAtomCarouselElement: {
        prototype: HTMLAtomCarouselElement;
        new (): HTMLAtomCarouselElement;
    };
    interface HTMLAtomCarouselItemElement extends Components.AtomCarouselItem, HTMLStencilElement {
    }
    var HTMLAtomCarouselItemElement: {
        prototype: HTMLAtomCarouselItemElement;
        new (): HTMLAtomCarouselItemElement;
    };
    interface HTMLAtomChipElementEventMap {
        "atomClick": any;
    }
    interface HTMLAtomChipElement extends Components.AtomChip, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAtomChipElementEventMap>(type: K, listener: (this: HTMLAtomChipElement, ev: AtomChipCustomEvent<HTMLAtomChipElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAtomChipElementEventMap>(type: K, listener: (this: HTMLAtomChipElement, ev: AtomChipCustomEvent<HTMLAtomChipElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAtomChipElement: {
        prototype: HTMLAtomChipElement;
        new (): HTMLAtomChipElement;
    };
    interface HTMLAtomColElement extends Components.AtomCol, HTMLStencilElement {
    }
    var HTMLAtomColElement: {
        prototype: HTMLAtomColElement;
        new (): HTMLAtomColElement;
    };
    interface HTMLAtomContainerElement extends Components.AtomContainer, HTMLStencilElement {
    }
    var HTMLAtomContainerElement: {
        prototype: HTMLAtomContainerElement;
        new (): HTMLAtomContainerElement;
    };
    interface HTMLAtomDatetimeElementEventMap {
        "atomFocus": void;
        "atomBlur": void;
        "atomChange": string | string[] | undefined;
        "atomCancel": void;
    }
    interface HTMLAtomDatetimeElement extends Components.AtomDatetime, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAtomDatetimeElementEventMap>(type: K, listener: (this: HTMLAtomDatetimeElement, ev: AtomDatetimeCustomEvent<HTMLAtomDatetimeElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAtomDatetimeElementEventMap>(type: K, listener: (this: HTMLAtomDatetimeElement, ev: AtomDatetimeCustomEvent<HTMLAtomDatetimeElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAtomDatetimeElement: {
        prototype: HTMLAtomDatetimeElement;
        new (): HTMLAtomDatetimeElement;
    };
    interface HTMLAtomDividerElement extends Components.AtomDivider, HTMLStencilElement {
    }
    var HTMLAtomDividerElement: {
        prototype: HTMLAtomDividerElement;
        new (): HTMLAtomDividerElement;
    };
    interface HTMLAtomGridElement extends Components.AtomGrid, HTMLStencilElement {
    }
    var HTMLAtomGridElement: {
        prototype: HTMLAtomGridElement;
        new (): HTMLAtomGridElement;
    };
    interface HTMLAtomIconElement extends Components.AtomIcon, HTMLStencilElement {
    }
    var HTMLAtomIconElement: {
        prototype: HTMLAtomIconElement;
        new (): HTMLAtomIconElement;
    };
    interface HTMLAtomInputElementEventMap {
        "atomFocus": void;
        "atomBlur": void;
        "atomChange": string;
        "atomInput": string;
    }
    interface HTMLAtomInputElement extends Components.AtomInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAtomInputElementEventMap>(type: K, listener: (this: HTMLAtomInputElement, ev: AtomInputCustomEvent<HTMLAtomInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAtomInputElementEventMap>(type: K, listener: (this: HTMLAtomInputElement, ev: AtomInputCustomEvent<HTMLAtomInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAtomInputElement: {
        prototype: HTMLAtomInputElement;
        new (): HTMLAtomInputElement;
    };
    interface HTMLAtomLinkElementEventMap {
        "click": any;
    }
    interface HTMLAtomLinkElement extends Components.AtomLink, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAtomLinkElementEventMap>(type: K, listener: (this: HTMLAtomLinkElement, ev: AtomLinkCustomEvent<HTMLAtomLinkElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAtomLinkElementEventMap>(type: K, listener: (this: HTMLAtomLinkElement, ev: AtomLinkCustomEvent<HTMLAtomLinkElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAtomLinkElement: {
        prototype: HTMLAtomLinkElement;
        new (): HTMLAtomLinkElement;
    };
    interface HTMLAtomListSliderElementEventMap {
        "clickNext": any;
        "clickPrev": any;
    }
    interface HTMLAtomListSliderElement extends Components.AtomListSlider, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAtomListSliderElementEventMap>(type: K, listener: (this: HTMLAtomListSliderElement, ev: AtomListSliderCustomEvent<HTMLAtomListSliderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAtomListSliderElementEventMap>(type: K, listener: (this: HTMLAtomListSliderElement, ev: AtomListSliderCustomEvent<HTMLAtomListSliderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAtomListSliderElement: {
        prototype: HTMLAtomListSliderElement;
        new (): HTMLAtomListSliderElement;
    };
    interface HTMLAtomListSliderItemElement extends Components.AtomListSliderItem, HTMLStencilElement {
    }
    var HTMLAtomListSliderItemElement: {
        prototype: HTMLAtomListSliderItemElement;
        new (): HTMLAtomListSliderItemElement;
    };
    interface HTMLAtomMeterElement extends Components.AtomMeter, HTMLStencilElement {
    }
    var HTMLAtomMeterElement: {
        prototype: HTMLAtomMeterElement;
        new (): HTMLAtomMeterElement;
    };
    interface HTMLAtomModalElementEventMap {
        "atomCloseClick": any;
        "atomDidDismiss": any;
        "atomDidPresent": any;
        "atomPrimaryClick": any;
        "atomSecondaryClick": any;
        "atomIsOpenChange": any;
    }
    interface HTMLAtomModalElement extends Components.AtomModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAtomModalElementEventMap>(type: K, listener: (this: HTMLAtomModalElement, ev: AtomModalCustomEvent<HTMLAtomModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAtomModalElementEventMap>(type: K, listener: (this: HTMLAtomModalElement, ev: AtomModalCustomEvent<HTMLAtomModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAtomModalElement: {
        prototype: HTMLAtomModalElement;
        new (): HTMLAtomModalElement;
    };
    interface HTMLAtomPaginationElementEventMap {
        "atomChangePage": number;
    }
    interface HTMLAtomPaginationElement extends Components.AtomPagination, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAtomPaginationElementEventMap>(type: K, listener: (this: HTMLAtomPaginationElement, ev: AtomPaginationCustomEvent<HTMLAtomPaginationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAtomPaginationElementEventMap>(type: K, listener: (this: HTMLAtomPaginationElement, ev: AtomPaginationCustomEvent<HTMLAtomPaginationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAtomPaginationElement: {
        prototype: HTMLAtomPaginationElement;
        new (): HTMLAtomPaginationElement;
    };
    interface HTMLAtomPopoverElementEventMap {
        "buttonAction": void;
    }
    interface HTMLAtomPopoverElement extends Components.AtomPopover, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAtomPopoverElementEventMap>(type: K, listener: (this: HTMLAtomPopoverElement, ev: AtomPopoverCustomEvent<HTMLAtomPopoverElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAtomPopoverElementEventMap>(type: K, listener: (this: HTMLAtomPopoverElement, ev: AtomPopoverCustomEvent<HTMLAtomPopoverElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAtomPopoverElement: {
        prototype: HTMLAtomPopoverElement;
        new (): HTMLAtomPopoverElement;
    };
    interface HTMLAtomSelectElementEventMap {
        "atomBlur": void;
        "atomCancel": void;
        "atomChange": string;
        "atomDismiss": void;
        "atomFocus": void;
    }
    interface HTMLAtomSelectElement extends Components.AtomSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAtomSelectElementEventMap>(type: K, listener: (this: HTMLAtomSelectElement, ev: AtomSelectCustomEvent<HTMLAtomSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAtomSelectElementEventMap>(type: K, listener: (this: HTMLAtomSelectElement, ev: AtomSelectCustomEvent<HTMLAtomSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAtomSelectElement: {
        prototype: HTMLAtomSelectElement;
        new (): HTMLAtomSelectElement;
    };
    interface HTMLAtomSpinnerElement extends Components.AtomSpinner, HTMLStencilElement {
    }
    var HTMLAtomSpinnerElement: {
        prototype: HTMLAtomSpinnerElement;
        new (): HTMLAtomSpinnerElement;
    };
    interface HTMLAtomStepperElement extends Components.AtomStepper, HTMLStencilElement {
    }
    var HTMLAtomStepperElement: {
        prototype: HTMLAtomStepperElement;
        new (): HTMLAtomStepperElement;
    };
    interface HTMLAtomStepsModalElementEventMap {
        "atomFinish": any;
        "atomCancel": any;
        "atomNextStep": any;
        "atomPreviousStep": any;
        "atomCloseClick": any;
        "atomDidDismiss": any;
        "atomDidPresent": any;
        "atomIsOpenChange": any;
    }
    interface HTMLAtomStepsModalElement extends Components.AtomStepsModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAtomStepsModalElementEventMap>(type: K, listener: (this: HTMLAtomStepsModalElement, ev: AtomStepsModalCustomEvent<HTMLAtomStepsModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAtomStepsModalElementEventMap>(type: K, listener: (this: HTMLAtomStepsModalElement, ev: AtomStepsModalCustomEvent<HTMLAtomStepsModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAtomStepsModalElement: {
        prototype: HTMLAtomStepsModalElement;
        new (): HTMLAtomStepsModalElement;
    };
    interface HTMLAtomTagElement extends Components.AtomTag, HTMLStencilElement {
    }
    var HTMLAtomTagElement: {
        prototype: HTMLAtomTagElement;
        new (): HTMLAtomTagElement;
    };
    interface HTMLAtomTextareaElementEventMap {
        "atomFocus": void;
        "atomBlur": void;
        "atomChange": string;
        "atomInput": string;
    }
    interface HTMLAtomTextareaElement extends Components.AtomTextarea, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAtomTextareaElementEventMap>(type: K, listener: (this: HTMLAtomTextareaElement, ev: AtomTextareaCustomEvent<HTMLAtomTextareaElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAtomTextareaElementEventMap>(type: K, listener: (this: HTMLAtomTextareaElement, ev: AtomTextareaCustomEvent<HTMLAtomTextareaElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAtomTextareaElement: {
        prototype: HTMLAtomTextareaElement;
        new (): HTMLAtomTextareaElement;
    };
    interface HTMLAtomTooltipElementEventMap {
        "atomClose": any;
        "atomOpen": any;
    }
    interface HTMLAtomTooltipElement extends Components.AtomTooltip, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAtomTooltipElementEventMap>(type: K, listener: (this: HTMLAtomTooltipElement, ev: AtomTooltipCustomEvent<HTMLAtomTooltipElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAtomTooltipElementEventMap>(type: K, listener: (this: HTMLAtomTooltipElement, ev: AtomTooltipCustomEvent<HTMLAtomTooltipElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAtomTooltipElement: {
        prototype: HTMLAtomTooltipElement;
        new (): HTMLAtomTooltipElement;
    };
    interface HTMLElementTagNameMap {
        "atom-alert": HTMLAtomAlertElement;
        "atom-badge": HTMLAtomBadgeElement;
        "atom-breadcrumb": HTMLAtomBreadcrumbElement;
        "atom-button": HTMLAtomButtonElement;
        "atom-carousel": HTMLAtomCarouselElement;
        "atom-carousel-item": HTMLAtomCarouselItemElement;
        "atom-chip": HTMLAtomChipElement;
        "atom-col": HTMLAtomColElement;
        "atom-container": HTMLAtomContainerElement;
        "atom-datetime": HTMLAtomDatetimeElement;
        "atom-divider": HTMLAtomDividerElement;
        "atom-grid": HTMLAtomGridElement;
        "atom-icon": HTMLAtomIconElement;
        "atom-input": HTMLAtomInputElement;
        "atom-link": HTMLAtomLinkElement;
        "atom-list-slider": HTMLAtomListSliderElement;
        "atom-list-slider-item": HTMLAtomListSliderItemElement;
        "atom-meter": HTMLAtomMeterElement;
        "atom-modal": HTMLAtomModalElement;
        "atom-pagination": HTMLAtomPaginationElement;
        "atom-popover": HTMLAtomPopoverElement;
        "atom-select": HTMLAtomSelectElement;
        "atom-spinner": HTMLAtomSpinnerElement;
        "atom-stepper": HTMLAtomStepperElement;
        "atom-steps-modal": HTMLAtomStepsModalElement;
        "atom-tag": HTMLAtomTagElement;
        "atom-textarea": HTMLAtomTextareaElement;
        "atom-tooltip": HTMLAtomTooltipElement;
    }
}
declare namespace LocalJSX {
    interface AtomAlert {
        "actionText"?: string;
        /**
          * @default false
         */
        "close"?: boolean;
        /**
          * @default 'neutral'
         */
        "color"?: 'info' | 'success' | 'warning' | 'danger' | 'neutral';
        "icon"?: IconProps;
        "messageText"?: string;
        "messageTitle"?: string;
        "onAtomAction"?: (event: AtomAlertCustomEvent<any>) => void;
        "onAtomClose"?: (event: AtomAlertCustomEvent<any>) => void;
    }
    interface AtomBadge {
        /**
          * @default 'primary'
         */
        "type"?: | 'primary'
    | 'secondary'
    | 'info'
    | 'success'
    | 'warning'
    | 'danger'
    | 'neutral'
    | 'dark';
    }
    interface AtomBreadcrumb {
        /**
          * @default []
         */
        "items"?: BreadcrumbItemProp[];
    }
    interface AtomButton {
        /**
          * @default 'primary'
         */
        "color"?: 'primary' | 'secondary' | 'white' | 'custom';
        "disabled"?: boolean;
        "download"?: string;
        "expand"?: 'block';
        /**
          * @default 'solid'
         */
        "fill"?: | 'clear'
    | 'outline'
    | 'outline-filled'
    | 'solid';
        "href"?: string;
        "loading"?: boolean;
        /**
          * @default 'md'
         */
        "mode"?: Mode;
        "onClick"?: (event: AtomButtonCustomEvent<any>) => void;
        "rel"?: string;
        /**
          * @default 'round'
         */
        "shape"?: 'round' | 'circle';
        /**
          * @default 'default'
         */
        "size"?: 'small' | 'default' | 'large';
        "target"?: string;
        /**
          * @default 'button'
         */
        "type"?: 'submit' | 'reset' | 'button';
    }
    interface AtomCarousel {
        "autoplay"?: number;
        /**
          * @default true
         */
        "hasNavigation"?: boolean;
        /**
          * @default true
         */
        "hasPagination"?: boolean;
        /**
          * @default false
         */
        "loop"?: boolean;
        "thumbnails"?: string[];
    }
    interface AtomCarouselItem {
    }
    interface AtomChip {
        /**
          * @default false
         */
        "activated"?: boolean;
        /**
          * @default false
         */
        "close"?: boolean;
        /**
          * @default false
         */
        "disabled"?: boolean;
        "icon"?: IconProps;
        /**
          * @default 'md'
         */
        "mode"?: 'ios' | 'md';
        "onAtomClick"?: (event: AtomChipCustomEvent<any>) => void;
        /**
          * @default false
         */
        "outline"?: boolean;
    }
    interface AtomCol {
        "offset"?: string;
        "offsetLg"?: string;
        "offsetMd"?: string;
        "offsetSm"?: string;
        "pull"?: string;
        "push"?: string;
        "size"?: 'auto' | string;
        "sizeLg"?: string;
        "sizeMd"?: string;
        "sizeSm"?: string;
    }
    interface AtomContainer {
        /**
          * @default true
         */
        "hasPadding"?: boolean;
    }
    interface AtomDatetime {
        "cancelText"?: string;
        "clearText"?: string;
        /**
          * @default 'datetime'
         */
        "datetimeId"?: string;
        "dayValues"?: number[] | string;
        "disabled"?: boolean;
        "doneText"?: string;
        /**
          * @default {     date: {       month: '2-digit',       day: '2-digit',       year: 'numeric',     },     time: {       hour: '2-digit',       minute: '2-digit',     },   }
         */
        "formatOptions"?: {
    date?: Intl.DateTimeFormatOptions
    time?: Intl.DateTimeFormatOptions
  };
        "highlightedDates"?: DatetimeHighlight[] | DatetimeHighlightCallback;
        /**
          * @default 'h23'
         */
        "hourCycle"?: 'h12' | 'h23';
        "hourValues"?: number[] | string;
        "isDateEnabled"?: (dateString: string) => boolean;
        "label"?: string;
        /**
          * @default 'pt-BR'
         */
        "locale"?: string;
        "max"?: string;
        "min"?: string;
        "minuteValues"?: number[] | string;
        "monthValues"?: number[] | string;
        "multiple"?: boolean;
        "name"?: string;
        "onAtomBlur"?: (event: AtomDatetimeCustomEvent<void>) => void;
        "onAtomCancel"?: (event: AtomDatetimeCustomEvent<void>) => void;
        "onAtomChange"?: (event: AtomDatetimeCustomEvent<string | string[] | undefined>) => void;
        "onAtomFocus"?: (event: AtomDatetimeCustomEvent<void>) => void;
        /**
          * @default false
         */
        "preferWheel"?: boolean;
        /**
          * @default 'date'
         */
        "presentation"?: DatetimePresentation;
        "rangeMode"?: boolean;
        "readonly"?: boolean;
        "showClearButton"?: boolean;
        "showDefaultButtons"?: boolean;
        /**
          * @default false
         */
        "showDefaultTimeLabel"?: boolean;
        /**
          * @default false
         */
        "showDefaultTitle"?: boolean;
        /**
          * @default 'fixed'
         */
        "size"?: 'cover' | 'fixed';
        /**
          * @default false
         */
        "useButton"?: boolean;
        "value"?: TValue;
        "yearValues"?: number[] | string;
    }
    interface AtomDivider {
        /**
          * @default 'horizontal'
         */
        "type"?: 'horizontal' | 'vertical';
    }
    interface AtomGrid {
        "fixed"?: boolean;
    }
    interface AtomIcon {
        "color"?: ColorProps;
        "icon"?: IconProps;
        "size"?: Size;
    }
    interface AtomInput {
        /**
          * @default 'off'
         */
        "autocomplete"?: 'on' | 'off';
        /**
          * @default false
         */
        "autofocus"?: boolean;
        /**
          * @default false
         */
        "clearInput"?: boolean;
        /**
          * @default false
         */
        "clearOnEdit"?: boolean;
        /**
          * @default 'secondary'
         */
        "color"?: 'primary' | 'secondary' | 'danger';
        /**
          * @default false
         */
        "counter"?: boolean;
        "counterFormatter"?: (
    inputLength: number,
    maxLength: number
  ) => string | undefined;
        "debounce"?: number;
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default 'enter'
         */
        "enterKeyHint"?: | 'enter'
    | 'done'
    | 'go'
    | 'next'
    | 'previous'
    | 'search'
    | 'send';
        "errorText"?: string;
        /**
          * @default 'solid'
         */
        "fill"?: 'solid' | 'outline';
        /**
          * @default false
         */
        "hasError"?: boolean;
        "helperText"?: string;
        "icon"?: IconProps;
        "inputmode"?: | 'none'
    | 'text'
    | 'tel'
    | 'url'
    | 'email'
    | 'numeric'
    | 'decimal'
    | 'search';
        "label"?: string;
        /**
          * @default 'floating'
         */
        "labelPlacement"?: 'stacked' | 'floating';
        "max"?: string | number;
        "maxlength"?: number;
        "min"?: string | number;
        "minlength"?: number;
        /**
          * @default 'md'
         */
        "mode"?: Mode;
        /**
          * @default false
         */
        "multiple"?: boolean;
        "name"?: string;
        "onAtomBlur"?: (event: AtomInputCustomEvent<void>) => void;
        "onAtomChange"?: (event: AtomInputCustomEvent<string>) => void;
        "onAtomFocus"?: (event: AtomInputCustomEvent<void>) => void;
        "onAtomInput"?: (event: AtomInputCustomEvent<string>) => void;
        /**
          * @default false
         */
        "passwordToggle"?: boolean;
        "pattern"?: string;
        "placeholder"?: string;
        /**
          * @default false
         */
        "readonly"?: boolean;
        /**
          * @default false
         */
        "required"?: boolean;
        /**
          * @default 'round'
         */
        "shape"?: 'round' | undefined;
        "step"?: string;
        /**
          * @default 'text'
         */
        "type"?: TextFieldTypes;
        "value"?: IonTypes.IonInput['value'];
    }
    interface AtomLink {
        /**
          * @default 'secondary'
         */
        "color"?: 'primary' | 'secondary';
        /**
          * @default false
         */
        "loading"?: boolean;
        "onClick"?: (event: AtomLinkCustomEvent<any>) => void;
        /**
          * @default 'medium'
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * @default 'anchor'
         */
        "type"?: 'anchor' | 'button';
    }
    interface AtomListSlider {
        "centralized"?: boolean;
        /**
          * @default true
         */
        "hasNavigation"?: boolean;
        "onClickNext"?: (event: AtomListSliderCustomEvent<any>) => void;
        "onClickPrev"?: (event: AtomListSliderCustomEvent<any>) => void;
        /**
          * @default 1
         */
        "step"?: number;
    }
    interface AtomListSliderItem {
    }
    interface AtomMeter {
        "actual"?: number;
        /**
          * @default false
         */
        "hasCenterTitle"?: boolean;
        "max"?: number;
        "min"?: number;
        /**
          * @default 'large'
         */
        "size"?: 'small' | 'large';
        "title"?: string;
        /**
          * @default 'neutral'
         */
        "type"?: 'success' | 'neutral' | 'warning' | 'danger';
    }
    interface AtomModal {
        "alertType"?: 'alert' | 'error';
        "canDismiss"?: boolean;
        /**
          * @default false
         */
        "disablePrimaryButton"?: boolean;
        /**
          * @default false
         */
        "disableSecondaryButton"?: boolean;
        /**
          * @default false
         */
        "hasDivider"?: boolean;
        /**
          * @default true
         */
        "hasFooter"?: boolean;
        /**
          * @default ''
         */
        "headerTitle"?: string;
        "idName"?: string;
        /**
          * @default false
         */
        "isOpen"?: boolean;
        /**
          * @default {}
         */
        "metaData"?: MetaData;
        "onAtomCloseClick"?: (event: AtomModalCustomEvent<any>) => void;
        "onAtomDidDismiss"?: (event: AtomModalCustomEvent<any>) => void;
        "onAtomDidPresent"?: (event: AtomModalCustomEvent<any>) => void;
        "onAtomIsOpenChange"?: (event: AtomModalCustomEvent<any>) => void;
        "onAtomPrimaryClick"?: (event: AtomModalCustomEvent<any>) => void;
        "onAtomSecondaryClick"?: (event: AtomModalCustomEvent<any>) => void;
        "primaryButtonText"?: string;
        "progress"?: number;
        "secondaryButtonText"?: string;
        "trigger"?: string;
    }
    interface AtomPagination {
        "count"?: number;
        "onAtomChangePage"?: (event: AtomPaginationCustomEvent<number>) => void;
        "page"?: number;
    }
    interface AtomPopover {
        /**
          * @default 'hover'
         */
        "action"?: 'hover' | 'click';
        "actionText"?: string;
        "element"?: string;
        "label"?: string;
        "onButtonAction"?: (event: AtomPopoverCustomEvent<void>) => void;
        /**
          * @default false
         */
        "open"?: boolean;
        /**
          * @default 'top'
         */
        "placement"?: | 'top'
    | 'top-start'
    | 'top-end'
    | 'bottom'
    | 'bottom-start'
    | 'bottom-end'
    | 'right'
    | 'left';
    }
    interface AtomSelect {
        "disabled"?: boolean;
        "errorText"?: string;
        /**
          * @default 'solid'
         */
        "fill"?: 'solid' | 'outline';
        "helperText"?: string;
        "icon"?: IconProps;
        "label"?: string;
        /**
          * @default 'md'
         */
        "mode"?: Mode;
        "multiple"?: boolean;
        "name"?: string;
        "onAtomBlur"?: (event: AtomSelectCustomEvent<void>) => void;
        "onAtomCancel"?: (event: AtomSelectCustomEvent<void>) => void;
        "onAtomChange"?: (event: AtomSelectCustomEvent<string>) => void;
        "onAtomDismiss"?: (event: AtomSelectCustomEvent<void>) => void;
        "onAtomFocus"?: (event: AtomSelectCustomEvent<void>) => void;
        /**
          * @default []
         */
        "options"?: Array<{
    id: string
    value: string
    label?: string
    selected?: boolean
    disabled?: boolean
    tag?: { color: string; label: string }
  }>;
        "placeholder"?: string;
        "readonly"?: boolean;
        "value"?: IonTypes.IonSelect['value'];
    }
    interface AtomSpinner {
        /**
          * @default 40
         */
        "size"?: number;
        /**
          * @default 'primary'
         */
        "type"?: 'primary' | 'secondary' | 'dark';
    }
    interface AtomStepper {
        "activeStep"?: number;
        /**
          * @default true
         */
        "disabledUnrenderedStep"?: boolean;
        "stepTitle"?: string;
        /**
          * @default []
         */
        "steps"?: Array<{
    title: string
    completed: boolean
  }>;
    }
    interface AtomStepsModal {
        "closeOnFinish"?: boolean;
        /**
          * @default 1
         */
        "currentStep"?: number;
        "disablePrimaryButton"?: boolean;
        "disableSecondaryButton"?: boolean;
        /**
          * @default false
         */
        "isOpen"?: boolean;
        "lockedInitialStep"?: number;
        /**
          * @default {}
         */
        "metaData"?: AtomModal['metaData'];
        "onAtomCancel"?: (event: AtomStepsModalCustomEvent<any>) => void;
        "onAtomCloseClick"?: (event: AtomStepsModalCustomEvent<any>) => void;
        "onAtomDidDismiss"?: (event: AtomStepsModalCustomEvent<any>) => void;
        "onAtomDidPresent"?: (event: AtomStepsModalCustomEvent<any>) => void;
        "onAtomFinish"?: (event: AtomStepsModalCustomEvent<any>) => void;
        "onAtomIsOpenChange"?: (event: AtomStepsModalCustomEvent<any>) => void;
        "onAtomNextStep"?: (event: AtomStepsModalCustomEvent<any>) => void;
        "onAtomPreviousStep"?: (event: AtomStepsModalCustomEvent<any>) => void;
        "primaryButtonTextsByStep"?: string;
        "secondaryButtonTextsByStep"?: string;
        "steps"?: number;
        "stepsTitles"?: string;
        "trigger"?: string;
    }
    interface AtomTag {
        "color"?: 'success' | 'danger' | 'warning' | 'info' | 'dark' | 'light';
        "customBackgroundColor"?: string;
        "customTextColor"?: string;
        "icon"?: IconProps;
    }
    interface AtomTextarea {
        /**
          * @default false
         */
        "autoGrow"?: boolean;
        /**
          * @default 'off'
         */
        "autocomplete"?: 'on' | 'off';
        /**
          * @default false
         */
        "autofocus"?: boolean;
        /**
          * @default false
         */
        "clearOnEdit"?: boolean;
        /**
          * @default 'secondary'
         */
        "color"?: 'primary' | 'secondary' | 'danger';
        "cols"?: number;
        /**
          * @default false
         */
        "counter"?: boolean;
        "counterFormatter"?: (
    inputLength: number,
    maxLength: number
  ) => string | undefined;
        "debounce"?: number;
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default 'enter'
         */
        "enterKeyHint"?: | 'enter'
    | 'done'
    | 'go'
    | 'next'
    | 'previous'
    | 'search'
    | 'send';
        "errorText"?: string;
        /**
          * @default 'solid'
         */
        "fill"?: 'solid' | 'outline';
        /**
          * @default false
         */
        "hasError"?: boolean;
        "helperText"?: string;
        "icon"?: IconProps;
        "inputmode"?: | 'none'
    | 'text'
    | 'tel'
    | 'url'
    | 'email'
    | 'numeric'
    | 'decimal'
    | 'search';
        "label"?: string;
        /**
          * @default 'floating'
         */
        "labelPlacement"?: 'stacked' | 'floating';
        "maxlength"?: number;
        "minlength"?: number;
        /**
          * @default 'md'
         */
        "mode"?: Mode;
        "name"?: string;
        "onAtomBlur"?: (event: AtomTextareaCustomEvent<void>) => void;
        "onAtomChange"?: (event: AtomTextareaCustomEvent<string>) => void;
        "onAtomFocus"?: (event: AtomTextareaCustomEvent<void>) => void;
        "onAtomInput"?: (event: AtomTextareaCustomEvent<string>) => void;
        "pattern"?: string;
        "placeholder"?: string;
        /**
          * @default false
         */
        "readonly"?: boolean;
        /**
          * @default false
         */
        "required"?: boolean;
        /**
          * @default 4
         */
        "rows"?: number;
        /**
          * @default 'round'
         */
        "shape"?: 'round' | undefined;
        "step"?: string;
        "value"?: IonTypes.IonTextarea['value'];
        "wrap"?: 'hard' | 'soft' | 'off';
    }
    interface AtomTooltip {
        /**
          * @default 'hover'
         */
        "action"?: 'hover' | 'click';
        "element"?: string;
        /**
          * Event is dispatched when: 1. Mouse leave event in selector 2. Click "Close" button when is mobile
         */
        "onAtomClose"?: (event: AtomTooltipCustomEvent<any>) => void;
        /**
          * Event is dispatched when: 1. Mouse enter event in selector 2. Click in element when is mobile
         */
        "onAtomOpen"?: (event: AtomTooltipCustomEvent<any>) => void;
        /**
          * @default false
         */
        "open"?: boolean;
        /**
          * @default 'top'
         */
        "placement"?: | 'auto'
    | 'auto-start'
    | 'auto-end'
    | 'top'
    | 'top-start'
    | 'top-end'
    | 'bottom'
    | 'bottom-start'
    | 'bottom-end'
    | 'right'
    | 'right-start'
    | 'right-end'
    | 'left'
    | 'left-start'
    | 'left-end';
    }
    interface IntrinsicElements {
        "atom-alert": AtomAlert;
        "atom-badge": AtomBadge;
        "atom-breadcrumb": AtomBreadcrumb;
        "atom-button": AtomButton;
        "atom-carousel": AtomCarousel;
        "atom-carousel-item": AtomCarouselItem;
        "atom-chip": AtomChip;
        "atom-col": AtomCol;
        "atom-container": AtomContainer;
        "atom-datetime": AtomDatetime;
        "atom-divider": AtomDivider;
        "atom-grid": AtomGrid;
        "atom-icon": AtomIcon;
        "atom-input": AtomInput;
        "atom-link": AtomLink;
        "atom-list-slider": AtomListSlider;
        "atom-list-slider-item": AtomListSliderItem;
        "atom-meter": AtomMeter;
        "atom-modal": AtomModal;
        "atom-pagination": AtomPagination;
        "atom-popover": AtomPopover;
        "atom-select": AtomSelect;
        "atom-spinner": AtomSpinner;
        "atom-stepper": AtomStepper;
        "atom-steps-modal": AtomStepsModal;
        "atom-tag": AtomTag;
        "atom-textarea": AtomTextarea;
        "atom-tooltip": AtomTooltip;
    }
}
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "atom-alert": LocalJSX.AtomAlert & JSXBase.HTMLAttributes<HTMLAtomAlertElement>;
            "atom-badge": LocalJSX.AtomBadge & JSXBase.HTMLAttributes<HTMLAtomBadgeElement>;
            "atom-breadcrumb": LocalJSX.AtomBreadcrumb & JSXBase.HTMLAttributes<HTMLAtomBreadcrumbElement>;
            "atom-button": LocalJSX.AtomButton & JSXBase.HTMLAttributes<HTMLAtomButtonElement>;
            "atom-carousel": LocalJSX.AtomCarousel & JSXBase.HTMLAttributes<HTMLAtomCarouselElement>;
            "atom-carousel-item": LocalJSX.AtomCarouselItem & JSXBase.HTMLAttributes<HTMLAtomCarouselItemElement>;
            "atom-chip": LocalJSX.AtomChip & JSXBase.HTMLAttributes<HTMLAtomChipElement>;
            "atom-col": LocalJSX.AtomCol & JSXBase.HTMLAttributes<HTMLAtomColElement>;
            "atom-container": LocalJSX.AtomContainer & JSXBase.HTMLAttributes<HTMLAtomContainerElement>;
            "atom-datetime": LocalJSX.AtomDatetime & JSXBase.HTMLAttributes<HTMLAtomDatetimeElement>;
            "atom-divider": LocalJSX.AtomDivider & JSXBase.HTMLAttributes<HTMLAtomDividerElement>;
            "atom-grid": LocalJSX.AtomGrid & JSXBase.HTMLAttributes<HTMLAtomGridElement>;
            "atom-icon": LocalJSX.AtomIcon & JSXBase.HTMLAttributes<HTMLAtomIconElement>;
            "atom-input": LocalJSX.AtomInput & JSXBase.HTMLAttributes<HTMLAtomInputElement>;
            "atom-link": LocalJSX.AtomLink & JSXBase.HTMLAttributes<HTMLAtomLinkElement>;
            "atom-list-slider": LocalJSX.AtomListSlider & JSXBase.HTMLAttributes<HTMLAtomListSliderElement>;
            "atom-list-slider-item": LocalJSX.AtomListSliderItem & JSXBase.HTMLAttributes<HTMLAtomListSliderItemElement>;
            "atom-meter": LocalJSX.AtomMeter & JSXBase.HTMLAttributes<HTMLAtomMeterElement>;
            "atom-modal": LocalJSX.AtomModal & JSXBase.HTMLAttributes<HTMLAtomModalElement>;
            "atom-pagination": LocalJSX.AtomPagination & JSXBase.HTMLAttributes<HTMLAtomPaginationElement>;
            "atom-popover": LocalJSX.AtomPopover & JSXBase.HTMLAttributes<HTMLAtomPopoverElement>;
            "atom-select": LocalJSX.AtomSelect & JSXBase.HTMLAttributes<HTMLAtomSelectElement>;
            "atom-spinner": LocalJSX.AtomSpinner & JSXBase.HTMLAttributes<HTMLAtomSpinnerElement>;
            "atom-stepper": LocalJSX.AtomStepper & JSXBase.HTMLAttributes<HTMLAtomStepperElement>;
            "atom-steps-modal": LocalJSX.AtomStepsModal & JSXBase.HTMLAttributes<HTMLAtomStepsModalElement>;
            "atom-tag": LocalJSX.AtomTag & JSXBase.HTMLAttributes<HTMLAtomTagElement>;
            "atom-textarea": LocalJSX.AtomTextarea & JSXBase.HTMLAttributes<HTMLAtomTextareaElement>;
            "atom-tooltip": LocalJSX.AtomTooltip & JSXBase.HTMLAttributes<HTMLAtomTooltipElement>;
        }
    }
}
