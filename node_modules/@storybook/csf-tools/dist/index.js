var __create=Object.create;var __defProp=Object.defineProperty;var __getOwnPropDesc=Object.getOwnPropertyDescriptor;var __getOwnPropNames=Object.getOwnPropertyNames;var __getProtoOf=Object.getPrototypeOf,__hasOwnProp=Object.prototype.hasOwnProperty;var __export=(target,all)=>{for(var name in all)__defProp(target,name,{get:all[name],enumerable:!0})},__copyProps=(to,from,except,desc)=>{if(from&&typeof from=="object"||typeof from=="function")for(let key of __getOwnPropNames(from))!__hasOwnProp.call(to,key)&&key!==except&&__defProp(to,key,{get:()=>from[key],enumerable:!(desc=__getOwnPropDesc(from,key))||desc.enumerable});return to};var __toESM=(mod,isNodeMode,target)=>(target=mod!=null?__create(__getProtoOf(mod)):{},__copyProps(isNodeMode||!mod||!mod.__esModule?__defProp(target,"default",{value:mod,enumerable:!0}):target,mod)),__toCommonJS=mod=>__copyProps(__defProp({},"__esModule",{value:!0}),mod);var src_exports={};__export(src_exports,{ConfigFile:()=>ConfigFile,CsfFile:()=>CsfFile,NoMetaError:()=>NoMetaError,babelParse:()=>babelParse,babelParseExpression:()=>babelParseExpression,enrichCsf:()=>enrichCsf,enrichCsfMeta:()=>enrichCsfMeta,enrichCsfStory:()=>enrichCsfStory,extractDescription:()=>extractDescription,extractSource:()=>extractSource,formatConfig:()=>formatConfig,formatCsf:()=>formatCsf,getStorySortParameter:()=>getStorySortParameter,loadConfig:()=>loadConfig,loadCsf:()=>loadCsf,parserOptions:()=>parserOptions,readConfig:()=>readConfig,readCsf:()=>readCsf,writeConfig:()=>writeConfig,writeCsf:()=>writeCsf});module.exports=__toCommonJS(src_exports);var import_fs_extra=__toESM(require("fs-extra")),import_ts_dedent=require("ts-dedent"),t2=__toESM(require("@babel/types")),generate=__toESM(require("@babel/generator")),traverse=__toESM(require("@babel/traverse")),import_csf=require("@storybook/csf");var parser=__toESM(require("@babel/parser")),recast=__toESM(require("recast")),parserOptions={sourceType:"module",plugins:["jsx","typescript","decorators-legacy","classProperties"],tokens:!0},babelParse=code=>recast.parse(code,{parser:{parse(source){return parser.parse(source,parserOptions)}}}),babelParseExpression=code=>parser.parseExpression(code,parserOptions);var t=__toESM(require("@babel/types")),findVarInitialization=(identifier3,program)=>{let init=null,declarations=null;return program.body.find(node=>(t.isVariableDeclaration(node)?declarations=node.declarations:t.isExportNamedDeclaration(node)&&t.isVariableDeclaration(node.declaration)&&(declarations=node.declaration.declarations),declarations&&declarations.find(decl=>t.isVariableDeclarator(decl)&&t.isIdentifier(decl.id)&&decl.id.name===identifier3?(init=decl.init,!0):!1))),init};var logger=console;function parseIncludeExclude(prop){if(t2.isArrayExpression(prop))return prop.elements.map(e=>{if(t2.isStringLiteral(e))return e.value;throw new Error(`Expected string literal: ${e}`)});if(t2.isStringLiteral(prop))return new RegExp(prop.value);if(t2.isRegExpLiteral(prop))return new RegExp(prop.pattern,prop.flags);throw new Error(`Unknown include/exclude: ${prop}`)}function parseTags(prop){if(!t2.isArrayExpression(prop))throw new Error("CSF: Expected tags array");return prop.elements.map(e=>{if(t2.isStringLiteral(e))return e.value;throw new Error("CSF: Expected tag to be string literal")})}var formatLocation=(node,fileName)=>{var _a;let{line,column}=((_a=node.loc)==null?void 0:_a.start)||{};return`${fileName||""} (line ${line}, col ${column})`.trim()},isArgsStory=(init,parent,csf)=>{let storyFn=init;if(t2.isCallExpression(init)){let{callee,arguments:bindArguments}=init;if(t2.isProgram(parent)&&t2.isMemberExpression(callee)&&t2.isIdentifier(callee.object)&&t2.isIdentifier(callee.property)&&callee.property.name==="bind"&&(bindArguments.length===0||bindArguments.length===1&&t2.isObjectExpression(bindArguments[0])&&bindArguments[0].properties.length===0)){let boundIdentifier=callee.object.name,template=findVarInitialization(boundIdentifier,parent);template&&(csf._templates[boundIdentifier]=template,storyFn=template)}}return t2.isArrowFunctionExpression(storyFn)||t2.isFunctionDeclaration(storyFn)?storyFn.params.length>0:!1},parseExportsOrder=init=>{if(t2.isArrayExpression(init))return init.elements.map(item=>{if(t2.isStringLiteral(item))return item.value;throw new Error(`Expected string literal named export: ${item}`)});throw new Error(`Expected array of string literals: ${init}`)},sortExports=(exportByName,order)=>order.reduce((acc,name)=>{let namedExport=exportByName[name];return namedExport&&(acc[name]=namedExport),acc},{}),NoMetaError=class extends Error{constructor(message,ast,fileName){super(import_ts_dedent.dedent`
      CSF: ${message} ${formatLocation(ast,fileName)}

      More info: https://storybook.js.org/docs/react/writing-stories/introduction#default-export
    `),this.name=this.constructor.name}},CsfFile=class{constructor(ast,{fileName,makeTitle}){this._stories={};this._metaAnnotations={};this._storyExports={};this._storyStatements={};this._storyAnnotations={};this._templates={};this._ast=ast,this._fileName=fileName,this.imports=[],this._makeTitle=makeTitle}_parseTitle(value){let node=t2.isIdentifier(value)?findVarInitialization(value.name,this._ast.program):value;if(t2.isStringLiteral(node))return node.value;throw new Error(import_ts_dedent.dedent`
      CSF: unexpected dynamic title ${formatLocation(node,this._fileName)}

      More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#string-literal-titles
    `)}_parseMeta(declaration,program){let meta={};declaration.properties.forEach(p=>{if(t2.isIdentifier(p.key)){if(this._metaAnnotations[p.key.name]=p.value,p.key.name==="title")meta.title=this._parseTitle(p.value);else if(["includeStories","excludeStories"].includes(p.key.name))meta[p.key.name]=parseIncludeExclude(p.value);else if(p.key.name==="component"){let{code}=generate.default(p.value,{});meta.component=code}else if(p.key.name==="tags"){let node=p.value;t2.isIdentifier(node)&&(node=findVarInitialization(node.name,this._ast.program)),meta.tags=parseTags(node)}else if(p.key.name==="id")if(t2.isStringLiteral(p.value))meta.id=p.value.value;else throw new Error(`Unexpected component id: ${p.value}`)}}),this._meta=meta}getStoryExport(key){let node=this._storyExports[key];if(node=t2.isVariableDeclarator(node)?node.init:node,t2.isCallExpression(node)){let{callee,arguments:bindArguments}=node;if(t2.isMemberExpression(callee)&&t2.isIdentifier(callee.object)&&t2.isIdentifier(callee.property)&&callee.property.name==="bind"&&(bindArguments.length===0||bindArguments.length===1&&t2.isObjectExpression(bindArguments[0])&&bindArguments[0].properties.length===0)){let{name}=callee.object;node=this._templates[name]}}return node}parse(){var _a;let self=this;if(traverse.default(this._ast,{ExportDefaultDeclaration:{enter({node,parent}){var _a2,_b;let metaNode,isVariableReference=t2.isIdentifier(node.declaration)&&t2.isProgram(parent),decl;if(isVariableReference){let variableName=node.declaration.name,isVariableDeclarator6=declaration=>t2.isIdentifier(declaration.id)&&declaration.id.name===variableName;self._metaStatement=self._ast.program.body.find(topLevelNode=>t2.isVariableDeclaration(topLevelNode)&&topLevelNode.declarations.find(isVariableDeclarator6)),decl=(_b=(((_a2=self==null?void 0:self._metaStatement)==null?void 0:_a2.declarations)||[]).find(isVariableDeclarator6))==null?void 0:_b.init}else self._metaStatement=node,decl=node.declaration;if(t2.isObjectExpression(decl)?metaNode=decl:(t2.isTSAsExpression(decl)||t2.isTSSatisfiesExpression(decl))&&t2.isObjectExpression(decl.expression)&&(metaNode=decl.expression),!self._meta&&metaNode&&t2.isProgram(parent)&&(self._metaNode=metaNode,self._parseMeta(metaNode,parent)),self._metaStatement&&!self._metaNode)throw new NoMetaError("default export must be an object",self._metaStatement,self._fileName)}},ExportNamedDeclaration:{enter({node,parent}){let declarations;t2.isVariableDeclaration(node.declaration)?declarations=node.declaration.declarations.filter(d=>t2.isVariableDeclarator(d)):t2.isFunctionDeclaration(node.declaration)&&(declarations=[node.declaration]),declarations?declarations.forEach(decl=>{if(t2.isIdentifier(decl.id)){let{name:exportName}=decl.id;if(exportName==="__namedExportsOrder"&&t2.isVariableDeclarator(decl)){self._namedExportsOrder=parseExportsOrder(decl.init);return}self._storyExports[exportName]=decl,self._storyStatements[exportName]=node;let name=(0,import_csf.storyNameFromExport)(exportName);self._storyAnnotations[exportName]?logger.warn(`Unexpected annotations for "${exportName}" before story declaration`):self._storyAnnotations[exportName]={};let parameters;if(t2.isVariableDeclarator(decl)&&t2.isObjectExpression(decl.init)){let __isArgsStory=!0;decl.init.properties.forEach(p=>{t2.isIdentifier(p.key)&&(p.key.name==="render"?__isArgsStory=isArgsStory(p.value,parent,self):p.key.name==="name"&&t2.isStringLiteral(p.value)?name=p.value.value:p.key.name==="storyName"&&t2.isStringLiteral(p.value)&&logger.warn(`Unexpected usage of "storyName" in "${exportName}". Please use "name" instead.`),self._storyAnnotations[exportName][p.key.name]=p.value)}),parameters={__isArgsStory}}else{let fn=t2.isVariableDeclarator(decl)?decl.init:decl;parameters={__isArgsStory:isArgsStory(fn,parent,self)}}self._stories[exportName]={id:"FIXME",name,parameters}}}):node.specifiers.length>0&&node.specifiers.forEach(specifier=>{if(t2.isExportSpecifier(specifier)&&t2.isIdentifier(specifier.exported)){let{name:exportName}=specifier.exported;if(exportName==="default"){let metaNode,decl=t2.isProgram(parent)?findVarInitialization(specifier.local.name,parent):specifier.local;t2.isObjectExpression(decl)?metaNode=decl:t2.isTSAsExpression(decl)&&t2.isObjectExpression(decl.expression)&&(metaNode=decl.expression),!self._meta&&metaNode&&t2.isProgram(parent)&&self._parseMeta(metaNode,parent)}else self._storyAnnotations[exportName]={},self._stories[exportName]={id:"FIXME",name:exportName,parameters:{}}}})}},ExpressionStatement:{enter({node,parent}){let{expression}=node;if(t2.isProgram(parent)&&t2.isAssignmentExpression(expression)&&t2.isMemberExpression(expression.left)&&t2.isIdentifier(expression.left.object)&&t2.isIdentifier(expression.left.property)){let exportName=expression.left.object.name,annotationKey=expression.left.property.name,annotationValue=expression.right;if(self._storyAnnotations[exportName]&&(annotationKey==="story"&&t2.isObjectExpression(annotationValue)?annotationValue.properties.forEach(prop=>{t2.isIdentifier(prop.key)&&(self._storyAnnotations[exportName][prop.key.name]=prop.value)}):self._storyAnnotations[exportName][annotationKey]=annotationValue),annotationKey==="storyName"&&t2.isStringLiteral(annotationValue)){let storyName=annotationValue.value,story=self._stories[exportName];if(!story)return;story.name=storyName}}}},CallExpression:{enter({node}){let{callee}=node;if(t2.isIdentifier(callee)&&callee.name==="storiesOf")throw new Error(import_ts_dedent.dedent`
              Unexpected \`storiesOf\` usage: ${formatLocation(node,self._fileName)}.

              In SB7, we use the next-generation \`storyStoreV7\` by default, which does not support \`storiesOf\`. 
              More info, with details about how to opt-out here: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#storystorev7-enabled-by-default
            `)}},ImportDeclaration:{enter({node}){let{source}=node;if(t2.isStringLiteral(source))self.imports.push(source.value);else throw new Error("CSF: unexpected import source")}}}),!self._meta)throw new NoMetaError("missing default export",self._ast,self._fileName);if(!self._meta.title&&!self._meta.component)throw new Error(import_ts_dedent.dedent`
        CSF: missing title/component ${formatLocation(self._ast,self._fileName)}

        More info: https://storybook.js.org/docs/react/writing-stories/introduction#default-export
      `);let entries=Object.entries(self._stories);if(self._meta.title=this._makeTitle((_a=self._meta)==null?void 0:_a.title),self._metaAnnotations.play&&(self._meta.tags=[...self._meta.tags||[],"play-fn"]),self._stories=entries.reduce((acc,[key,story])=>{var _a2,_b;if((0,import_csf.isExportStory)(key,self._meta)){let id=(0,import_csf.toId)(((_a2=self._meta)==null?void 0:_a2.id)||((_b=self._meta)==null?void 0:_b.title),(0,import_csf.storyNameFromExport)(key)),parameters={...story.parameters,__id:id},{includeStories}=self._meta||{};key==="__page"&&(entries.length===1||Array.isArray(includeStories)&&includeStories.length===1)&&(parameters.docsOnly=!0),acc[key]={...story,id,parameters};let{tags,play}=self._storyAnnotations[key];if(tags){let node=t2.isIdentifier(tags)?findVarInitialization(tags.name,this._ast.program):tags;acc[key].tags=parseTags(node)}play&&(acc[key].tags=[...acc[key].tags||[],"play-fn"])}return acc},{}),Object.keys(self._storyExports).forEach(key=>{(0,import_csf.isExportStory)(key,self._meta)||(delete self._storyExports[key],delete self._storyAnnotations[key])}),self._namedExportsOrder){let unsortedExports=Object.keys(self._storyExports);self._storyExports=sortExports(self._storyExports,self._namedExportsOrder),self._stories=sortExports(self._stories,self._namedExportsOrder);let sortedExports=Object.keys(self._storyExports);if(unsortedExports.length!==sortedExports.length)throw new Error(`Missing exports after sort: ${unsortedExports.filter(key=>!sortedExports.includes(key))}`)}return self}get meta(){return this._meta}get stories(){return Object.values(this._stories)}},loadCsf=(code,options)=>{let ast=babelParse(code);return new CsfFile(ast,options)},formatCsf=(csf,options={sourceMaps:!1})=>{let result=generate.default(csf._ast,options);if(options.sourceMaps)return result;let{code}=result;return code},readCsf=async(fileName,options)=>{let code=(await import_fs_extra.default.readFile(fileName,"utf-8")).toString();return loadCsf(code,{...options,fileName})},writeCsf=async(csf,fileName)=>{if(!(fileName||csf._fileName))throw new Error("Please specify a fileName for writeCsf");await import_fs_extra.default.writeFile(fileName,await formatCsf(csf))};var import_fs_extra2=__toESM(require("fs-extra")),t3=__toESM(require("@babel/types")),generate2=__toESM(require("@babel/generator")),traverse2=__toESM(require("@babel/traverse"));var logger2=console,propKey=p=>t3.isIdentifier(p.key)?p.key.name:t3.isStringLiteral(p.key)?p.key.value:null,_getPath=(path,node)=>{if(path.length===0)return node;if(t3.isObjectExpression(node)){let[first,...rest]=path,field=node.properties.find(p=>propKey(p)===first);if(field)return _getPath(rest,field.value)}},_getPathProperties=(path,node)=>{if(path.length===0){if(t3.isObjectExpression(node))return node.properties;throw new Error("Expected object expression")}if(t3.isObjectExpression(node)){let[first,...rest]=path,field=node.properties.find(p=>propKey(p)===first);if(field)return rest.length===0?node.properties:_getPathProperties(rest,field.value)}},_findVarInitialization=(identifier3,program)=>{let init=null,declarations=null;return program.body.find(node=>(t3.isVariableDeclaration(node)?declarations=node.declarations:t3.isExportNamedDeclaration(node)&&t3.isVariableDeclaration(node.declaration)&&(declarations=node.declaration.declarations),declarations&&declarations.find(decl=>t3.isVariableDeclarator(decl)&&t3.isIdentifier(decl.id)&&decl.id.name===identifier3?(init=decl.init,!0):!1))),init},_makeObjectExpression=(path,value)=>{if(path.length===0)return value;let[first,...rest]=path,innerExpression=_makeObjectExpression(rest,value);return t3.objectExpression([t3.objectProperty(t3.identifier(first),innerExpression)])},_updateExportNode=(path,expr,existing)=>{let[first,...rest]=path,existingField=existing.properties.find(p=>propKey(p)===first);existingField?t3.isObjectExpression(existingField.value)&&rest.length>0?_updateExportNode(rest,expr,existingField.value):existingField.value=_makeObjectExpression(rest,expr):existing.properties.push(t3.objectProperty(t3.identifier(first),_makeObjectExpression(rest,expr)))},ConfigFile=class{constructor(ast,code,fileName){this._exports={};this._exportDecls={};this.hasDefaultExport=!1;this._ast=ast,this._code=code,this.fileName=fileName}parse(){let self=this;return traverse2.default(this._ast,{ExportDefaultDeclaration:{enter({node,parent}){self.hasDefaultExport=!0;let decl=t3.isIdentifier(node.declaration)&&t3.isProgram(parent)?_findVarInitialization(node.declaration.name,parent):node.declaration;(t3.isTSAsExpression(decl)||t3.isTSSatisfiesExpression(decl))&&(decl=decl.expression),t3.isObjectExpression(decl)?(self._exportsObject=decl,decl.properties.forEach(p=>{let exportName=propKey(p);if(exportName){let exportVal=p.value;t3.isIdentifier(exportVal)&&(exportVal=_findVarInitialization(exportVal.name,parent)),self._exports[exportName]=exportVal}})):logger2.warn(`Unexpected ${JSON.stringify(node)}`)}},ExportNamedDeclaration:{enter({node,parent}){t3.isVariableDeclaration(node.declaration)?node.declaration.declarations.forEach(decl=>{if(t3.isVariableDeclarator(decl)&&t3.isIdentifier(decl.id)){let{name:exportName}=decl.id,exportVal=decl.init;t3.isIdentifier(exportVal)&&(exportVal=_findVarInitialization(exportVal.name,parent)),self._exports[exportName]=exportVal,self._exportDecls[exportName]=decl}}):logger2.warn(`Unexpected ${JSON.stringify(node)}`)}},ExpressionStatement:{enter({node,parent}){if(t3.isAssignmentExpression(node.expression)&&node.expression.operator==="="){let{left,right}=node.expression;if(t3.isMemberExpression(left)&&t3.isIdentifier(left.object)&&left.object.name==="module"&&t3.isIdentifier(left.property)&&left.property.name==="exports"){let exportObject=right;t3.isIdentifier(right)&&(exportObject=_findVarInitialization(right.name,parent)),(t3.isTSAsExpression(exportObject)||t3.isTSSatisfiesExpression(exportObject))&&(exportObject=exportObject.expression),t3.isObjectExpression(exportObject)?(self._exportsObject=exportObject,exportObject.properties.forEach(p=>{let exportName=propKey(p);if(exportName){let exportVal=p.value;t3.isIdentifier(exportVal)&&(exportVal=_findVarInitialization(exportVal.name,parent)),self._exports[exportName]=exportVal}})):logger2.warn(`Unexpected ${JSON.stringify(node)}`)}}}}}),self}getFieldNode(path){let[root,...rest]=path,exported=this._exports[root];if(exported)return _getPath(rest,exported)}getFieldProperties(path){let[root,...rest]=path,exported=this._exports[root];if(exported)return _getPathProperties(rest,exported)}getFieldValue(path){let node=this.getFieldNode(path);if(node){let{code}=generate2.default(node,{});return(0,eval)(`(() => (${code}))()`)}}getSafeFieldValue(path){try{return this.getFieldValue(path)}catch{}}setFieldNode(path,expr){let[first,...rest]=path,exportNode=this._exports[first];if(this._exportsObject)_updateExportNode(path,expr,this._exportsObject),this._exports[path[0]]=expr;else if(exportNode&&t3.isObjectExpression(exportNode)&&rest.length>0)_updateExportNode(rest,expr,exportNode);else if(exportNode&&rest.length===0&&this._exportDecls[path[0]]){let decl=this._exportDecls[path[0]];decl.init=_makeObjectExpression([],expr)}else{if(this.hasDefaultExport)throw new Error(`Could not set the "${path.join(".")}" field as the default export is not an object in this file.`);{let exportObj=_makeObjectExpression(rest,expr),newExport=t3.exportNamedDeclaration(t3.variableDeclaration("const",[t3.variableDeclarator(t3.identifier(first),exportObj)]));this._exports[first]=exportObj,this._ast.program.body.push(newExport)}}}getNameFromPath(path){let node=this.getFieldNode(path);if(node)return this._getPresetValue(node,"name")}getNamesFromPath(path){let node=this.getFieldNode(path);if(!node)return;let pathNames=[];return t3.isArrayExpression(node)&&node.elements.forEach(element=>{pathNames.push(this._getPresetValue(element,"name"))}),pathNames}_getPresetValue(node,fallbackProperty){let value;if(t3.isStringLiteral(node)?value=node.value:t3.isObjectExpression(node)&&node.properties.forEach(prop=>{t3.isObjectProperty(prop)&&t3.isIdentifier(prop.key)&&prop.key.name===fallbackProperty&&t3.isStringLiteral(prop.value)&&(value=prop.value.value),t3.isObjectProperty(prop)&&t3.isStringLiteral(prop.key)&&prop.key.value==="name"&&t3.isStringLiteral(prop.value)&&(value=prop.value.value)}),!value)throw new Error(`The given node must be a string literal or an object expression with a "${fallbackProperty}" property that is a string literal.`);return value}removeField(path){let removeProperty=(properties2,prop)=>{let index=properties2.findIndex(p=>t3.isIdentifier(p.key)&&p.key.name===prop||t3.isStringLiteral(p.key)&&p.key.value===prop);index>=0&&properties2.splice(index,1)};if(path.length===1){let removedRootProperty=!1;if(this._ast.program.body.forEach(node=>{if(t3.isExportNamedDeclaration(node)&&t3.isVariableDeclaration(node.declaration)){let decl=node.declaration.declarations[0];t3.isIdentifier(decl.id)&&decl.id.name===path[0]&&(this._ast.program.body.splice(this._ast.program.body.indexOf(node),1),removedRootProperty=!0)}if(t3.isExportDefaultDeclaration(node)&&t3.isObjectExpression(node.declaration)){let properties2=node.declaration.properties;removeProperty(properties2,path[0]),removedRootProperty=!0}if(t3.isExpressionStatement(node)&&t3.isAssignmentExpression(node.expression)&&t3.isMemberExpression(node.expression.left)&&t3.isIdentifier(node.expression.left.object)&&node.expression.left.object.name==="module"&&t3.isIdentifier(node.expression.left.property)&&node.expression.left.property.name==="exports"&&t3.isObjectExpression(node.expression.right)){let properties2=node.expression.right.properties;removeProperty(properties2,path[0]),removedRootProperty=!0}}),removedRootProperty)return}let properties=this.getFieldProperties(path);if(properties){let lastPath=path.at(-1);removeProperty(properties,lastPath)}}appendValueToArray(path,value){let node=this.valueToNode(value);this.appendNodeToArray(path,node)}appendNodeToArray(path,node){let current=this.getFieldNode(path);if(!current)this.setFieldNode(path,t3.arrayExpression([node]));else if(t3.isArrayExpression(current))current.elements.push(node);else throw new Error(`Expected array at '${path.join(".")}', got '${current.type}'`)}_inferQuotes(){if(!this._quotes){let occurrences=(this._ast.tokens||[]).slice(0,500).reduce((acc,token)=>(token.type.label==="string"&&(acc[this._code[token.start]]+=1),acc),{"'":0,'"':0});this._quotes=occurrences["'"]>occurrences['"']?"single":"double"}return this._quotes}valueToNode(value){let quotes=this._inferQuotes(),valueNode;if(quotes==="single"){let{code}=generate2.default(t3.valueToNode(value),{jsescOption:{quotes}}),program=babelParse(`const __x = ${code}`);traverse2.default(program,{VariableDeclaration:{enter({node}){node.declarations.length===1&&t3.isVariableDeclarator(node.declarations[0])&&t3.isIdentifier(node.declarations[0].id)&&node.declarations[0].id.name==="__x"&&(valueNode=node.declarations[0].init)}}})}else valueNode=t3.valueToNode(value);return valueNode}setFieldValue(path,value){let valueNode=this.valueToNode(value);if(!valueNode)throw new Error(`Unexpected value ${JSON.stringify(value)}`);this.setFieldNode(path,valueNode)}},loadConfig=(code,fileName)=>{let ast=babelParse(code);return new ConfigFile(ast,code,fileName)},formatConfig=config=>{let{code}=generate2.default(config._ast,{});return code},readConfig=async fileName=>{let code=(await import_fs_extra2.default.readFile(fileName,"utf-8")).toString();return loadConfig(code,fileName).parse()},writeConfig=async(config,fileName)=>{let fname=fileName||config.fileName;if(!fname)throw new Error("Please specify a fileName for writeConfig");await import_fs_extra2.default.writeFile(fname,await formatConfig(config))};var t4=__toESM(require("@babel/types")),traverse3=__toESM(require("@babel/traverse")),generate3=__toESM(require("@babel/generator")),import_ts_dedent2=require("ts-dedent");var logger3=console,getValue=(obj,key)=>{let value;return obj.properties.forEach(p=>{t4.isIdentifier(p.key)&&p.key.name===key&&(value=p.value)}),value},parseValue=expr=>{if(t4.isArrayExpression(expr))return expr.elements.map(o=>parseValue(o));if(t4.isObjectExpression(expr))return expr.properties.reduce((acc,p)=>(t4.isIdentifier(p.key)&&(acc[p.key.name]=parseValue(p.value)),acc),{});if(t4.isLiteral(expr))return expr.value;if(t4.isIdentifier(expr))return unsupported(expr.name,!0);throw new Error(`Unknown node type ${expr.type}`)},unsupported=(unexpectedVar,isError)=>{let message=import_ts_dedent2.dedent`
    Unexpected '${unexpectedVar}'. Parameter 'options.storySort' should be defined inline e.g.:

    export default {
      parameters: {
        options: {
          storySort: <array | object | function>
        },
      },
    };
  `;if(isError)throw new Error(message);logger3.info(message)},stripTSModifiers=expr=>t4.isTSAsExpression(expr)||t4.isTSSatisfiesExpression(expr)?expr.expression:expr,parseParameters=params=>{let paramsObject=stripTSModifiers(params);if(t4.isObjectExpression(paramsObject)){let options=getValue(paramsObject,"options");if(options){if(t4.isObjectExpression(options))return getValue(options,"storySort");unsupported("options",!0)}}},parseDefault=(defaultExpr,program)=>{let defaultObj=stripTSModifiers(defaultExpr);if(t4.isObjectExpression(defaultObj)){let params=getValue(defaultObj,"parameters");if(t4.isIdentifier(params)&&(params=findVarInitialization(params.name,program)),params)return parseParameters(params)}else unsupported("default",!0)},getStorySortParameter=previewCode=>{var _a;let storySort,ast=babelParse(previewCode);if(traverse3.default(ast,{ExportNamedDeclaration:{enter({node}){t4.isVariableDeclaration(node.declaration)?node.declaration.declarations.forEach(decl=>{if(t4.isVariableDeclarator(decl)&&t4.isIdentifier(decl.id)){let{name:exportName}=decl.id;if(exportName==="parameters"){let paramsObject=stripTSModifiers(decl.init);storySort=parseParameters(paramsObject)}}}):node.specifiers.forEach(spec=>{t4.isIdentifier(spec.exported)&&spec.exported.name==="parameters"&&unsupported("parameters",!1)})}},ExportDefaultDeclaration:{enter({node}){let defaultObj=node.declaration;t4.isIdentifier(defaultObj)&&(defaultObj=findVarInitialization(defaultObj.name,ast.program)),defaultObj=stripTSModifiers(defaultObj),t4.isObjectExpression(defaultObj)?storySort=parseDefault(defaultObj,ast.program):unsupported("default",!1)}}}),!!storySort){if(t4.isArrowFunctionExpression(storySort)){let{code:sortCode}=generate3.default(storySort,{});return(0,eval)(sortCode)}if(t4.isFunctionExpression(storySort)){let{code:sortCode}=generate3.default(storySort,{}),functionName=(_a=storySort.id)==null?void 0:_a.name,wrapper=`(a, b) => {
      ${sortCode};
      return ${functionName}(a, b)
    }`;return(0,eval)(wrapper)}return t4.isLiteral(storySort)||t4.isArrayExpression(storySort)||t4.isObjectExpression(storySort)?parseValue(storySort):unsupported("storySort",!0)}};var t5=__toESM(require("@babel/types")),generate4=__toESM(require("@babel/generator")),enrichCsfStory=(csf,key,options)=>{let storyExport=csf.getStoryExport(key),source=!(options!=null&&options.disableSource)&&extractSource(storyExport),description=!(options!=null&&options.disableDescription)&&extractDescription(csf._storyStatements[key]),parameters=[],originalParameters=t5.memberExpression(t5.identifier(key),t5.identifier("parameters"));parameters.push(t5.spreadElement(originalParameters));let optionalDocs=t5.optionalMemberExpression(originalParameters,t5.identifier("docs"),!1,!0),extraDocsParameters=[];if(source){let optionalSource=t5.optionalMemberExpression(optionalDocs,t5.identifier("source"),!1,!0);extraDocsParameters.push(t5.objectProperty(t5.identifier("source"),t5.objectExpression([t5.objectProperty(t5.identifier("originalSource"),t5.stringLiteral(source)),t5.spreadElement(optionalSource)])))}if(description){let optionalDescription=t5.optionalMemberExpression(optionalDocs,t5.identifier("description"),!1,!0);extraDocsParameters.push(t5.objectProperty(t5.identifier("description"),t5.objectExpression([t5.objectProperty(t5.identifier("story"),t5.stringLiteral(description)),t5.spreadElement(optionalDescription)])))}if(extraDocsParameters.length>0){parameters.push(t5.objectProperty(t5.identifier("docs"),t5.objectExpression([t5.spreadElement(optionalDocs),...extraDocsParameters])));let addParameter=t5.expressionStatement(t5.assignmentExpression("=",originalParameters,t5.objectExpression(parameters)));csf._ast.program.body.push(addParameter)}},addComponentDescription=(node,path,value)=>{if(!path.length){node.properties.find(p=>t5.isObjectProperty(p)&&t5.isIdentifier(p.key)&&p.key.name==="component")||node.properties.unshift(value);return}let[first,...rest]=path,existing=node.properties.find(p=>t5.isObjectProperty(p)&&t5.isIdentifier(p.key)&&p.key.name===first&&t5.isObjectExpression(p.value)),subNode;existing?subNode=existing.value:(subNode=t5.objectExpression([]),node.properties.push(t5.objectProperty(t5.identifier(first),subNode))),addComponentDescription(subNode,rest,value)},enrichCsfMeta=(csf,options)=>{let description=!(options!=null&&options.disableDescription)&&extractDescription(csf._metaStatement);if(description){let metaNode=csf._metaNode;metaNode&&t5.isObjectExpression(metaNode)&&addComponentDescription(metaNode,["parameters","docs","description"],t5.objectProperty(t5.identifier("component"),t5.stringLiteral(description)))}},enrichCsf=(csf,options)=>{enrichCsfMeta(csf,options),Object.keys(csf._storyExports).forEach(key=>{enrichCsfStory(csf,key,options)})},extractSource=node=>{let src=t5.isVariableDeclarator(node)?node.init:node,{code}=generate4.default(src,{});return code},extractDescription=node=>node!=null&&node.leadingComments?node.leadingComments.map(comment=>comment.type==="CommentLine"||!comment.value.startsWith("*")?null:comment.value.split(`
`).map(line=>line.replace(/^(\s+)?(\*+)?(\s)?/,"")).join(`
`).trim()).filter(Boolean).join(`
`):"";0&&(module.exports={ConfigFile,CsfFile,NoMetaError,babelParse,babelParseExpression,enrichCsf,enrichCsfMeta,enrichCsfStory,extractDescription,extractSource,formatConfig,formatCsf,getStorySortParameter,loadConfig,loadCsf,parserOptions,readConfig,readCsf,writeConfig,writeCsf});
