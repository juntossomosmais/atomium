var __require=(x=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(x,{get:(a,b)=>(typeof require<"u"?require:a)[b]}):x)(function(x){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+x+'" is not supported')});import{logger as logger2}from"@storybook/client-logger";import readPkgUp from"read-pkg-up";import{detect,getNpmVersion}from"detect-package-manager";import{loadMainConfig,getStorybookInfo,getStorybookConfiguration,getProjectRoot as getProjectRoot2}from"@storybook/core-common";import*as fs from"fs-extra";import path from"path";var getActualPackageVersions=async packages=>{let packageNames=Object.keys(packages);return Promise.all(packageNames.map(getActualPackageVersion))},getActualPackageVersion=async packageName=>{try{let packageJson=await getActualPackageJson(packageName);return{name:packageName,version:packageJson.version}}catch{return{name:packageName,version:null}}},getActualPackageJson=async packageName=>{let resolvedPackageJson=__require.resolve(path.join(packageName,"package.json"),{paths:[process.cwd()]});return await fs.readJson(resolvedPackageJson)},getStorybookCoreVersion=async()=>(await Promise.all(["@storybook/core-common","@storybook/core-server"].map(getActualPackageVersion))).find(v=>v.version)?.version;import fs2 from"fs-extra";import path2 from"path";import{getProjectRoot}from"@storybook/core-common";var monorepoConfigs={Nx:"nx.json",Turborepo:"turbo.json",Lerna:"lerna.json",Rush:"rush.json",Lage:"lage.config.json"},getMonorepoType=()=>{let projectRootPath=getProjectRoot();if(!projectRootPath)return;let monorepoType=Object.keys(monorepoConfigs).find(monorepo=>{let configFile=path2.join(projectRootPath,monorepoConfigs[monorepo]);return fs2.existsSync(configFile)});if(monorepoType)return monorepoType;if(!fs2.existsSync(path2.join(projectRootPath,"package.json")))return;if(fs2.readJsonSync(path2.join(projectRootPath,"package.json"))?.workspaces)return"Workspaces"};import{sep}from"path";function regexpEscape(str){return str.replace(/[-[/{}()*+?.\\^$|]/g,"\\$&")}function cleanPaths(str,separator=sep){if(!str)return str;let stack=process.cwd().split(separator);for(;stack.length>1;){let currentPath=stack.join(separator),currentRegex=new RegExp(regexpEscape(currentPath),"g");str=str.replace(currentRegex,"$SNIP");let currentPath2=stack.join(separator+separator),currentRegex2=new RegExp(regexpEscape(currentPath2),"g");str=str.replace(currentRegex2,"$SNIP"),stack.pop()}return str}function sanitizeError(error,pathSeparator=sep){try{error=JSON.parse(JSON.stringify(error,Object.getOwnPropertyNames(error)));let errorString=cleanPaths(JSON.stringify(error),pathSeparator);return JSON.parse(errorString)}catch(err){return`Sanitization error: ${err?.message}`}}var knownRenderers=["html","react","svelte","vue3","preact","server","vue","web-components","angular","ember"],knownBuilders=["builder-webpack5","builder-vite"];function findMatchingPackage(packageJson,suffixes){let{name="",version,dependencies,devDependencies,peerDependencies}=packageJson,allDependencies={[name]:version,...dependencies,...devDependencies,...peerDependencies};return suffixes.map(suffix=>`@storybook/${suffix}`).find(pkg=>allDependencies[pkg])}async function getFrameworkInfo(mainConfig){let{framework:frameworkInput}=mainConfig;if(!frameworkInput)return{};let framework=typeof frameworkInput=="string"?{name:frameworkInput}:frameworkInput,frameworkPackageJson=await getActualPackageJson(framework.name),builder=findMatchingPackage(frameworkPackageJson,knownBuilders),renderer=findMatchingPackage(frameworkPackageJson,knownRenderers);return{framework,builder,renderer}}function getChromaticVersionSpecifier(packageJson){let dependency=packageJson.dependencies?.chromatic||packageJson.devDependencies?.chromatic||packageJson.peerDependencies?.chromatic;return dependency||(packageJson.scripts&&Object.values(packageJson.scripts).find(s=>s?.match(/chromatic/))?"latest":void 0)}var metaFrameworks={next:"Next","react-scripts":"CRA",gatsby:"Gatsby","@nuxtjs/storybook":"nuxt","@nrwl/storybook":"nx","@vue/cli-service":"vue-cli","@sveltejs/kit":"sveltekit"},sanitizeAddonName=name=>cleanPaths(name).replace(/\/dist\/.*/,"").replace(/\.[mc]?[tj]?s[x]?$/,"").replace(/\/register$/,"").replace(/\/manager$/,"").replace(/\/preset$/,""),computeStorybookMetadata=async({packageJson,mainConfig})=>{let metadata={generatedAt:new Date().getTime(),hasCustomBabel:!1,hasCustomWebpack:!1,hasStaticDirs:!1,hasStorybookEslint:!1,refCount:0},allDependencies={...packageJson?.dependencies,...packageJson?.devDependencies,...packageJson?.peerDependencies},metaFramework=Object.keys(allDependencies).find(dep=>!!metaFrameworks[dep]);if(metaFramework){let{version}=await getActualPackageVersion(metaFramework);metadata.metaFramework={name:metaFrameworks[metaFramework],packageName:metaFramework,version}}let monorepoType=getMonorepoType();monorepoType&&(metadata.monorepo=monorepoType);try{let packageManagerType=await detect({cwd:getProjectRoot2()}),packageManagerVerson=await getNpmVersion(packageManagerType);metadata.packageManager={type:packageManagerType,version:packageManagerVerson}}catch{}metadata.hasCustomBabel=!!mainConfig.babel,metadata.hasCustomWebpack=!!mainConfig.webpackFinal,metadata.hasStaticDirs=!!mainConfig.staticDirs,mainConfig.typescript&&(metadata.typescriptOptions=mainConfig.typescript);let frameworkInfo=await getFrameworkInfo(mainConfig);mainConfig.refs&&(metadata.refCount=Object.keys(mainConfig.refs).length),mainConfig.features&&(metadata.features=mainConfig.features);let addons={};mainConfig.addons&&mainConfig.addons.forEach(addon=>{let addonName,options;typeof addon=="string"?addonName=sanitizeAddonName(addon):(options=addon.options,addonName=sanitizeAddonName(addon.name)),addons[addonName]={options,version:void 0}});let chromaticVersionSpecifier=getChromaticVersionSpecifier(packageJson);chromaticVersionSpecifier&&(addons.chromatic={version:void 0,versionSpecifier:chromaticVersionSpecifier,options:void 0}),(await getActualPackageVersions(addons)).forEach(({name,version})=>{addons[name].version=version});let addonNames=Object.keys(addons),storybookPackages=Object.keys(allDependencies).filter(dep=>dep.includes("storybook")&&!addonNames.includes(dep)).reduce((acc,dep)=>({...acc,[dep]:{version:void 0}}),{});(await getActualPackageVersions(storybookPackages)).forEach(({name,version})=>{storybookPackages[name].version=version});let language=allDependencies.typescript?"typescript":"javascript",hasStorybookEslint=!!allDependencies["eslint-plugin-storybook"],storybookInfo=getStorybookInfo(packageJson),storybookVersion=storybookPackages[storybookInfo.frameworkPackage]?.version;return{...metadata,...frameworkInfo,storybookVersion,storybookVersionSpecifier:storybookInfo.version,language,storybookPackages,addons,hasStorybookEslint}},cachedMetadata,getStorybookMetadata=async _configDir=>{if(cachedMetadata)return cachedMetadata;let{packageJson={}}=readPkgUp.sync({cwd:process.cwd(),normalize:!1})||{},configDir=(_configDir||getStorybookConfiguration(packageJson?.scripts?.storybook||"","-c","--config-dir"))??".storybook",mainConfig=await loadMainConfig({configDir});return cachedMetadata=await computeStorybookMetadata({mainConfig,packageJson}),cachedMetadata};import originalFetch from"isomorphic-unfetch";import retry from"fetch-retry";import{nanoid}from"nanoid";import path3 from"path";import{execSync}from"child_process";import{getProjectRoot as getProjectRoot3}from"@storybook/core-common";import{createHash}from"crypto";var oneWayHash=payload=>{let hash=createHash("sha256");return hash.update("storybook-telemetry-salt"),hash.update(payload),hash.digest("hex")};function normalizeGitUrl(rawUrl){return rawUrl.trim().replace(/#.*$/,"").replace(/^.*@/,"").replace(/^.*\/\//,"").replace(":","/")}var anonymousProjectId,getAnonymousProjectId=()=>{if(anonymousProjectId)return anonymousProjectId;let unhashedProjectId;try{let projectRoot=getProjectRoot3(),projectRootPath=path3.relative(projectRoot,process.cwd()),originBuffer=execSync("git config --local --get remote.origin.url",{timeout:1e3,stdio:"pipe"});unhashedProjectId=`${normalizeGitUrl(String(originBuffer))}${projectRootPath}`,anonymousProjectId=oneWayHash(unhashedProjectId)}catch{}return anonymousProjectId};import{cache}from"@storybook/core-common";var operation=Promise.resolve(),setHelper=async(eventType,body)=>{let lastEvents=await cache.get("lastEvents")||{};lastEvents[eventType]={body,timestamp:Date.now()},await cache.set("lastEvents",lastEvents)},set=async(eventType,body)=>(await operation,operation=setHelper(eventType,body),operation);var upgradeFields=event=>{let{body,timestamp}=event;return{timestamp,eventType:body?.eventType,eventId:body?.eventId,sessionId:body?.sessionId}},UPGRADE_EVENTS=["init","upgrade"],RUN_EVENTS=["build","dev","error"],lastEvent=(lastEvents,eventTypes)=>{let descendingEvents=eventTypes.map(eventType=>lastEvents?.[eventType]).filter(Boolean).sort((a,b)=>b.timestamp-a.timestamp);return descendingEvents.length>0?descendingEvents[0]:void 0},getPrecedingUpgrade=async(events=void 0)=>{let lastEvents=events||await cache.get("lastEvents")||{},lastUpgradeEvent=lastEvent(lastEvents,UPGRADE_EVENTS),lastRunEvent=lastEvent(lastEvents,RUN_EVENTS);if(lastUpgradeEvent)return!lastRunEvent?.timestamp||lastUpgradeEvent.timestamp>lastRunEvent.timestamp?upgradeFields(lastUpgradeEvent):void 0};var URL=process.env.STORYBOOK_TELEMETRY_URL||"https://storybook.js.org/event-log",fetch=retry(originalFetch),tasks=[],sessionId=nanoid(),addToGlobalContext=(key,value)=>{globalContext[key]=value},globalContext={inCI:Boolean(process.env.CI),isTTY:process.stdout.isTTY};async function sendTelemetry(data,options={retryDelay:1e3,immediate:!1}){let{eventType,payload,metadata,...rest}=data,context=options.stripMetadata?globalContext:{...globalContext,anonymousId:getAnonymousProjectId()},eventId=nanoid(),body={...rest,eventType,eventId,sessionId,metadata,payload,context},request;try{request=fetch(URL,{method:"POST",body:JSON.stringify(body),headers:{"Content-Type":"application/json"},retries:3,retryOn:[503,504],retryDelay:attempt=>2**attempt*(typeof options?.retryDelay=="number"&&!Number.isNaN(options?.retryDelay)?options.retryDelay:1e3)}),tasks.push(request),options.immediate?await Promise.all(tasks):await request,await set(eventType,body)}catch{}finally{tasks=tasks.filter(task=>task!==request)}}import chalk from"chalk";import{cache as cache2}from"@storybook/core-common";var TELEMETRY_KEY_NOTIFY_DATE="telemetry-notification-date",logger=console,notify=async()=>{await cache2.get(TELEMETRY_KEY_NOTIFY_DATE,null)||(cache2.set(TELEMETRY_KEY_NOTIFY_DATE,Date.now()),logger.log(),logger.log(`${chalk.magenta.bold("attention")} => Storybook now collects completely anonymous telemetry regarding usage.`),logger.log("This information is used to shape Storybook's roadmap and prioritize features."),logger.log("You can learn more, including how to opt-out if you'd not like to participate in this anonymous program, by visiting the following URL:"),logger.log(chalk.cyan("https://storybook.js.org/telemetry")),logger.log())};var telemetry=async(eventType,payload={},options={})=>{eventType!=="boot"&&await notify();let telemetryData={eventType,payload};try{options?.stripMetadata||(telemetryData.metadata=await getStorybookMetadata(options?.configDir))}catch(error){telemetryData.payload.metadataErrorMessage=sanitizeError(error).message,options?.enableCrashReports&&(telemetryData.payload.metadataError=sanitizeError(error))}finally{let{error}=telemetryData.payload;error&&(telemetryData.payload.error=sanitizeError(error)),(!telemetryData.payload.error||options?.enableCrashReports)&&(process.env?.STORYBOOK_TELEMETRY_DEBUG&&(logger2.info(`
[telemetry]`),logger2.info(JSON.stringify(telemetryData,null,2))),await sendTelemetry(telemetryData,options))}};export{addToGlobalContext,computeStorybookMetadata,getPrecedingUpgrade,getStorybookCoreVersion,getStorybookMetadata,metaFrameworks,oneWayHash,sanitizeAddonName,telemetry};
