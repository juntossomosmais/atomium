"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nodeExecutor = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const buildable_libs_utils_1 = require("../../utils/buildable-libs-utils");
const child_process_1 = require("child_process");
const crypto_1 = require("crypto");
const hashing_impl_1 = require("nx/src/hasher/hashing-impl");
const treeKill = require("tree-kill");
const util_1 = require("util");
const hasher = new hashing_impl_1.HashingImpl();
const processMap = new Map();
const hashedMap = new Map();
function nodeExecutor(options, context) {
    return tslib_1.__asyncGenerator(this, arguments, function* nodeExecutor_1() {
        var _a, e_1, _b, _c;
        const uniqueKey = (0, crypto_1.randomUUID)();
        process.on('SIGTERM', () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield killCurrentProcess(uniqueKey, options, 'SIGTERM');
            process.exit(128 + 15);
        }));
        process.on('SIGINT', () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield killCurrentProcess(uniqueKey, options, 'SIGINT');
            process.exit(128 + 2);
        }));
        process.on('SIGHUP', () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield killCurrentProcess(uniqueKey, options, 'SIGHUP');
            process.exit(128 + 1);
        }));
        if (options.waitUntilTargets && options.waitUntilTargets.length > 0) {
            const results = yield tslib_1.__await(runWaitUntilTargets(options, context));
            for (const [i, result] of results.entries()) {
                if (!result.success) {
                    throw new Error(`Wait until target failed: ${options.waitUntilTargets[i]}.`);
                }
            }
        }
        const mappings = calculateResolveMappings(context, options);
        try {
            for (var _d = true, _e = tslib_1.__asyncValues(startBuild(options, context)), _f; _f = yield tslib_1.__await(_e.next()), _a = _f.done, !_a;) {
                _c = _f.value;
                _d = false;
                try {
                    const event = _c;
                    if (!event.success) {
                        devkit_1.logger.error('There was an error with the build. See above.');
                        devkit_1.logger.info(`${event.outfile} was not restarted.`);
                    }
                    yield tslib_1.__await(handleBuildEvent(uniqueKey, event, options, mappings));
                    yield yield tslib_1.__await(event);
                }
                finally {
                    _d = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) yield tslib_1.__await(_b.call(_e));
            }
            finally { if (e_1) throw e_1.error; }
        }
    });
}
exports.nodeExecutor = nodeExecutor;
function calculateResolveMappings(context, options) {
    const parsed = (0, devkit_1.parseTargetString)(options.buildTarget, context.projectGraph);
    const { dependencies } = (0, buildable_libs_utils_1.calculateProjectDependencies)(context.projectGraph, context.root, parsed.project, parsed.target, parsed.configuration);
    return dependencies.reduce((m, c) => {
        if (c.node.type !== 'npm' && c.outputs[0] != null) {
            m[c.name] = (0, devkit_1.joinPathFragments)(context.root, c.outputs[0]);
        }
        return m;
    }, {});
}
function runProcess(uniqueKey, event, options, mappings) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const execArgv = getExecArgv(options);
        const hashedKey = JSON.stringify([uniqueKey, ...options.args]);
        const hashed = hasher.hashArray(execArgv.concat(hashedKey));
        hashedMap.set(hashedKey, hashed);
        const subProcess = (0, child_process_1.fork)((0, devkit_1.joinPathFragments)(__dirname, 'node-with-require-overrides'), options.args, {
            execArgv,
            stdio: 'inherit',
            env: Object.assign(Object.assign({}, process.env), { NX_FILE_TO_RUN: event.outfile, NX_MAPPINGS: JSON.stringify(mappings) }),
        });
        processMap.set(hashed, subProcess);
        if (!options.watch) {
            return new Promise((resolve, reject) => {
                subProcess.on('exit', (code) => {
                    if (code === 0) {
                        resolve(undefined);
                    }
                    else {
                        reject();
                    }
                });
            });
        }
    });
}
function getExecArgv(options) {
    const args = [
        '-r',
        require.resolve('source-map-support/register'),
        ...options.runtimeArgs,
    ];
    if (options.inspect === true) {
        options.inspect = "inspect" /* InspectType.Inspect */;
    }
    if (options.inspect) {
        args.push(`--${options.inspect}=${options.host}:${options.port}`);
    }
    return args;
}
function handleBuildEvent(uniqueKey, event, options, mappings) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // Don't kill previous run unless new build is successful.
        if (options.watch && event.success) {
            yield killCurrentProcess(uniqueKey, options);
        }
        if (event.success) {
            yield runProcess(uniqueKey, event, options, mappings);
        }
    });
}
const promisifiedTreeKill = (0, util_1.promisify)(treeKill);
function killCurrentProcess(uniqueKey, options, signal = 'SIGTERM') {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const hashedKey = JSON.stringify([uniqueKey, ...options.args]);
        const currentProcessKey = hashedMap.get(hashedKey);
        if (!currentProcessKey)
            return;
        const currentProcess = processMap.get(currentProcessKey);
        if (!currentProcess)
            return;
        try {
            yield promisifiedTreeKill(currentProcess.pid, signal);
            // if the currentProcess.killed is false, invoke kill()
            // to properly send the signal to the process
            if (!currentProcess.killed) {
                currentProcess.kill(signal);
            }
        }
        catch (err) {
            if (Array.isArray(err) && err[0] && err[2]) {
                const errorMessage = err[2];
                devkit_1.logger.error(errorMessage);
            }
            else if (err.message) {
                devkit_1.logger.error(err.message);
            }
        }
        finally {
            processMap.delete(currentProcessKey);
            hashedMap.delete(hashedKey);
        }
    });
}
function startBuild(options, context) {
    return tslib_1.__asyncGenerator(this, arguments, function* startBuild_1() {
        const buildTarget = (0, devkit_1.parseTargetString)(options.buildTarget, context.projectGraph);
        yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(yield tslib_1.__await((0, devkit_1.runExecutor)(buildTarget, Object.assign(Object.assign({}, options.buildTargetOptions), { watch: options.watch }), context)))));
    });
}
function runWaitUntilTargets(options, context) {
    return Promise.all(options.waitUntilTargets.map((waitUntilTarget) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const target = (0, devkit_1.parseTargetString)(waitUntilTarget, context.projectGraph);
        const output = yield (0, devkit_1.runExecutor)(target, {}, context);
        return new Promise((resolve) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let event = yield output.next();
            // Resolve after first event
            resolve(event.value);
            // Continue iterating
            while (!event.done) {
                event = yield output.next();
            }
        }));
    })));
}
exports.default = nodeExecutor;
//# sourceMappingURL=node.impl.js.map