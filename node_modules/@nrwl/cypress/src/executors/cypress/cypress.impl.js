"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
require("dotenv/config");
const fs_1 = require("fs");
const path_1 = require("path");
const ct_helpers_1 = require("../../utils/ct-helpers");
const cypress_version_1 = require("../../utils/cypress-version");
const detectPort = require("detect-port");
const Cypress = require('cypress'); // @NOTE: Importing via ES6 messes the whole test dependencies.
function cypressExecutor(options, context) {
    var _a, e_1, _b, _c;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        options = normalizeOptions(options, context);
        // this is used by cypress component testing presets to build the executor contexts with the correct configuration options.
        process.env.NX_CYPRESS_TARGET_CONFIGURATION = context.configurationName;
        let success;
        try {
            for (var _d = true, _e = tslib_1.__asyncValues(startDevServer(options, context)), _f; _f = yield _e.next(), _a = _f.done, !_a;) {
                _c = _f.value;
                _d = false;
                try {
                    const devServerValues = _c;
                    try {
                        success = yield runCypress(devServerValues.baseUrl, Object.assign(Object.assign({}, options), { portLockFilePath: devServerValues.portLockFilePath }));
                        if (!options.watch)
                            break;
                    }
                    catch (e) {
                        devkit_1.logger.error(e.message);
                        success = false;
                        if (!options.watch)
                            break;
                    }
                }
                finally {
                    _d = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return { success };
    });
}
exports.default = cypressExecutor;
function normalizeOptions(options, context) {
    var _a, _b, _c;
    options.env = options.env || {};
    if (options.tsConfig) {
        const tsConfigPath = (0, path_1.join)(context.root, options.tsConfig);
        options.env.tsConfig = tsConfigPath;
        process.env.TS_NODE_PROJECT = tsConfigPath;
    }
    if (options.testingType === 'component') {
        const project = (_b = (_a = context === null || context === void 0 ? void 0 : context.projectGraph) === null || _a === void 0 ? void 0 : _a.nodes) === null || _b === void 0 ? void 0 : _b[context.projectName];
        if ((_c = project === null || project === void 0 ? void 0 : project.data) === null || _c === void 0 ? void 0 : _c.root) {
            options.ctTailwindPath = (0, ct_helpers_1.getTempTailwindPath)(context);
        }
    }
    checkSupportedBrowser(options);
    warnDeprecatedHeadless(options);
    warnDeprecatedCypressVersion();
    return options;
}
function checkSupportedBrowser({ browser }) {
    // Browser was not passed in as an option, cypress will use whatever default it has set and we dont need to check it
    if (!browser) {
        return;
    }
    if ((0, cypress_version_1.installedCypressVersion)() >= 4 && browser == 'canary') {
        devkit_1.logger.warn((0, devkit_1.stripIndents) `
  Warning:
  You are using a browser that is not supported by cypress v4+.

  Read here for more info:
  https://docs.cypress.io/guides/references/migration-guide.html#Launching-Chrome-Canary-with-browser
  `);
        return;
    }
    const supportedV3Browsers = ['electron', 'chrome', 'canary', 'chromium'];
    if ((0, cypress_version_1.installedCypressVersion)() <= 3 &&
        !supportedV3Browsers.includes(browser)) {
        devkit_1.logger.warn((0, devkit_1.stripIndents) `
    Warning:
    You are using a browser that is not supported by cypress v3.
    `);
        return;
    }
}
function warnDeprecatedHeadless({ headless }) {
    if ((0, cypress_version_1.installedCypressVersion)() < 8 || headless === undefined) {
        return;
    }
    if (headless) {
        const deprecatedMsg = (0, devkit_1.stripIndents) `
    NOTE:
    You can now remove the use of the '--headless' flag during 'cypress run' as this is the default for all browsers.`;
        devkit_1.logger.warn(deprecatedMsg);
    }
}
function warnDeprecatedCypressVersion() {
    if ((0, cypress_version_1.installedCypressVersion)() < 10) {
        devkit_1.logger.warn((0, devkit_1.stripIndents) `
NOTE:
Support for Cypress versions < 10 is deprecated. Please upgrade to at least Cypress version 10.
A generator to migrate from v8 to v10 is provided. See https://nx.dev/cypress/v10-migration-guide
`);
    }
}
function startDevServer(opts, context) {
    var _a, _b, _c;
    return tslib_1.__asyncGenerator(this, arguments, function* startDevServer_1() {
        var _d, e_2, _e, _f;
        // no dev server, return the provisioned base url
        if (!opts.devServerTarget || opts.skipServe) {
            yield yield tslib_1.__await({ baseUrl: opts.baseUrl });
            return yield tslib_1.__await(void 0);
        }
        const parsedDevServerTarget = (0, devkit_1.parseTargetString)(opts.devServerTarget, context.projectGraph);
        const [targetSupportsWatchOpt] = getValueFromSchema(context, parsedDevServerTarget, 'watch');
        const overrides = Object.assign({}, (targetSupportsWatchOpt ? { watch: opts.watch } : {}));
        if (opts.port === 'cypress-auto') {
            const freePort = yield tslib_1.__await(getPortForProject(context, parsedDevServerTarget));
            overrides['port'] = freePort;
        }
        else if (opts.port !== undefined) {
            overrides['port'] = opts.port;
            // zero is a special case that means any valid port so there is no reason to try to 'lock it'
            if (opts.port !== 0) {
                const didLock = attemptToLockPort(opts.port);
                if (!didLock) {
                    devkit_1.logger.warn((0, devkit_1.stripIndents) `${opts.port} is potentially already in use by another cypress run.
If the port is in use, try using a different port value or passing --port='cypress-auto' to find a free port.`);
                }
            }
        }
        try {
            for (var _g = true, _h = tslib_1.__asyncValues(yield tslib_1.__await((0, devkit_1.runExecutor)(parsedDevServerTarget, overrides, context))), _j; _j = yield tslib_1.__await(_h.next()), _d = _j.done, !_d;) {
                _f = _j.value;
                _g = false;
                try {
                    const output = _f;
                    if (!output.success && !opts.watch)
                        throw new Error('Could not compile application files');
                    if (!opts.baseUrl &&
                        !output.baseUrl &&
                        !((_a = output.info) === null || _a === void 0 ? void 0 : _a.baseUrl) &&
                        ((_b = output.info) === null || _b === void 0 ? void 0 : _b.port)) {
                        output.baseUrl = `http://localhost:${output.info.port}`;
                    }
                    yield yield tslib_1.__await({
                        baseUrl: opts.baseUrl || output.baseUrl || ((_c = output.info) === null || _c === void 0 ? void 0 : _c.baseUrl),
                        portLockFilePath: overrides.port && (0, path_1.join)(__dirname, `${overrides.port}.txt`),
                    });
                }
                finally {
                    _g = true;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (!_g && !_d && (_e = _h.return)) yield tslib_1.__await(_e.call(_h));
            }
            finally { if (e_2) throw e_2.error; }
        }
    });
}
/**
 * @whatItDoes Initialize the Cypress test runner with the provided project configuration.
 * By default, Cypress will run tests from the CLI without the GUI and provide directly the results in the console output.
 * If `watch` is `true`: Open Cypress in the interactive GUI to interact directly with the application.
 */
function runCypress(baseUrl, opts) {
    var _a, _b;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const cypressVersion = (0, cypress_version_1.installedCypressVersion)();
        // Cypress expects the folder where a cypress config is present
        const projectFolderPath = (0, path_1.dirname)(opts.cypressConfig);
        const options = {
            project: projectFolderPath,
            configFile: (0, path_1.basename)(opts.cypressConfig),
        };
        // If not, will use the `baseUrl` normally from `cypress.json`
        if (baseUrl) {
            options.config = { baseUrl };
        }
        if (opts.browser) {
            options.browser = opts.browser;
        }
        if (opts.env) {
            options.env = opts.env;
        }
        if (opts.spec) {
            options.spec = opts.spec;
        }
        options.tag = opts.tag;
        options.exit = opts.exit;
        options.headed = opts.headed;
        if (opts.headless) {
            options.headless = opts.headless;
        }
        options.record = opts.record;
        options.key = opts.key;
        options.parallel = opts.parallel;
        options.ciBuildId = (_a = opts.ciBuildId) === null || _a === void 0 ? void 0 : _a.toString();
        options.group = opts.group;
        // renamed in cy 10
        if (cypressVersion >= 10) {
            (_b = options.config) !== null && _b !== void 0 ? _b : (options.config = {});
            options.config[opts.testingType] = {
                excludeSpecPattern: opts.ignoreTestFiles,
            };
        }
        else {
            options.ignoreTestFiles = opts.ignoreTestFiles;
        }
        if (opts.reporter) {
            options.reporter = opts.reporter;
        }
        if (opts.reporterOptions) {
            options.reporterOptions = opts.reporterOptions;
        }
        options.testingType = opts.testingType;
        const result = yield (opts.watch
            ? Cypress.open(options)
            : Cypress.run(options));
        cleanupTmpFile(opts.ctTailwindPath);
        cleanupTmpFile(opts.portLockFilePath);
        if (process.env.NX_VERBOSE_LOGGING === 'true' && opts.portLockFilePath) {
            (0, fs_1.readdirSync)((0, path_1.dirname)(opts.portLockFilePath)).forEach((f) => {
                if (f.endsWith('.txt')) {
                    devkit_1.logger.debug(`Lock file ${f} still present`);
                }
            });
        }
        /**
         * `cypress.open` is returning `0` and is not of the same type as `cypress.run`.
         * `cypress.open` is the graphical UI, so it will be obvious to know what wasn't
         * working. Forcing the build to success when `cypress.open` is used.
         */
        return !result.totalFailed && !result.failures;
    });
}
/**
 * try to find a free port for the project to run on
 * will return undefined if no port is found or the project doesn't have a port option
 **/
function getPortForProject(context, target, defaultPort = 4200) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const fmtTarget = (0, devkit_1.targetToTargetString)(target);
        const [hasPortOpt, schemaPortValue] = getValueFromSchema(context, target, 'port');
        let freePort;
        if (hasPortOpt) {
            let normalizedPortValue;
            if (!schemaPortValue) {
                devkit_1.logger.info(`NX ${fmtTarget} did not have a defined port value, checking for free port with the default value of ${defaultPort}`);
                normalizedPortValue = defaultPort;
            }
            else {
                normalizedPortValue = Number(schemaPortValue);
            }
            if (isNaN(normalizedPortValue)) {
                devkit_1.output.warn({
                    title: `Port Not a Number`,
                    bodyLines: [
                        `The port value found was not a number or can't be parsed to a number`,
                        `When reading the devServerTarget (${fmtTarget}) schema, expected ${schemaPortValue} to be a number but got NaN.`,
                        `Nx will use the default value of ${defaultPort} instead.`,
                        `You can manually specify a port by setting the 'port' option`,
                    ],
                });
                normalizedPortValue = defaultPort;
            }
            try {
                let attempts = 0;
                // make sure when this check happens in parallel,
                // we don't let the same port be used by multiple projects
                do {
                    freePort = yield detectPort(freePort || normalizedPortValue);
                    if (attemptToLockPort(freePort)) {
                        break;
                    }
                    attempts++;
                    // increment port in case the lock file isn't cleaned up
                    freePort++;
                } while (attempts < 20);
                devkit_1.logger.info(`NX Using port ${freePort} for ${fmtTarget}`);
            }
            catch (err) {
                throw new Error((0, devkit_1.stripIndents) `Unable to find a free port for the dev server, ${fmtTarget}.
You can disable auto port detection by specifing a port or not passing a value to --port`);
            }
        }
        else {
            devkit_1.output.warn({
                title: `No Port Option Found`,
                bodyLines: [
                    `The 'port' option is set to 'cypress-auto', but the devServerTarget (${fmtTarget}) does not have a port option.`,
                    `Because of this, Nx is unable to verify the port is free before starting the dev server.`,
                    `This might cause issues if the devServerTarget is trying to use a port that is already in use.`,
                ],
            });
        }
        return freePort;
    });
}
/**
 * Check if the given target has the given property in it's options.
 * if the property is does not have a default value or is not in the actual executor options,
 * the value will be undefined even if it's in the executor schema.
 **/
function getValueFromSchema(context, target, property) {
    var _a, _b;
    let targetOpts;
    try {
        targetOpts = (0, devkit_1.readTargetOptions)(target, context);
    }
    catch (e) {
        throw new Error(`Unable to read the target options for  ${(0, devkit_1.targetToTargetString)(target)}.
Are you sure this is a valid target?
Was trying to read the target for the property: '${property}', but got the following error: 
${e.message || e}`);
    }
    let targetHasOpt = Object.keys(targetOpts).includes(property);
    if (!targetHasOpt) {
        // NOTE: readTargetOptions doesn't apply non defaulted values, i.e. @nrwl/vite has a port options but is optional
        // so we double check the schema if readTargetOptions didn't return a value for the property
        const projectConfig = (_b = (_a = context.projectsConfigurations) === null || _a === void 0 ? void 0 : _a.projects) === null || _b === void 0 ? void 0 : _b[target.project];
        const targetConfig = projectConfig.targets[target.target];
        const workspace = new devkit_1.Workspaces(context.root);
        const [collection, executor] = targetConfig.executor.split(':');
        const { schema } = workspace.readExecutor(collection, executor);
        // NOTE: schema won't have a default since readTargetOptions would have
        // already set that and this check wouldn't need to be made
        targetHasOpt = Object.keys(schema.properties).includes(property);
    }
    return [targetHasOpt, targetOpts[property]];
}
function attemptToLockPort(port) {
    const portLockFilePath = (0, path_1.join)(__dirname, `${port}.txt`);
    try {
        if ((0, fs_1.existsSync)(portLockFilePath)) {
            return false;
        }
        (0, fs_1.writeFileSync)(portLockFilePath, 'locked');
        return true;
    }
    catch (err) {
        return false;
    }
}
function cleanupTmpFile(path) {
    try {
        if (path && (0, fs_1.existsSync)(path)) {
            (0, fs_1.unlinkSync)(path);
        }
        return true;
    }
    catch (err) {
        return false;
    }
}
//# sourceMappingURL=cypress.impl.js.map