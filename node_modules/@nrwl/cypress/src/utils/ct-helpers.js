"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createExecutorContext = exports.getProjectConfigByPath = exports.isCtProjectUsingBuildProject = exports.getTempTailwindPath = exports.CY_FILE_MATCHER = void 0;
const devkit_1 = require("@nrwl/devkit");
const path_1 = require("path");
const fs_1 = require("fs");
const find_project_for_path_1 = require("nx/src/project-graph/utils/find-project-for-path");
const project_graph_1 = require("nx/src/project-graph/project-graph");
const file_utils_1 = require("nx/src/project-graph/file-utils");
exports.CY_FILE_MATCHER = new RegExp(/\.cy\.[tj]sx?$/);
/**
 * return a path to a temp css file
 * temp file is scoped to the project root
 * i.e. <context.root>/tmp/<project-root>/ct-styles.css
 */
function getTempTailwindPath(context) {
    var _a;
    if (!context.projectName) {
        throw new Error('No project name found in context');
    }
    const project = context === null || context === void 0 ? void 0 : context.projectGraph.nodes[context.projectName];
    if (!project) {
        throw new Error(`No project found in project graph for ${context.projectName}`);
    }
    if ((_a = project === null || project === void 0 ? void 0 : project.data) === null || _a === void 0 ? void 0 : _a.root) {
        return (0, path_1.join)(context.root, 'tmp', project.data.root, 'ct-styles.css');
    }
}
exports.getTempTailwindPath = getTempTailwindPath;
/**
 * Checks if the childProjectName is a decendent of the parentProjectName
 * in the project graph
 **/
function isCtProjectUsingBuildProject(graph, parentProjectName, childProjectName) {
    const isProjectDirectDep = graph.dependencies[parentProjectName].some((p) => p.target === childProjectName);
    if (isProjectDirectDep) {
        return true;
    }
    const maybeIntermediateProjects = graph.dependencies[parentProjectName].filter((p) => !graph.externalNodes[p.target]);
    for (const maybeIntermediateProject of maybeIntermediateProjects) {
        if (isCtProjectUsingBuildProject(graph, maybeIntermediateProject.target, childProjectName)) {
            return true;
        }
    }
    return false;
}
exports.isCtProjectUsingBuildProject = isCtProjectUsingBuildProject;
function getProjectConfigByPath(graph, configPath) {
    var _a, _b, _c;
    var _d;
    const configFileFromWorkspaceRoot = (0, path_1.relative)(devkit_1.workspaceRoot, configPath);
    const normalizedPathFromWorkspaceRoot = (0, devkit_1.normalizePath)((0, fs_1.lstatSync)(configPath).isFile()
        ? configFileFromWorkspaceRoot.replace((0, path_1.extname)(configPath), '')
        : configFileFromWorkspaceRoot);
    const projectRootMappings = (0, find_project_for_path_1.createProjectRootMappings)(graph.nodes);
    const componentTestingProjectName = (0, find_project_for_path_1.findProjectForPath)(normalizedPathFromWorkspaceRoot, projectRootMappings);
    if (!componentTestingProjectName ||
        !((_a = graph.nodes[componentTestingProjectName]) === null || _a === void 0 ? void 0 : _a.data)) {
        throw new Error((0, devkit_1.stripIndents) `Unable to find the project configuration that includes ${normalizedPathFromWorkspaceRoot}. 
      Found project name? ${componentTestingProjectName}. 
      Graph has data? ${!!((_b = graph.nodes[componentTestingProjectName]) === null || _b === void 0 ? void 0 : _b.data)}`);
    }
    // make sure name is set since it can be undefined
    (_c = (_d = graph.nodes[componentTestingProjectName].data).name) !== null && _c !== void 0 ? _c : (_d.name = componentTestingProjectName);
    return graph.nodes[componentTestingProjectName].data;
}
exports.getProjectConfigByPath = getProjectConfigByPath;
function createExecutorContext(graph, targets, projectName, targetName, configurationName) {
    const projectsConfigurations = (0, project_graph_1.readProjectsConfigurationFromProjectGraph)(graph);
    const nxJsonConfiguration = (0, file_utils_1.readNxJson)();
    return {
        cwd: process.cwd(),
        projectGraph: graph,
        target: targets[targetName],
        targetName,
        configurationName,
        root: devkit_1.workspaceRoot,
        isVerbose: false,
        projectName,
        projectsConfigurations,
        nxJsonConfiguration,
        workspace: Object.assign(Object.assign({}, nxJsonConfiguration), projectsConfigurations),
    };
}
exports.createExecutorContext = createExecutorContext;
//# sourceMappingURL=ct-helpers.js.map