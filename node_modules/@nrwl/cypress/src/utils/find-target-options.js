"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findBuildConfig = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const file_utils_1 = require("nx/src/project-graph/file-utils");
const project_graph_1 = require("nx/src/project-graph/project-graph");
function findBuildConfig(tree, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            // attempt to use the provided target
            const graph = yield (0, devkit_1.createProjectGraphAsync)();
            if (options.buildTarget) {
                return {
                    target: options.buildTarget,
                    config: findInTarget(tree, graph, options),
                };
            }
            // check to see if there is a valid config in the given project
            const selfProject = findTargetOptionsInProject(tree, graph, options.project, options.validExecutorNames);
            if (selfProject) {
                return selfProject;
            }
            // attempt to find any projects with the valid config in the graph that consumes this project
            return yield findInGraph(tree, graph, options);
        }
        catch (e) {
            devkit_1.logger.error(e);
            throw new Error((0, devkit_1.stripIndents) `Error trying to find build configuration. Try manually specifying the build target with the --build-target flag.
    Provided project? ${options.project}
    Provided build target? ${options.buildTarget}
    Provided Executors? ${[...options.validExecutorNames].join(', ')}`);
        }
    });
}
exports.findBuildConfig = findBuildConfig;
function findInTarget(tree, graph, options) {
    var _a, _b, _c, _d;
    const { project, target, configuration } = (0, devkit_1.parseTargetString)(options.buildTarget);
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, project);
    const executorName = (_b = (_a = projectConfig === null || projectConfig === void 0 ? void 0 : projectConfig.targets) === null || _a === void 0 ? void 0 : _a[target]) === null || _b === void 0 ? void 0 : _b.executor;
    if (!options.validExecutorNames.has(executorName)) {
        devkit_1.logger.error((0, devkit_1.stripIndents) `NX The provided build target, ${options.buildTarget}, uses the '${executorName}' executor.
But only the follow executors are allowed
${Array.from(options.validExecutorNames)
            .map((ve) => ` - ${ve}`)
            .join('\n')}

This is most likely because the provided --build-target is not a build target for an application.
For example, the provide build target, '${options.buildTarget}' is:
 - the build target for a buildable/publishable library instead of an app.
 - using a different framework than expected like react library using an angular app build target.

If you do not have an app in the workspace to you can make a new app with 'nx g app' and use it just for component testing
`);
        throw new Error('The provided --build-target does not use an executor in the allow list of executors defined.');
    }
    const foundConfig = configuration || ((_d = (_c = projectConfig === null || projectConfig === void 0 ? void 0 : projectConfig.targets) === null || _c === void 0 ? void 0 : _c[target]) === null || _d === void 0 ? void 0 : _d.defaultConfiguration);
    return (0, devkit_1.readTargetOptions)({ project, target, configuration: foundConfig }, createExecutorContext(graph, projectConfig.targets, project, target, foundConfig));
}
function findInGraph(tree, graph, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const parents = findParentsOfProject(graph, options.project);
        const potentialTargets = [];
        for (const parent of parents) {
            const parentProject = findTargetOptionsInProject(tree, graph, parent.target, options.validExecutorNames);
            if (parentProject) {
                potentialTargets.push(parentProject);
            }
        }
        if (potentialTargets.length > 1) {
            devkit_1.logger.warn((0, devkit_1.stripIndents) `Multiple potential targets found for ${options.project}. Found ${potentialTargets.length}.
    Using ${potentialTargets[0].target}.
    To specify a different target use the --build-target flag.
    `);
        }
        return potentialTargets[0];
    });
}
function findParentsOfProject(graph, projectName) {
    const reversedGraph = (0, devkit_1.reverse)(graph);
    return reversedGraph.dependencies[projectName]
        ? Object.values(reversedGraph.dependencies[projectName])
        : [];
}
function findTargetOptionsInProject(tree, graph, projectName, includes) {
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    for (const targetName in projectConfig.targets) {
        const targetConfig = projectConfig.targets[targetName];
        if (includes.has(targetConfig.executor)) {
            return {
                target: `${projectName}:${targetName}`,
                config: (0, devkit_1.readTargetOptions)({ project: projectName, target: targetName }, createExecutorContext(graph, projectConfig.targets, projectName, targetName, null)),
            };
        }
    }
}
function createExecutorContext(graph, targets, projectName, targetName, configurationName) {
    const nxJsonConfiguration = (0, file_utils_1.readNxJson)();
    const projectsConfigurations = (0, project_graph_1.readProjectsConfigurationFromProjectGraph)(graph);
    return {
        cwd: process.cwd(),
        projectGraph: graph,
        target: targets[targetName],
        targetName,
        configurationName,
        root: devkit_1.workspaceRoot,
        isVerbose: false,
        projectName,
        projectsConfigurations,
        nxJsonConfiguration,
        workspace: Object.assign(Object.assign({}, projectsConfigurations), nxJsonConfiguration),
    };
}
//# sourceMappingURL=find-target-options.js.map