"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateCyFile = exports.addMountCommand = exports.updateCyMountUsage = void 0;
const tslib_1 = require("tslib");
const ct_helpers_1 = require("../../utils/ct-helpers");
const cypress_version_1 = require("../../utils/cypress-version");
const devkit_1 = require("@nrwl/devkit");
const executor_options_utils_1 = require("@nrwl/devkit/src/generators/executor-options-utils");
const semver_1 = require("@nrwl/devkit/src/utils/semver");
const tsquery_1 = require("@phenomnomnominal/tsquery");
const semver_2 = require("semver");
function updateCyMountUsage(tree) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if ((0, cypress_version_1.installedCypressVersion)() < 10) {
            return;
        }
        const projects = (0, devkit_1.getProjects)(tree);
        const graph = yield (0, devkit_1.createProjectGraphAsync)();
        (0, executor_options_utils_1.forEachExecutorOptions)(tree, '@nrwl/cypress:cypress', (options, projectName) => {
            if (options.testingType !== 'component' || !options.devServerTarget) {
                return;
            }
            const parsed = (0, devkit_1.parseTargetString)(options.devServerTarget, graph);
            if (!(parsed === null || parsed === void 0 ? void 0 : parsed.project) || !(parsed === null || parsed === void 0 ? void 0 : parsed.target)) {
                return;
            }
            const buildProjectConfig = projects.get(parsed.project);
            const framework = getFramework(tree, parsed.configuration
                ? buildProjectConfig.targets[parsed.target].configurations[parsed.configuration]
                : buildProjectConfig.targets[parsed.target]);
            const ctProjectConfig = projects.get(projectName);
            addMountCommand(tree, ctProjectConfig.root, framework);
            (0, devkit_1.visitNotIgnoredFiles)(tree, ctProjectConfig.sourceRoot, (filePath) => {
                if (ct_helpers_1.CY_FILE_MATCHER.test(filePath)) {
                    updateCyFile(tree, filePath, framework);
                }
            });
        });
        yield (0, devkit_1.formatFiles)(tree);
    });
}
exports.updateCyMountUsage = updateCyMountUsage;
function addMountCommand(tree, projectRoot, framework) {
    const commandFilePath = (0, devkit_1.joinPathFragments)(projectRoot, 'cypress', 'support', 'commands.ts');
    if (!tree.exists(commandFilePath)) {
        return;
    }
    const commandFile = tree.read(commandFilePath, 'utf-8');
    const mountCommand = tsquery_1.tsquery.query(commandFile, 'CallExpression:has(StringLiteral[value="mount"]) PropertyAccessExpression:has(Identifier[name="add"])');
    if ((mountCommand === null || mountCommand === void 0 ? void 0 : mountCommand.length) > 0) {
        return;
    }
    const existingCommands = tsquery_1.tsquery.query(commandFile, 'InterfaceDeclaration:has(Identifier[name="Chainable"]) > MethodSignature, InterfaceDeclaration:has(Identifier[name="Chainable"]) > PropertySignature');
    const isGlobalDeclaration = tsquery_1.tsquery.query(commandFile, 'ModuleDeclaration > Identifier[name="global"]');
    const updatedInterface = tsquery_1.tsquery.replace(commandFile, 'ModuleDeclaration:has(Identifier[name="Cypress"])', (node) => {
        const newModuleDelcaration = `declare global {
  // eslint-disable-next-line @typescript-eslint/no-namespace
  namespace Cypress {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    interface Chainable<Subject> {
      ${existingCommands.map((c) => c.getText()).join('\n')}
      mount: typeof mount;
    }
  }
}`;
        /*
         * this is to prevent the change being applied twice since
         * declare global { 1
         *   interface Cypress { 2
         *   }
         * }
         * matches twice.
         * i.e. if there is no global declaration, then add it
         * or if the node is the global declaration, then add it,
         * but not to the cypress module declaration inside the global declaration
         */
        if ((isGlobalDeclaration === null || isGlobalDeclaration === void 0 ? void 0 : isGlobalDeclaration.length) === 0 ||
            node.name.getText() === 'global') {
            return newModuleDelcaration;
        }
    });
    const updatedCommandFile = `import { mount } from 'cypress/${framework}'\n${updatedInterface}\nCypress.Commands.add('mount', mount);`;
    tree.write(commandFilePath, updatedCommandFile);
}
exports.addMountCommand = addMountCommand;
function getFramework(tree, target) {
    var _a;
    if (target.executor === '@nrwl/angular:webpack-browser' ||
        target.executor === '@angular-devkit/build-angular:browser') {
        return 'angular';
    }
    const pkgJson = (0, devkit_1.readJson)(tree, 'package.json');
    const reactDomVersion = (_a = pkgJson === null || pkgJson === void 0 ? void 0 : pkgJson.dependencies) === null || _a === void 0 ? void 0 : _a['react-dom'];
    const hasReact18 = reactDomVersion &&
        (0, semver_2.gte)((0, semver_1.checkAndCleanWithSemver)('react-dom', reactDomVersion), '18.0.0');
    if (hasReact18) {
        return 'react18';
    }
    return 'react';
}
function updateCyFile(tree, filePath, framework) {
    if (!tree.exists(filePath)) {
        return;
    }
    const contents = tree.read(filePath, 'utf-8');
    const withCyMount = tsquery_1.tsquery.replace(contents, ':matches(CallExpression>Identifier[name="mount"])', (node) => {
        return `cy.mount`;
    });
    const withUpdatedImports = tsquery_1.tsquery.replace(withCyMount, ':matches(ImportDeclaration, VariableStatement):has(Identifier[name="mount"]):has(StringLiteral[value="cypress/react"], StringLiteral[value="cypress/angular"], StringLiteral[value="cypress/react18"])', (node) => {
        switch (framework) {
            case 'angular':
                return `import { MountConfig } from 'cypress/angular';`;
            case 'react18':
            case 'react':
                return ' '; // have to return non falsy string to remove the node
            default:
                return node.getText().replace('mount', '');
        }
    });
    tree.write(filePath, withUpdatedImports);
}
exports.updateCyFile = updateCyFile;
exports.default = updateCyMountUsage;
//# sourceMappingURL=update-cy-mount-usage.js.map