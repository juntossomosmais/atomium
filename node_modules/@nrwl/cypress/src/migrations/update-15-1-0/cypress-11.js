"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateProviderUsage = exports.updateUnmountUsage = exports.updateMountHookUsage = exports.updateToCypress11 = void 0;
const tslib_1 = require("tslib");
const ct_helpers_1 = require("../../utils/ct-helpers");
const devkit_1 = require("@nrwl/devkit");
const executor_options_utils_1 = require("@nrwl/devkit/src/generators/executor-options-utils");
const tsquery_1 = require("@phenomnomnominal/tsquery");
const path_1 = require("path");
const ts = require("typescript");
const cypress_version_1 = require("../../utils/cypress-version");
const versions_1 = require("../../utils/versions");
function updateToCypress11(tree) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const installedVersion = (0, cypress_version_1.installedCypressVersion)();
        if (installedVersion < 10) {
            return;
        }
        const projects = (0, devkit_1.getProjects)(tree);
        (0, executor_options_utils_1.forEachExecutorOptions)(tree, '@nrwl/cypress:cypress', (options, projectName, targetName, configurationName) => {
            if (options.testingType !== 'component' ||
                !(options.cypressConfig && tree.exists(options.cypressConfig))) {
                return;
            }
            const projectConfig = projects.get(projectName);
            const commandsFile = (0, devkit_1.joinPathFragments)(projectConfig.root, 'cypress', 'support', 'commands.ts');
            const framework = getFramework(tree.exists(commandsFile)
                ? tree.read(commandsFile, 'utf-8')
                : tree.read(options.cypressConfig, 'utf-8'));
            (0, devkit_1.visitNotIgnoredFiles)(tree, projectConfig.sourceRoot, (filePath) => {
                if (!ct_helpers_1.CY_FILE_MATCHER.test(filePath)) {
                    return;
                }
                const frameworkFromFile = getFramework(tree.read(filePath, 'utf-8'));
                if (framework === 'react' || frameworkFromFile === 'react') {
                    updateUnmountUsage(tree, filePath);
                    updateMountHookUsage(tree, filePath);
                }
                if (framework === 'angular' || frameworkFromFile === 'angular') {
                    updateProviderUsage(tree, filePath);
                }
            });
        });
        const installTask = (0, devkit_1.addDependenciesToPackageJson)(tree, {}, { cypress: versions_1.cypressVersion });
        yield (0, devkit_1.formatFiles)(tree);
        return () => {
            installTask();
        };
    });
}
exports.updateToCypress11 = updateToCypress11;
function updateMountHookUsage(tree, filePath) {
    const originalContents = tree.read(filePath, 'utf-8');
    const commentedMountHook = tsquery_1.tsquery.replace(originalContents, ':matches(ImportDeclaration, VariableStatement):has(Identifier[name="mountHook"]):has(StringLiteral[value="cypress/react"], StringLiteral[value="cypress/react18"])', (node) => {
        return `/** TODO: mountHook is deprecate. 
* Use a wrapper component instead. 
* See post for details: https://www.cypress.io/blog/2022/11/04/upcoming-changes-to-component-testing/#reactmounthook-removed 
* */\n${node.getText()}`;
    });
    tree.write(filePath, commentedMountHook);
}
exports.updateMountHookUsage = updateMountHookUsage;
function updateUnmountUsage(tree, filePath) {
    const reactDomImport = (0, path_1.extname)(filePath).includes('ts')
        ? `import ReactDom from 'react-dom'`
        : `const ReactDom = require('react-dom')`;
    const originalContents = tree.read(filePath, 'utf-8');
    const updatedImports = tsquery_1.tsquery.replace(originalContents, ':matches(ImportDeclaration, VariableStatement):has(Identifier[name="unmount"]):has(StringLiteral[value="cypress/react"], StringLiteral[value="cypress/react18"])', (node) => {
        return `${node.getText().replace('unmount', 'getContainerEl')}
${reactDomImport}`;
    });
    const updatedUnmountApi = tsquery_1.tsquery.replace(updatedImports, 'ExpressionStatement > CallExpression:has(Identifier[name="unmount"])', (node) => {
        if (node.expression.getText() === 'unmount') {
            return `cy.then(() => ReactDom.unmountComponentAtNode(getContainerEl()))`;
        }
    });
    tree.write(filePath, updatedUnmountApi);
}
exports.updateUnmountUsage = updateUnmountUsage;
function updateProviderUsage(tree, filePath) {
    var _a;
    const originalContents = tree.read(filePath, 'utf-8');
    const isTestBedImported = ((_a = tsquery_1.tsquery.query(originalContents, ':matches(ImportDeclaration, VariableStatement):has(Identifier[name="TestBed"]):has(StringLiteral[value="@angular/core/testing"])')) === null || _a === void 0 ? void 0 : _a.length) > 0;
    let updatedProviders = tsquery_1.tsquery.replace(originalContents, 'CallExpression:has(PropertyAccessExpression:has(Identifier[name="mount"]))', (node) => {
        var _a, _b, _c, _d;
        const expressionName = node.expression.getText();
        if (expressionName === 'cy.mount' && ((_a = node === null || node === void 0 ? void 0 : node.arguments) === null || _a === void 0 ? void 0 : _a.length) > 1) {
            const component = node.arguments[0].getText();
            if (ts.isObjectLiteralExpression(node.arguments[1])) {
                const providers = (_d = (_c = (_b = node.arguments[1]) === null || _b === void 0 ? void 0 : _b.properties) === null || _c === void 0 ? void 0 : _c.find((p) => { var _a; return ((_a = p.name) === null || _a === void 0 ? void 0 : _a.getText()) === 'providers'; })) === null || _d === void 0 ? void 0 : _d.getText();
                const noProviders = tsquery_1.tsquery.replace(node.getText(), 'PropertyAssignment:has(Identifier[name="providers"])', (n) => {
                    // set it to undefined so we don't run into a hanging comma causing invalid syntax
                    return 'providers: undefined';
                });
                return `TestBed.overrideComponent(${component}, { add: { ${providers} }});\n${noProviders}`;
            }
            else {
                return `TestBed.overrideComponent(${component}, {add: { providers: ${node.arguments[1].getText()}.providers}});\n${node.getText()}`;
            }
        }
    });
    tree.write(filePath, `${isTestBedImported
        ? ''
        : "import {TestBed} from '@angular/core/testing';\n"}${updatedProviders}`);
}
exports.updateProviderUsage = updateProviderUsage;
function getFramework(contents) {
    if (contents.includes('cypress/react') || contents.includes('@nrwl/react')) {
        return 'react';
    }
    if (contents.includes('cypress/angular') ||
        contents.includes('@nrwl/angular')) {
        return 'angular';
    }
    return null;
}
exports.default = updateToCypress11;
//# sourceMappingURL=cypress-11.js.map