"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateCypressConfigsPresets = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const executor_options_utils_1 = require("@nrwl/devkit/src/generators/executor-options-utils");
const tsquery_1 = require("@phenomnomnominal/tsquery");
const cypress_version_1 = require("../../utils/cypress-version");
const find_target_options_1 = require("../../utils/find-target-options");
function updateCypressConfigsPresets(tree) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if ((0, cypress_version_1.installedCypressVersion)() < 10) {
            return;
        }
        const projectsWithoutDevServerTarget = new Set();
        const updateTasks = [];
        (0, executor_options_utils_1.forEachExecutorOptions)(tree, '@nrwl/cypress:cypress', (options, projectName, targetName, configName) => {
            var _a, _b, _c, _d;
            if (options.cypressConfig && tree.exists(options.cypressConfig)) {
                updatePreset(tree, options, targetName);
            }
            const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, projectName);
            const testingType = options.testingType ||
                ((_b = (_a = projectConfig.targets[targetName]) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.testingType);
            const devServerTarget = options.devServerTarget ||
                ((_d = (_c = projectConfig.targets[targetName]) === null || _c === void 0 ? void 0 : _c.options) === null || _d === void 0 ? void 0 : _d.devServerTarget);
            if (!devServerTarget && testingType === 'component') {
                updateTasks.push(addBuildTargetToConfig(tree, projectName, targetName, configName).then((didUpdate) => {
                    if (!didUpdate) {
                        projectsWithoutDevServerTarget.add(projectName);
                    }
                }));
            }
        });
        if (updateTasks.length > 0) {
            cacheComponentTestTarget(tree);
        }
        yield Promise.all(updateTasks);
        if (projectsWithoutDevServerTarget.size > 0) {
            devkit_1.logger.warn(`Unable to find a build target to add to the component testing target in the following projects:`);
            devkit_1.logger.warn(`- ${Array.from(projectsWithoutDevServerTarget).join('\n- ')}`);
            devkit_1.logger.warn((0, devkit_1.stripIndents) `
You can manually add the 'devServerTarget' option to the 
component testing target to specify the build target to use.
The build configuration should be using @nrwl/web:webpack as the executor. 
Usually this is a React app in your workspace. 
Component testing will fallback to a default configuration if one isn't provided, 
but might require modifications if your projects are more complex.
    `);
        }
    });
}
exports.updateCypressConfigsPresets = updateCypressConfigsPresets;
function updatePreset(tree, options, targetName) {
    let contents = tsquery_1.tsquery.replace(tree.read(options.cypressConfig, 'utf-8'), 'CallExpression', (node) => {
        // technically someone could have both component and e2e in the same project.
        const expression = node.expression.getText();
        if (expression === 'nxE2EPreset') {
            return 'nxE2EPreset(__filename)';
        }
        else if (expression === 'nxE2EStorybookPreset') {
            return 'nxE2EStorybookPreset(__filename)';
        }
        else if (node.expression.getText() === 'nxComponentTestingPreset') {
            return targetName && targetName !== 'component-test' // the default
                ? `nxComponentTestingPreset(__filename, { ctTargetName: '${targetName}' })`
                : 'nxComponentTestingPreset(__filename)';
        }
        return;
    });
    tree.write(options.cypressConfig, contents);
}
function addBuildTargetToConfig(tree, projectName, targetName, configName) {
    var _a, _b;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const projectWithBuild = yield (0, find_target_options_1.findBuildConfig)(tree, {
            project: projectName,
            validExecutorNames: new Set(['@nrwl/web:webpack']),
        });
        // didn't find the config so can't update. consumer should collect list of them and display a warning at the end
        // no reason to fail since the preset will fallback to a default config so should still keep working.
        if (!(projectWithBuild === null || projectWithBuild === void 0 ? void 0 : projectWithBuild.target) || !(projectWithBuild === null || projectWithBuild === void 0 ? void 0 : projectWithBuild.config)) {
            return false;
        }
        const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, projectName);
        // if using a custom config and the devServerTarget default args
        // has a different target, then add it to the custom target config
        // otherwise add it to the default options
        if (configName &&
            projectWithBuild.target !==
                ((_b = (_a = projectConfig.targets[targetName]) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.devServerTarget)) {
            projectConfig.targets[targetName].configurations[configName] = Object.assign(Object.assign({}, projectConfig.targets[targetName].configurations[configName]), { devServerTarget: projectWithBuild.target, skipServe: true });
        }
        else {
            projectConfig.targets[targetName].options = Object.assign(Object.assign({}, projectConfig.targets[targetName].options), { devServerTarget: projectWithBuild.target, skipServe: true });
        }
        (0, devkit_1.updateProjectConfiguration)(tree, projectName, projectConfig);
        return true;
    });
}
function cacheComponentTestTarget(tree) {
    (0, devkit_1.updateJson)(tree, 'nx.json', (json) => {
        var _a, _b, _c, _d, _e, _f, _g;
        return (Object.assign(Object.assign({}, json), { tasksRunnerOptions: Object.assign(Object.assign({}, json.tasksRunnerOptions), { default: Object.assign(Object.assign({}, (_a = json.tasksRunnerOptions) === null || _a === void 0 ? void 0 : _a.default), { options: Object.assign(Object.assign({}, (_c = (_b = json.tasksRunnerOptions) === null || _b === void 0 ? void 0 : _b.default) === null || _c === void 0 ? void 0 : _c.options), { cacheableOperations: Array.from(new Set([
                            ...((_g = (_f = (_e = (_d = json.tasksRunnerOptions) === null || _d === void 0 ? void 0 : _d.default) === null || _e === void 0 ? void 0 : _e.options) === null || _f === void 0 ? void 0 : _f.cacheableOperations) !== null && _g !== void 0 ? _g : []),
                            'component-test',
                        ])) }) }) }) }));
    });
}
exports.default = updateCypressConfigsPresets;
//# sourceMappingURL=update-cypress-configs-presets.js.map