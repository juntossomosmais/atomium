"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldNotOverrideCommands = exports.shouldNotUseCyInShouldCB = exports.shouldUseCySession = exports.shouldUseCyIntercept = exports.turnOffTestIsolation = exports.updateToCypress12 = void 0;
const devkit_1 = require("@nrwl/devkit");
const executor_options_utils_1 = require("@nrwl/devkit/src/generators/executor-options-utils");
const tsquery_1 = require("@phenomnomnominal/tsquery");
const typescript_1 = require("typescript");
const cypress_version_1 = require("../../utils/cypress-version");
const helpers_1 = require("./helpers");
const JS_TS_FILE_MATCHER = /\.[jt]sx?$/;
function updateToCypress12(tree) {
    if ((0, cypress_version_1.installedCypressVersion)() < 11) {
        return;
    }
    const projects = (0, devkit_1.getProjects)(tree);
    (0, executor_options_utils_1.forEachExecutorOptions)(tree, '@nrwl/cypress:cypress', (options, projectName, targetName, configName) => {
        if (!(options.cypressConfig && tree.exists(options.cypressConfig))) {
            return;
        }
        const projectConfig = projects.get(projectName);
        turnOffTestIsolation(tree, options.cypressConfig);
        (0, devkit_1.visitNotIgnoredFiles)(tree, projectConfig.root, (filePath) => {
            if (!JS_TS_FILE_MATCHER.test(filePath)) {
                return;
            }
            shouldUseCyIntercept(tree, filePath);
            shouldUseCySession(tree, filePath);
            shouldNotUseCyInShouldCB(tree, filePath);
            shouldNotOverrideCommands(tree, filePath);
        });
    });
    console.warn((0, devkit_1.stripIndents) `Cypress 12 has lots of breaking changes that might subtly break your tests.
This migration marked known issues that need to be manually migrated, 
but there can still be runtime based errors that were not detected.
Please consult the offical Cypress v12 migration guide for more info on these changes and the next steps.
https://docs.cypress.io/guides/references/migration-guide
      `);
    (0, devkit_1.updateJson)(tree, 'package.json', (json) => {
        json.devDependencies.cypress = '^12.2.0';
        return json;
    });
    return () => {
        (0, devkit_1.installPackagesTask)(tree);
    };
}
exports.updateToCypress12 = updateToCypress12;
function turnOffTestIsolation(tree, configPath) {
    const config = tree.read(configPath, 'utf-8');
    const isTestIsolationSet = tsquery_1.tsquery.query(config, 'ExportAssignment ObjectLiteralExpression > PropertyAssignment:has(Identifier[name="testIsolation"])');
    if (isTestIsolationSet.length > 0) {
        return;
    }
    const testIsolationProperty = `/**
    * TODO(@nrwl/cypress): In Cypress v12,the testIsolation option is turned on by default. 
    * This can cause tests to start breaking where not indended.
    * You should consider enabling this once you verify tests do not depend on each other
    * More Info: https://docs.cypress.io/guides/references/migration-guide#Test-Isolation
    **/
    testIsolation: false,`;
    const updated = tsquery_1.tsquery.replace(config, 'ExportAssignment ObjectLiteralExpression > PropertyAssignment:has(Identifier[name="e2e"])', (node) => {
        if ((0, typescript_1.isObjectLiteralExpression)(node.initializer)) {
            const listOfProperties = node.initializer.properties
                .map((j) => j.getText())
                .join(',\n    ');
            return `e2e: {
    ${listOfProperties},
    ${testIsolationProperty}
 }`;
        }
        return `e2e: {
    ...${node.initializer.getText()},
    ${testIsolationProperty}
  }`;
    });
    tree.write(configPath, updated);
}
exports.turnOffTestIsolation = turnOffTestIsolation;
/**
 * Leave a comment on all apis that have been removed andsuperseded by cy.intercept
 * stating they these API are now removed and need to update.
 * cy.route, cy.server, Cypress.Server.defaults
 **/
function shouldUseCyIntercept(tree, filePath) {
    const content = tree.read(filePath, 'utf-8');
    const markedRemovedCommands = tsquery_1.tsquery.replace(content, ':matches(PropertyAccessExpression:has(Identifier[name="cy"]):has(Identifier[name="server"], Identifier[name="route"]), PropertyAccessExpression:has(Identifier[name="defaults"]):has(Identifier[name="Cypress"], Identifier[name="Server"]))', (node) => {
        if ((0, helpers_1.isAlreadyCommented)(node)) {
            return;
        }
        const expression = node.expression.getText().trim();
        // prevent extra chaining i.e. cy.route().as() will return 2 results
        // cy.route and cy.route().as
        // only need the first 1 so skip any extra chaining
        if (expression === 'cy' || expression === 'Cypress.Server') {
            return `// TODO(@nrwl/cypress): this command has been removed, use cy.intercept instead. https://docs.cypress.io/guides/references/migration-guide#cy-server-cy-route-and-Cypress-Server-defaults
${node.getText()}`;
        }
    });
    tree.write(filePath, markedRemovedCommands);
}
exports.shouldUseCyIntercept = shouldUseCyIntercept;
/**
 * Leave a comment on all apis that have been removed and superseded by cy.session
 * stating they these API are now removed and need to update.
 * Cypress.Cookies.defaults & Cypress.Cookies.preserveOnce
 **/
function shouldUseCySession(tree, filePath) {
    const content = tree.read(filePath, 'utf-8');
    const markedRemovedCommands = tsquery_1.tsquery.replace(content, ':matches(PropertyAccessExpression:has(Identifier[name="defaults"]):has(Identifier[name="Cypress"], Identifier[name="Cookies"]), PropertyAccessExpression:has(Identifier[name="preserveOnce"]):has(Identifier[name="Cypress"], Identifier[name="Cookies"]))', (node) => {
        if ((0, helpers_1.isAlreadyCommented)(node)) {
            return;
        }
        const expression = node.expression.getText().trim();
        // prevent grabbing other Cypress.<something>.defaults
        if (expression === 'Cypress.Cookies') {
            return `// TODO(@nrwl/cypress): this command has been removed, use cy.session instead. https://docs.cypress.io/guides/references/migration-guide#Command-Cypress-API-Changes
${node.getText()}`;
        }
    });
    tree.write(filePath, markedRemovedCommands);
}
exports.shouldUseCySession = shouldUseCySession;
/**
 * leave a comment about nested cy commands in a cy.should callback
 * */
function shouldNotUseCyInShouldCB(tree, filePath) {
    const content = tree.read(filePath, 'utf-8');
    const markedNestedCyCommands = tsquery_1.tsquery.replace(content, 'CallExpression > PropertyAccessExpression:has(Identifier[name="cy"]):has(Identifier[name="should"])', (node) => {
        var _a, _b;
        if ((0, helpers_1.isAlreadyCommented)(node) ||
            (node.parent && !(0, typescript_1.isCallExpression)(node.parent))) {
            return;
        }
        const parentExpression = node.parent;
        if (((_a = parentExpression === null || parentExpression === void 0 ? void 0 : parentExpression.arguments) === null || _a === void 0 ? void 0 : _a[0]) &&
            ((0, typescript_1.isArrowFunction)(parentExpression.arguments[0]) ||
                (0, typescript_1.isFunctionExpression)(parentExpression.arguments[0]))) {
            const isUsingNestedCyCommand = ((_b = tsquery_1.tsquery.query(parentExpression.arguments[0], 'CallExpression > PropertyAccessExpression:has(Identifier[name="cy"])')) === null || _b === void 0 ? void 0 : _b.length) > 0;
            if (isUsingNestedCyCommand) {
                return `/**
* TODO(@nrwl/cypress): Nesting Cypress commands in a should assertion now throws.
* You should use .then() to chain commands instead.
* More Info: https://docs.cypress.io/guides/references/migration-guide#-should
**/
${node.getText()}`;
            }
            return node.getText();
        }
    });
    tree.write(filePath, markedNestedCyCommands);
}
exports.shouldNotUseCyInShouldCB = shouldNotUseCyInShouldCB;
/**
 * leave a comment on all usages of overriding built-ins that are now banned
 * */
function shouldNotOverrideCommands(tree, filePath) {
    const content = tree.read(filePath, 'utf-8');
    const markedOverrideUsage = tsquery_1.tsquery.replace(content, 'PropertyAccessExpression:has(Identifier[name="overwrite"]):has(Identifier[name="Cypress"])', (node) => {
        var _a, _b;
        if ((0, helpers_1.isAlreadyCommented)(node)) {
            return;
        }
        const expression = node.expression.getText().trim();
        // prevent grabbing other Cypress.<something>.defaults
        if (expression === 'Cypress.Commands') {
            // get value.
            const overwriteExpression = node.parent;
            const command = (_b = (_a = overwriteExpression.arguments) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.text; // need string without quotes
            if (helpers_1.BANNED_COMMANDS.includes(command)) {
                // overwrite
                return `/**
* TODO(@nrwl/cypress): This command can no longer be overridden
* Consider using a different name like 'custom_${command}'
* More info: https://docs.cypress.io/guides/references/migration-guide#Cypress-Commands-overwrite
**/
${node.getText()}`;
            }
        }
    });
    tree.write(filePath, markedOverrideUsage);
}
exports.shouldNotOverrideCommands = shouldNotOverrideCommands;
exports.default = updateToCypress12;
//# sourceMappingURL=update-to-cypress-12.js.map