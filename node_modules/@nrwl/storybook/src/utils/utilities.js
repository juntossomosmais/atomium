"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTsSourceFile = exports.isTheFileAStory = exports.findStorybookAndBuildTargetsAndCompiler = exports.dedupe = exports.storybookConfigExistsCheck = exports.readCurrentWorkspaceStorybookVersionFromExecutor = exports.readCurrentWorkspaceStorybookVersionFromGenerator = exports.safeFileDelete = exports.isStorybookV7 = exports.Constants = void 0;
const devkit_1 = require("@nrwl/devkit");
const versions_1 = require("./versions");
const fs_1 = require("fs");
const typescript_1 = require("nx/src/utils/typescript");
const ts = require("typescript");
const semver_1 = require("semver");
const path_1 = require("path");
exports.Constants = {
    addonDependencies: ['@storybook/addons'],
    tsConfigExclusions: ['stories', '**/*.stories.ts'],
    pkgJsonScripts: {
        storybook: 'start-storybook -p 9001 -c .storybook',
    },
    jsonIndentLevel: 2,
    coreAddonPrefix: '@storybook/addon-',
    uiFrameworks: {
        angular: '@storybook/angular',
        react: '@storybook/react',
        html: '@storybook/html',
        'web-components': '@storybook/web-components',
        vue: '@storybook/vue',
        vue3: '@storybook/vue3',
        svelte: '@storybook/svelte',
        'react-native': '@storybook/react-native',
    },
    uiFrameworks7: [
        '@storybook/angular',
        '@storybook/html-webpack5',
        '@storybook/nextjs',
        '@storybook/preact-webpack5',
        '@storybook/react-webpack5',
        '@storybook/react-vite',
        '@storybook/server-webpack5',
        '@storybook/svelte-webpack5',
        '@storybook/svelte-vite',
        '@storybook/sveltekit',
        '@storybook/vue-webpack5',
        '@storybook/vue-vite',
        '@storybook/vue3-webpack5',
        '@storybook/vue3-vite',
        '@storybook/web-components-webpack5',
        '@storybook/web-components-vite',
    ],
};
function isStorybookV7() {
    const storybookPackageVersion = require((0, path_1.join)('@storybook/core-server', 'package.json')).version;
    return (0, semver_1.gte)(storybookPackageVersion, '7.0.0-alpha.0');
}
exports.isStorybookV7 = isStorybookV7;
function safeFileDelete(tree, path) {
    if (tree.exists(path)) {
        tree.delete(path);
        return true;
    }
    else {
        return false;
    }
}
exports.safeFileDelete = safeFileDelete;
function readCurrentWorkspaceStorybookVersionFromGenerator(tree) {
    const packageJsonContents = (0, devkit_1.readJson)(tree, 'package.json');
    return determineStorybookWorkspaceVersion(packageJsonContents);
}
exports.readCurrentWorkspaceStorybookVersionFromGenerator = readCurrentWorkspaceStorybookVersionFromGenerator;
function readCurrentWorkspaceStorybookVersionFromExecutor() {
    const packageJsonContents = (0, devkit_1.readJsonFile)('package.json');
    return determineStorybookWorkspaceVersion(packageJsonContents);
}
exports.readCurrentWorkspaceStorybookVersionFromExecutor = readCurrentWorkspaceStorybookVersionFromExecutor;
function determineStorybookWorkspaceVersion(packageJsonContents) {
    let workspaceStorybookVersion = versions_1.storybookVersion;
    if (packageJsonContents && packageJsonContents['devDependencies']) {
        if (packageJsonContents['devDependencies']['@storybook/angular']) {
            workspaceStorybookVersion =
                packageJsonContents['devDependencies']['@storybook/angular'];
        }
        if (packageJsonContents['devDependencies']['@storybook/react']) {
            workspaceStorybookVersion =
                packageJsonContents['devDependencies']['@storybook/react'];
        }
        if (packageJsonContents['devDependencies']['@storybook/core']) {
            workspaceStorybookVersion =
                packageJsonContents['devDependencies']['@storybook/core'];
        }
        if (packageJsonContents['devDependencies']['@storybook/react-native']) {
            workspaceStorybookVersion =
                packageJsonContents['devDependencies']['@storybook/react-native'];
        }
    }
    if (packageJsonContents && packageJsonContents['dependencies']) {
        if (packageJsonContents['dependencies']['@storybook/angular']) {
            workspaceStorybookVersion =
                packageJsonContents['dependencies']['@storybook/angular'];
        }
        if (packageJsonContents['dependencies']['@storybook/react']) {
            workspaceStorybookVersion =
                packageJsonContents['dependencies']['@storybook/react'];
        }
        if (packageJsonContents['dependencies']['@storybook/core']) {
            workspaceStorybookVersion =
                packageJsonContents['dependencies']['@storybook/core'];
        }
        if (packageJsonContents['dependencies']['@storybook/react-native']) {
            workspaceStorybookVersion =
                packageJsonContents['dependencies']['@storybook/react-native'];
        }
    }
    return workspaceStorybookVersion;
}
function storybookConfigExistsCheck(config, projectName) {
    const exists = !!(config && (0, fs_1.statSync)(config).isDirectory());
    if (!exists) {
        throw new Error(`Could not find Storybook configuration for project ${projectName}.
      Please generate Storybook configuration using the following command:

      nx g @nrwl/storybook:configuration --name=${projectName}
      `);
    }
}
exports.storybookConfigExistsCheck = storybookConfigExistsCheck;
function dedupe(arr) {
    return Array.from(new Set(arr));
}
exports.dedupe = dedupe;
function findStorybookAndBuildTargetsAndCompiler(targets) {
    var _a, _b, _c;
    const returnObject = {};
    const arrayOfBuilders = [
        '@nxext/vite:build',
        '@nrwl/js:babel',
        '@nrwl/js:swc',
        '@nrwl/js:tsc',
        '@nrwl/webpack:webpack',
        '@nrwl/rollup:rollup',
        '@nrwl/web:rollup',
        '@nrwl/vite:build',
        '@nrwl/angular:ng-packagr-lite',
        '@nrwl/angular:package',
        '@nrwl/angular:webpack-browser',
        '@angular-devkit/build-angular:browser',
        '@nrwl/esbuild:esbuild',
        '@nrwl/next:build',
        '@nrwl/react-native:bundle',
        '@nrwl/react-native:build-android',
        '@nrwl/react-native:bundle',
    ];
    for (const target in targets) {
        if (arrayOfBuilders.includes(targets[target].executor)) {
            if (targets[target].executor === '@angular-devkit/build-angular:browser') {
                /**
                 * Not looking for '@nrwl/angular:ng-packagr-lite' or any other
                 * @nrwl/angular:* executors.
                 * Only looking for '@angular-devkit/build-angular:browser'
                 * because the '@nrwl/angular:ng-packagr-lite' executor
                 * (and maybe the other custom executors)
                 * does not support styles and extra options, so the user
                 * will be forced to switch to build-storybook to add extra options.
                 *
                 * So we might as well use the build-storybook by default to
                 * avoid any errors.
                 */
                returnObject.ngBuildTarget = target;
            }
            else if (targets[target].executor.includes('vite')) {
                returnObject.viteBuildTarget = target;
            }
            else if (targets[target].executor.includes('next')) {
                returnObject.nextBuildTarget = target;
            }
            else {
                returnObject.otherBuildTarget = target;
            }
            returnObject.compiler = (_a = targets[target].options) === null || _a === void 0 ? void 0 : _a.compiler;
        }
        else if (targets[target].executor === '@storybook/angular:start-storybook' ||
            targets[target].executor === '@nrwl/storybook:storybook') {
            returnObject.storybookTarget = target;
        }
        else if (targets[target].executor === '@storybook/angular:build-storybook' ||
            targets[target].executor === '@nrwl/storybook:build') {
            returnObject.storybookBuildTarget = target;
        }
        else if ((_b = targets[target].options) === null || _b === void 0 ? void 0 : _b.compiler) {
            returnObject.otherBuildTarget = target;
            returnObject.compiler = (_c = targets[target].options) === null || _c === void 0 ? void 0 : _c.compiler;
        }
    }
    return returnObject;
}
exports.findStorybookAndBuildTargetsAndCompiler = findStorybookAndBuildTargetsAndCompiler;
function isTheFileAStory(tree, path) {
    const ext = path.slice(path.lastIndexOf('.'));
    let fileIsStory = false;
    if (ext === '.tsx' || ext === '.ts') {
        const file = getTsSourceFile(tree, path);
        const importArray = (0, typescript_1.findNodes)(file, [ts.SyntaxKind.ImportDeclaration]);
        let nodeContainsStorybookImport = false;
        let nodeContainsStoryImport = false;
        importArray.forEach((importNode) => {
            const importPath = (0, typescript_1.findNodes)(importNode, [ts.SyntaxKind.StringLiteral]);
            importPath.forEach((importPath) => {
                var _a;
                if ((_a = importPath.getText()) === null || _a === void 0 ? void 0 : _a.includes('@storybook/')) {
                    nodeContainsStorybookImport = true;
                }
            });
            const importSpecifiers = (0, typescript_1.findNodes)(importNode, [
                ts.SyntaxKind.ImportSpecifier,
            ]);
            importSpecifiers.forEach((importSpecifier) => {
                if (importSpecifier.getText() === 'Story' ||
                    importSpecifier.getText() === 'storiesOf' ||
                    importSpecifier.getText() === 'ComponentStory') {
                    nodeContainsStoryImport = true;
                }
            });
            // We place this check within the loop, because we want the
            // import combination of Story from @storybook/*
            if (nodeContainsStorybookImport && nodeContainsStoryImport) {
                fileIsStory = true;
            }
        });
    }
    else {
        fileIsStory =
            (path.endsWith('.js') && path.endsWith('.stories.js')) ||
                (path.endsWith('.jsx') && path.endsWith('.stories.jsx'));
    }
    return fileIsStory;
}
exports.isTheFileAStory = isTheFileAStory;
function getTsSourceFile(host, path) {
    const buffer = host.read(path);
    if (!buffer) {
        throw new Error(`Could not read TS file (${path}).`);
    }
    const content = buffer.toString();
    const source = ts.createSourceFile(path, content, ts.ScriptTarget.Latest, true);
    return source;
}
exports.getTsSourceFile = getTsSourceFile;
//# sourceMappingURL=utilities.js.map