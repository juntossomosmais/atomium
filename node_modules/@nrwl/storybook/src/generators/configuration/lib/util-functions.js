"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getViteConfigFilePath = exports.getE2EProjectName = exports.rootFileIsTs = exports.workspaceHasRootProject = exports.projectIsRootProjectInStandaloneWorkspace = exports.addBuildStorybookToCacheableOperations = exports.getTsConfigPath = exports.createProjectStorybookDir = exports.addStorybookToNamedInputs = exports.normalizeSchema = exports.updateLintConfig = exports.configureTsSolutionConfig = exports.configureTsProjectConfig = exports.addStaticTarget = exports.addAngularStorybookTask = exports.addStorybookTask = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const executor_options_utils_1 = require("@nrwl/devkit/src/generators/executor-options-utils");
const linter_1 = require("@nrwl/linter");
const path_1 = require("path");
const utilities_1 = require("../../../utils/utilities");
const versions_1 = require("../../../utils/versions");
const DEFAULT_PORT = 4400;
function addStorybookTask(tree, projectName, uiFramework, configureTestRunner, usesV7) {
    if (uiFramework === '@storybook/react-native') {
        return;
    }
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    projectConfig.targets['storybook'] = {
        executor: '@nrwl/storybook:storybook',
        options: {
            port: DEFAULT_PORT,
            configDir: `${projectConfig.root}/.storybook`,
        },
        configurations: {
            ci: {
                quiet: true,
            },
        },
    };
    projectConfig.targets['build-storybook'] = {
        executor: '@nrwl/storybook:build',
        outputs: ['{options.outputDir}'],
        options: {
            outputDir: (0, devkit_1.joinPathFragments)('dist/storybook', projectName),
            configDir: `${projectConfig.root}/.storybook`,
        },
        configurations: {
            ci: {
                quiet: true,
            },
        },
    };
    if (!usesV7) {
        projectConfig.targets['storybook'].options.uiFramework = uiFramework;
        projectConfig.targets['build-storybook'].options.uiFramework = uiFramework;
    }
    if (configureTestRunner === true) {
        projectConfig.targets['test-storybook'] = {
            executor: 'nx:run-commands',
            options: {
                command: `test-storybook -c ${projectConfig.root}/.storybook --url=http://localhost:${DEFAULT_PORT}`,
            },
        };
    }
    (0, devkit_1.updateProjectConfiguration)(tree, projectName, projectConfig);
}
exports.addStorybookTask = addStorybookTask;
function addAngularStorybookTask(tree, projectName, configureTestRunner) {
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    const { ngBuildTarget } = (0, utilities_1.findStorybookAndBuildTargetsAndCompiler)(projectConfig.targets);
    projectConfig.targets['storybook'] = {
        executor: '@storybook/angular:start-storybook',
        options: {
            port: 4400,
            configDir: `${projectConfig.root}/.storybook`,
            browserTarget: `${projectName}:${ngBuildTarget ? 'build' : 'build-storybook'}`,
            compodoc: false,
        },
        configurations: {
            ci: {
                quiet: true,
            },
        },
    };
    projectConfig.targets['build-storybook'] = {
        executor: '@storybook/angular:build-storybook',
        outputs: ['{options.outputDir}'],
        options: {
            outputDir: (0, devkit_1.joinPathFragments)('dist/storybook', projectName),
            configDir: `${projectConfig.root}/.storybook`,
            browserTarget: `${projectName}:${ngBuildTarget ? 'build' : 'build-storybook'}`,
            compodoc: false,
        },
        configurations: {
            ci: {
                quiet: true,
            },
        },
    };
    if (configureTestRunner === true) {
        projectConfig.targets['test-storybook'] = {
            executor: 'nx:run-commands',
            options: {
                command: `test-storybook -c ${projectConfig.root}/.storybook --url=http://localhost:${DEFAULT_PORT}`,
            },
        };
    }
    (0, devkit_1.updateProjectConfiguration)(tree, projectName, projectConfig);
}
exports.addAngularStorybookTask = addAngularStorybookTask;
function addStaticTarget(tree, opts) {
    const nrwlWeb = (0, devkit_1.ensurePackage)('@nrwl/web', versions_1.nxVersion);
    nrwlWeb.webStaticServeGenerator(tree, {
        buildTarget: `${opts.name}:build-storybook`,
        outputPath: (0, devkit_1.joinPathFragments)('dist/storybook', opts.name),
        targetName: 'static-storybook',
    });
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, opts.name);
    projectConfig.targets['static-storybook'].configurations = {
        ci: {
            buildTarget: `${opts.name}:build-storybook:ci`,
        },
    };
    (0, devkit_1.updateProjectConfiguration)(tree, opts.name, projectConfig);
}
exports.addStaticTarget = addStaticTarget;
function configureTsProjectConfig(tree, schema) {
    var _a, _b, _c;
    const { name: projectName } = schema;
    let tsConfigPath;
    let tsConfigContent;
    try {
        tsConfigPath = getTsConfigPath(tree, projectName);
        tsConfigContent = (0, devkit_1.readJson)(tree, tsConfigPath);
    }
    catch (_d) {
        /**
         * Custom app configurations
         * may contain a tsconfig.json
         * instead of a tsconfig.app.json.
         */
        tsConfigPath = getTsConfigPath(tree, projectName, 'tsconfig.json');
        tsConfigContent = (0, devkit_1.readJson)(tree, tsConfigPath);
    }
    if (!((_a = tsConfigContent === null || tsConfigContent === void 0 ? void 0 : tsConfigContent.exclude) === null || _a === void 0 ? void 0 : _a.includes('**/*.stories.ts')) &&
        !((_b = tsConfigContent === null || tsConfigContent === void 0 ? void 0 : tsConfigContent.exclude) === null || _b === void 0 ? void 0 : _b.includes('**/*.stories.js'))) {
        tsConfigContent.exclude = [
            ...(tsConfigContent.exclude || []),
            '**/*.stories.ts',
            '**/*.stories.js',
            ...(schema.uiFramework === '@storybook/react' ||
                schema.uiFramework === '@storybook/react-native' ||
                ((_c = schema.storybook7UiFramework) === null || _c === void 0 ? void 0 : _c.startsWith('@storybook/react'))
                ? ['**/*.stories.jsx', '**/*.stories.tsx']
                : []),
        ];
    }
    (0, devkit_1.writeJson)(tree, tsConfigPath, tsConfigContent);
}
exports.configureTsProjectConfig = configureTsProjectConfig;
function configureTsSolutionConfig(tree, schema) {
    var _a, _b;
    const { name: projectName } = schema;
    const { root } = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    const tsConfigPath = (0, path_1.join)(root, 'tsconfig.json');
    const tsConfigContent = (0, devkit_1.readJson)(tree, tsConfigPath);
    if (!((_b = (_a = tsConfigContent.references) === null || _a === void 0 ? void 0 : _a.map((reference) => reference.path)) === null || _b === void 0 ? void 0 : _b.includes('./.storybook/tsconfig.json'))) {
        tsConfigContent.references = [
            ...(tsConfigContent.references || []),
            {
                path: './.storybook/tsconfig.json',
            },
        ];
    }
    (0, devkit_1.writeJson)(tree, tsConfigPath, tsConfigContent);
}
exports.configureTsSolutionConfig = configureTsSolutionConfig;
/**
 * When adding storybook we need to inform TSLint or ESLint
 * of the additional tsconfig.json file which will be the only tsconfig
 * which includes *.stories files.
 *
 * For TSLint this is done via the builder config, for ESLint this is
 * done within the .eslintrc.json file.
 */
function updateLintConfig(tree, schema) {
    const { name: projectName } = schema;
    const { targets, root } = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    const tslintTargets = Object.values(targets).filter((target) => target.executor === '@angular-devkit/build-angular:tslint');
    tslintTargets.forEach((target) => {
        target.options.tsConfig = (0, utilities_1.dedupe)([
            ...target.options.tsConfig,
            (0, devkit_1.joinPathFragments)(root, './.storybook/tsconfig.json'),
        ]);
    });
    if (tree.exists((0, path_1.join)(root, '.eslintrc.json'))) {
        (0, devkit_1.updateJson)(tree, (0, path_1.join)(root, '.eslintrc.json'), (json) => {
            var _a, _b, _c, _d;
            if (typeof ((_a = json.parserOptions) === null || _a === void 0 ? void 0 : _a.project) === 'string') {
                json.parserOptions.project = [json.parserOptions.project];
            }
            if (Array.isArray((_b = json.parserOptions) === null || _b === void 0 ? void 0 : _b.project)) {
                json.parserOptions.project = (0, utilities_1.dedupe)([
                    ...json.parserOptions.project,
                    (0, path_1.join)(root, '.storybook/tsconfig.json'),
                ]);
            }
            const overrides = json.overrides || [];
            for (const o of overrides) {
                if (typeof ((_c = o.parserOptions) === null || _c === void 0 ? void 0 : _c.project) === 'string') {
                    o.parserOptions.project = [o.parserOptions.project];
                }
                if (Array.isArray((_d = o.parserOptions) === null || _d === void 0 ? void 0 : _d.project)) {
                    o.parserOptions.project = (0, utilities_1.dedupe)([
                        ...o.parserOptions.project,
                        (0, path_1.join)(root, '.storybook/tsconfig.json'),
                    ]);
                }
            }
            return json;
        });
    }
}
exports.updateLintConfig = updateLintConfig;
function normalizeSchema(schema) {
    const defaults = {
        configureCypress: true,
        linter: linter_1.Linter.EsLint,
        js: false,
    };
    return Object.assign(Object.assign({}, defaults), schema);
}
exports.normalizeSchema = normalizeSchema;
function addStorybookToNamedInputs(tree) {
    var _a, _b, _c, _d;
    var _e, _f;
    const nxJson = (0, devkit_1.readNxJson)(tree);
    if (nxJson.namedInputs) {
        const hasProductionFileset = !!((_a = nxJson.namedInputs) === null || _a === void 0 ? void 0 : _a.production);
        if (hasProductionFileset) {
            if (!nxJson.namedInputs.production.includes('!{projectRoot}/**/*.stories.@(js|jsx|ts|tsx|mdx)')) {
                nxJson.namedInputs.production.push('!{projectRoot}/**/*.stories.@(js|jsx|ts|tsx|mdx)');
            }
            if (!nxJson.namedInputs.production.includes('!{projectRoot}/.storybook/**/*')) {
                nxJson.namedInputs.production.push('!{projectRoot}/.storybook/**/*');
            }
        }
        (_b = nxJson.targetDefaults) !== null && _b !== void 0 ? _b : (nxJson.targetDefaults = {});
        (_c = (_e = nxJson.targetDefaults)['build-storybook']) !== null && _c !== void 0 ? _c : (_e['build-storybook'] = {});
        (_d = (_f = nxJson.targetDefaults['build-storybook']).inputs) !== null && _d !== void 0 ? _d : (_f.inputs = [
            'default',
            hasProductionFileset ? '^production' : '^default',
        ]);
        if (!nxJson.targetDefaults['build-storybook'].inputs.includes('!{projectRoot}/.storybook/**/*')) {
            nxJson.targetDefaults['build-storybook'].inputs.push('!{projectRoot}/.storybook/**/*');
        }
        (0, devkit_1.updateNxJson)(tree, nxJson);
    }
}
exports.addStorybookToNamedInputs = addStorybookToNamedInputs;
function createProjectStorybookDir(tree, projectName, uiFramework, js, tsConfiguration, root, projectType, projectIsRootProjectInStandaloneWorkspace, isNextJs, usesSwc, usesVite, usesV7, viteConfigFilePath) {
    const projectDirectory = projectType === 'application'
        ? isNextJs
            ? 'components'
            : 'src/app'
        : 'src/lib';
    const storybookConfigExists = projectIsRootProjectInStandaloneWorkspace
        ? tree.exists('.storybook/main.js') || tree.exists('.storybook/main.ts')
        : tree.exists((0, path_1.join)(root, '.storybook/main.ts')) ||
            tree.exists((0, path_1.join)(root, '.storybook/main.js'));
    if (storybookConfigExists) {
        devkit_1.logger.warn(`Storybook configuration files already exist for ${projectName}!`);
        return;
    }
    devkit_1.logger.debug(`adding .storybook folder to your ${projectType}`);
    const templatePath = (0, path_1.join)(__dirname, `../project-files${usesV7 ? '-7' : ''}${tsConfiguration ? '-ts' : ''}`);
    (0, devkit_1.generateFiles)(tree, templatePath, root, {
        tmpl: '',
        uiFramework,
        offsetFromRoot: (0, devkit_1.offsetFromRoot)(root),
        projectDirectory,
        projectType,
        mainDir: isNextJs && projectType === 'application' ? 'components' : 'src',
        isNextJs: isNextJs && projectType === 'application',
        usesSwc,
        usesVite,
        isRootProject: projectIsRootProjectInStandaloneWorkspace,
        viteConfigFilePath,
    });
    if (js) {
        (0, devkit_1.toJS)(tree);
    }
}
exports.createProjectStorybookDir = createProjectStorybookDir;
function getTsConfigPath(tree, projectName, path) {
    const { root, projectType } = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    return (0, path_1.join)(root, path && path.length > 0
        ? path
        : projectType === 'application'
            ? 'tsconfig.app.json'
            : 'tsconfig.lib.json');
}
exports.getTsConfigPath = getTsConfigPath;
function addBuildStorybookToCacheableOperations(tree) {
    (0, devkit_1.updateJson)(tree, 'nx.json', (json) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        return (Object.assign(Object.assign({}, json), { tasksRunnerOptions: Object.assign(Object.assign({}, ((_a = json.tasksRunnerOptions) !== null && _a !== void 0 ? _a : {})), { default: Object.assign(Object.assign({}, ((_c = (_b = json.tasksRunnerOptions) === null || _b === void 0 ? void 0 : _b.default) !== null && _c !== void 0 ? _c : {})), { options: Object.assign(Object.assign({}, ((_f = (_e = (_d = json.tasksRunnerOptions) === null || _d === void 0 ? void 0 : _d.default) === null || _e === void 0 ? void 0 : _e.options) !== null && _f !== void 0 ? _f : {})), { cacheableOperations: Array.from(new Set([
                            ...((_k = (_j = (_h = (_g = json.tasksRunnerOptions) === null || _g === void 0 ? void 0 : _g.default) === null || _h === void 0 ? void 0 : _h.options) === null || _j === void 0 ? void 0 : _j.cacheableOperations) !== null && _k !== void 0 ? _k : []),
                            'build-storybook',
                        ])) }) }) }) }));
    });
}
exports.addBuildStorybookToCacheableOperations = addBuildStorybookToCacheableOperations;
function projectIsRootProjectInStandaloneWorkspace(projectRoot) {
    return (0, path_1.relative)(devkit_1.workspaceRoot, projectRoot).length === 0;
}
exports.projectIsRootProjectInStandaloneWorkspace = projectIsRootProjectInStandaloneWorkspace;
function workspaceHasRootProject(tree) {
    return tree.exists('project.json');
}
exports.workspaceHasRootProject = workspaceHasRootProject;
function rootFileIsTs(tree, rootFileName, tsConfiguration) {
    if (tree.exists(`.storybook/${rootFileName}.ts`) && !tsConfiguration) {
        devkit_1.logger.info(`The root Storybook configuration is in TypeScript, 
      so Nx will generate TypeScript Storybook configuration files 
      in this project's .storybook folder as well.`);
        return true;
    }
    else if (tree.exists(`.storybook/${rootFileName}.js`) && tsConfiguration) {
        devkit_1.logger.info(`The root Storybook configuration is in JavaScript, 
        so Nx will generate JavaScript Storybook configuration files 
        in this project's .storybook folder as well.`);
        return false;
    }
    else {
        return tsConfiguration;
    }
}
exports.rootFileIsTs = rootFileIsTs;
function getE2EProjectName(tree, mainProject) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let e2eProject;
        const graph = yield (0, devkit_1.createProjectGraphAsync)();
        (0, executor_options_utils_1.forEachExecutorOptions)(tree, '@nrwl/cypress:cypress', (options, projectName) => {
            if (e2eProject) {
                return;
            }
            if (options['devServerTarget']) {
                const { project, target } = (0, devkit_1.parseTargetString)(options['devServerTarget'], graph);
                if ((project === mainProject && target === 'serve') ||
                    (project === mainProject && target === 'storybook')) {
                    e2eProject = projectName;
                }
            }
        });
        return e2eProject;
    });
}
exports.getE2EProjectName = getE2EProjectName;
function getViteConfigFilePath(tree, projectRoot, configFile) {
    return configFile && tree.exists(configFile)
        ? configFile
        : tree.exists((0, devkit_1.joinPathFragments)(`${projectRoot}/vite.config.ts`))
            ? (0, devkit_1.joinPathFragments)(`${projectRoot}/vite.config.ts`)
            : tree.exists((0, devkit_1.joinPathFragments)(`${projectRoot}/vite.config.js`))
                ? (0, devkit_1.joinPathFragments)(`${projectRoot}/vite.config.js`)
                : undefined;
}
exports.getViteConfigFilePath = getViteConfigFilePath;
//# sourceMappingURL=util-functions.js.map