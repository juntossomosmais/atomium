"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateWorkspaceFiles = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const versions_1 = require("../../utils/versions");
const path_1 = require("path");
const presets_1 = require("../utils/presets");
const default_base_1 = require("../../utilities/default-base");
function generateWorkspaceFiles(tree, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!options.name) {
            throw new Error(`Invalid options, "name" is required.`);
        }
        options = normalizeOptions(options);
        createReadme(tree, options);
        createFiles(tree, options);
        createNxJson(tree, options);
        const [packageMajor] = (0, devkit_1.getPackageManagerVersion)(options.packageManager).split('.');
        if (options.packageManager === 'pnpm' && +packageMajor >= 7) {
            createNpmrc(tree, options);
        }
        else if (options.packageManager === 'yarn' && +packageMajor >= 2) {
            createYarnrcYml(tree, options);
        }
        setPresetProperty(tree, options);
        addNpmScripts(tree, options);
        createAppsAndLibsFolders(tree, options);
        setUpWorkspacesInPackageJson(tree, options);
        yield (0, devkit_1.formatFiles)(tree);
    });
}
exports.generateWorkspaceFiles = generateWorkspaceFiles;
function setPresetProperty(tree, options) {
    (0, devkit_1.updateJson)(tree, (0, path_1.join)(options.directory, 'nx.json'), (json) => {
        if (options.preset === presets_1.Preset.Core || options.preset === presets_1.Preset.NPM) {
            addPropertyWithStableKeys(json, 'extends', 'nx/presets/npm.json');
            delete json.implicitDependencies;
            delete json.targetDefaults;
            delete json.targetDependencies;
            delete json.workspaceLayout;
            delete json.npmScope;
        }
        return json;
    });
}
function createAppsAndLibsFolders(tree, options) {
    if (options.preset === presets_1.Preset.Core ||
        options.preset === presets_1.Preset.TS ||
        options.preset === presets_1.Preset.NPM) {
        tree.write((0, path_1.join)(options.directory, 'packages/.gitkeep'), '');
    }
    else if (options.preset === presets_1.Preset.AngularStandalone ||
        options.preset === presets_1.Preset.ReactStandalone ||
        options.preset === presets_1.Preset.NodeStandalone ||
        options.isCustomPreset) {
        // don't generate any folders
    }
    else {
        tree.write((0, path_1.join)(options.directory, 'apps/.gitkeep'), '');
        tree.write((0, path_1.join)(options.directory, 'libs/.gitkeep'), '');
    }
}
function createNxJson(tree, { directory, npmScope, packageManager, defaultBase, preset }) {
    const nxJson = {
        $schema: './node_modules/nx/schemas/nx-schema.json',
        npmScope: npmScope,
        affected: {
            defaultBase,
        },
        tasksRunnerOptions: {
            default: {
                runner: 'nx/tasks-runners/default',
                options: {
                    cacheableOperations: ['build', 'lint', 'test', 'e2e'],
                },
            },
        },
    };
    nxJson.targetDefaults = {
        build: {
            dependsOn: ['^build'],
        },
    };
    if (defaultBase === 'main') {
        delete nxJson.affected;
    }
    if (preset !== presets_1.Preset.Core &&
        preset !== presets_1.Preset.NPM &&
        preset !== presets_1.Preset.Empty) {
        nxJson.namedInputs = {
            default: ['{projectRoot}/**/*', 'sharedGlobals'],
            production: ['default'],
            sharedGlobals: [],
        };
        nxJson.targetDefaults.build.inputs = ['production', '^production'];
    }
    (0, devkit_1.writeJson)(tree, (0, path_1.join)(directory, 'nx.json'), nxJson);
}
function createFiles(tree, options) {
    const formattedNames = (0, devkit_1.names)(options.name);
    const filesDirName = options.preset === presets_1.Preset.AngularStandalone ||
        options.preset === presets_1.Preset.ReactStandalone ||
        options.preset === presets_1.Preset.NodeStandalone
        ? './files-root-app'
        : options.preset === presets_1.Preset.NPM || options.preset === presets_1.Preset.Core
            ? './files-package-based-repo'
            : './files-integrated-repo';
    (0, devkit_1.generateFiles)(tree, (0, path_1.join)(__dirname, filesDirName), options.directory, Object.assign(Object.assign({ formattedNames, dot: '.', tmpl: '', cliCommand: 'nx', nxCli: false }, options), { nxVersion: versions_1.nxVersion, packageManager: options.packageManager }));
}
function createReadme(tree, { name, appName, directory }) {
    const formattedNames = (0, devkit_1.names)(name);
    (0, devkit_1.generateFiles)(tree, (0, path_1.join)(__dirname, './files-readme'), directory, {
        formattedNames,
        appName,
        name,
    });
}
// ensure that pnpm install add all the missing peer deps
function createNpmrc(tree, options) {
    tree.write((0, path_1.join)(options.directory, '.npmrc'), 'strict-peer-dependencies=false\nauto-install-peers=true\n');
}
// ensure that yarn (berry) install uses classic node linker
function createYarnrcYml(tree, options) {
    tree.write((0, path_1.join)(options.directory, '.yarnrc.yml'), 'nodeLinker: node-modules\n');
}
function addNpmScripts(tree, options) {
    if (options.preset === presets_1.Preset.AngularStandalone ||
        options.preset === presets_1.Preset.ReactStandalone ||
        options.preset === presets_1.Preset.NodeStandalone) {
        (0, devkit_1.updateJson)(tree, (0, path_1.join)(options.directory, 'package.json'), (json) => {
            Object.assign(json.scripts, {
                start: 'nx serve',
                build: 'nx build',
                test: 'nx test',
            });
            return json;
        });
    }
}
function addPropertyWithStableKeys(obj, key, value) {
    const copy = Object.assign({}, obj);
    Object.keys(obj).forEach((k) => {
        delete obj[k];
    });
    obj[key] = value;
    Object.keys(copy).forEach((k) => {
        obj[k] = copy[k];
    });
}
function normalizeOptions(options) {
    let defaultBase = options.defaultBase || (0, default_base_1.deduceDefaultBase)();
    return Object.assign(Object.assign({ npmScope: options.name }, options), { defaultBase });
}
function setUpWorkspacesInPackageJson(tree, options) {
    if (options.preset === presets_1.Preset.NPM || options.preset === presets_1.Preset.Core) {
        if (options.packageManager === 'pnpm') {
            tree.write((0, path_1.join)(options.directory, 'pnpm-workspace.yaml'), `packages:
  - 'packages/*'
`);
        }
        else {
            (0, devkit_1.updateJson)(tree, (0, path_1.join)(options.directory, 'package.json'), (json) => {
                json.workspaces = ['packages/*'];
                return json;
            });
        }
    }
}
//# sourceMappingURL=generate-workspace-files.js.map