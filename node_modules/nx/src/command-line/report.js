"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findInstalledPackagesWeCareAbout = exports.findInstalledCommunityPlugins = exports.findMisalignedPackagesForPackage = exports.getReportData = exports.reportHandler = exports.patternsWeIgnoreInCommunityReport = exports.packagesWeCareAbout = void 0;
const tslib_1 = require("tslib");
const chalk = require("chalk");
const workspace_root_1 = require("../utils/workspace-root");
const output_1 = require("../utils/output");
const path_1 = require("path");
const package_manager_1 = require("../utils/package-manager");
const fileutils_1 = require("../utils/fileutils");
const package_json_1 = require("../utils/package-json");
const local_plugins_1 = require("../utils/plugins/local-plugins");
const project_graph_1 = require("../project-graph/project-graph");
const semver_1 = require("semver");
const nxPackageJson = (0, fileutils_1.readJsonFile)((0, path_1.join)(__dirname, '../../package.json'));
exports.packagesWeCareAbout = [
    'nx',
    'lerna',
    ...nxPackageJson['nx-migrations'].packageGroup.map((x) => typeof x === 'string' ? x : x.package),
    '@nrwl/schematics',
    'typescript',
];
exports.patternsWeIgnoreInCommunityReport = [
    ...exports.packagesWeCareAbout,
    '@schematics/angular',
    new RegExp('@angular/*'),
    '@nestjs/schematics',
];
const LINE_SEPARATOR = '---------------------------------------';
/**
 * Reports relevant version numbers for adding to an Nx issue report
 *
 * @remarks
 *
 * Must be run within an Nx workspace
 *
 */
function reportHandler() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { pm, pmVersion, localPlugins, communityPlugins, packageVersionsWeCareAbout, outOfSyncPackageGroup, projectGraphError, } = yield getReportData();
        const bodyLines = [
            `Node : ${process.versions.node}`,
            `OS   : ${process.platform} ${process.arch}`,
            `${pm.padEnd(5)}: ${pmVersion}`,
            ``,
        ];
        let padding = Math.max(...packageVersionsWeCareAbout.map((x) => x.package.length)) + 1;
        packageVersionsWeCareAbout.forEach((p) => {
            bodyLines.push(`${chalk.green(p.package.padEnd(padding))} : ${chalk.bold(p.version)}`);
        });
        if (communityPlugins.length) {
            bodyLines.push(LINE_SEPARATOR);
            padding = Math.max(...communityPlugins.map((x) => x.package.length)) + 1;
            bodyLines.push('Community plugins:');
            communityPlugins.forEach((p) => {
                bodyLines.push(`${chalk.green(p.package.padEnd(padding))}: ${chalk.bold(p.version)}`);
            });
        }
        if (localPlugins.length) {
            bodyLines.push(LINE_SEPARATOR);
            bodyLines.push('Local workspace plugins:');
            for (const plugin of localPlugins) {
                bodyLines.push(`\t ${chalk.green(plugin)}`);
            }
        }
        if (outOfSyncPackageGroup) {
            bodyLines.push(LINE_SEPARATOR);
            bodyLines.push(`The following packages should match the installed version of ${outOfSyncPackageGroup.basePackage}`);
            for (const pkg of outOfSyncPackageGroup.misalignedPackages) {
                bodyLines.push(`  - ${pkg.name}@${pkg.version}`);
            }
            bodyLines.push('');
            bodyLines.push(`To fix this, run \`nx migrate ${outOfSyncPackageGroup.migrateTarget}\``);
        }
        if (projectGraphError) {
            bodyLines.push(LINE_SEPARATOR);
            bodyLines.push('⚠️ Unable to construct project graph.');
            bodyLines.push(projectGraphError.message);
            bodyLines.push(projectGraphError.stack);
        }
        output_1.output.log({
            title: 'Report complete - copy this into the issue template',
            bodyLines,
        });
    });
}
exports.reportHandler = reportHandler;
function getReportData() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const pm = (0, package_manager_1.detectPackageManager)();
        const pmVersion = (0, package_manager_1.getPackageManagerVersion)(pm);
        const localPlugins = yield findLocalPlugins();
        const communityPlugins = findInstalledCommunityPlugins();
        let projectGraphError = null;
        try {
            yield (0, project_graph_1.createProjectGraphAsync)();
        }
        catch (e) {
            projectGraphError = e;
        }
        const packageVersionsWeCareAbout = findInstalledPackagesWeCareAbout();
        const outOfSyncPackageGroup = findMisalignedPackagesForPackage(nxPackageJson);
        return {
            pm,
            pmVersion,
            localPlugins,
            communityPlugins,
            packageVersionsWeCareAbout,
            outOfSyncPackageGroup,
            projectGraphError,
        };
    });
}
exports.getReportData = getReportData;
function findLocalPlugins() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const projectGraph = yield (0, project_graph_1.createProjectGraphAsync)({ exitOnError: true });
            return Array.from((0, local_plugins_1.getLocalWorkspacePlugins)((0, project_graph_1.readProjectsConfigurationFromProjectGraph)(projectGraph)).keys());
        }
        catch (_a) {
            return [];
        }
    });
}
function readPackageJson(p) {
    try {
        return (0, package_json_1.readModulePackageJson)(p).packageJson;
    }
    catch (_a) {
        return null;
    }
}
function readPackageVersion(p) {
    var _a;
    return (_a = readPackageJson(p)) === null || _a === void 0 ? void 0 : _a.version;
}
function findMisalignedPackagesForPackage(base) {
    const misalignedPackages = [];
    let migrateTarget = base.version;
    const { packageGroup } = (0, package_json_1.readNxMigrateConfig)(base);
    for (const entry of packageGroup !== null && packageGroup !== void 0 ? packageGroup : []) {
        const { package: packageName, version } = entry;
        // should be aligned
        if (version === '*') {
            const installedVersion = readPackageVersion(packageName);
            if (installedVersion && installedVersion !== base.version) {
                if ((0, semver_1.valid)(installedVersion) && (0, semver_1.gt)(installedVersion, migrateTarget)) {
                    migrateTarget = installedVersion;
                }
                misalignedPackages.push({
                    name: packageName,
                    version: installedVersion,
                });
            }
        }
    }
    return misalignedPackages.length
        ? {
            basePackage: base.name,
            misalignedPackages,
            migrateTarget: `${base.name}@${migrateTarget}`,
        }
        : undefined;
}
exports.findMisalignedPackagesForPackage = findMisalignedPackagesForPackage;
function findInstalledCommunityPlugins() {
    const { dependencies, devDependencies } = (0, fileutils_1.readJsonFile)((0, path_1.join)(workspace_root_1.workspaceRoot, 'package.json'));
    const deps = [
        Object.keys(dependencies || {}),
        Object.keys(devDependencies || {}),
    ].flat();
    return deps.reduce((arr, nextDep) => {
        if (exports.patternsWeIgnoreInCommunityReport.some((pattern) => typeof pattern === 'string'
            ? pattern === nextDep
            : pattern.test(nextDep))) {
            return arr;
        }
        try {
            const depPackageJson = readPackageJson(nextDep) || {};
            if ([
                'ng-update',
                'nx-migrations',
                'schematics',
                'generators',
                'builders',
                'executors',
            ].some((field) => field in depPackageJson)) {
                arr.push(Object.assign({ package: nextDep }, depPackageJson));
                return arr;
            }
            else {
                return arr;
            }
        }
        catch (_a) {
            console.warn(`Error parsing packageJson for ${nextDep}`);
            return arr;
        }
    }, []);
}
exports.findInstalledCommunityPlugins = findInstalledCommunityPlugins;
function findInstalledPackagesWeCareAbout() {
    return exports.packagesWeCareAbout.reduce((acc, next) => {
        const v = readPackageVersion(next);
        if (v) {
            acc.push({ package: next, version: v });
        }
        return acc;
    }, []);
}
exports.findInstalledPackagesWeCareAbout = findInstalledPackagesWeCareAbout;
//# sourceMappingURL=report.js.map