{"file":"ion-reorder-group.entry.js","mappings":"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","names":[],"sources":["../../node_modules/@ionic/core/dist/collection/components/reorder-group/reorder-group.css?tag=ion-reorder-group","../../node_modules/@ionic/core/dist/collection/components/reorder-group/reorder-group.js"],"sourcesContent":[".reorder-list-active > * {\n  display: block;\n  transition: transform 300ms;\n  will-change: transform;\n}\n\n.reorder-enabled {\n  user-select: none;\n}\n\n.reorder-enabled ion-reorder {\n  display: block;\n  cursor: grab;\n  pointer-events: all;\n  touch-action: none;\n}\n\n.reorder-selected,\n.reorder-selected ion-reorder {\n  cursor: grabbing;\n}\n\n.reorder-selected {\n  position: relative;\n  /* stylelint-disable-next-line declaration-no-important */\n  transition: none !important;\n  box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);\n  opacity: 0.8;\n  z-index: 100;\n}\n\n.reorder-visible ion-reorder .reorder-icon {\n  transform: translate3d(0,  0,  0);\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, h } from '@stencil/core';\nimport { getIonMode } from '../../global/ionic-global';\nimport { findClosestIonContent, getScrollElement } from '../../utils/content';\nimport { raf } from '../../utils/helpers';\nimport { hapticSelectionChanged, hapticSelectionEnd, hapticSelectionStart } from '../../utils/native/haptic';\nexport class ReorderGroup {\n  constructor() {\n    this.lastToIndex = -1;\n    this.cachedHeights = [];\n    this.scrollElTop = 0;\n    this.scrollElBottom = 0;\n    this.scrollElInitial = 0;\n    this.containerTop = 0;\n    this.containerBottom = 0;\n    this.state = 0 /* ReorderGroupState.Idle */;\n    this.disabled = true;\n  }\n  disabledChanged() {\n    if (this.gesture) {\n      this.gesture.enable(!this.disabled);\n    }\n  }\n  async connectedCallback() {\n    const contentEl = findClosestIonContent(this.el);\n    if (contentEl) {\n      this.scrollEl = await getScrollElement(contentEl);\n    }\n    this.gesture = (await import('../../utils/gesture')).createGesture({\n      el: this.el,\n      gestureName: 'reorder',\n      gesturePriority: 110,\n      threshold: 0,\n      direction: 'y',\n      passive: false,\n      canStart: (detail) => this.canStart(detail),\n      onStart: (ev) => this.onStart(ev),\n      onMove: (ev) => this.onMove(ev),\n      onEnd: () => this.onEnd(),\n    });\n    this.disabledChanged();\n  }\n  disconnectedCallback() {\n    this.onEnd();\n    if (this.gesture) {\n      this.gesture.destroy();\n      this.gesture = undefined;\n    }\n  }\n  /**\n   * Completes the reorder operation. Must be called by the `ionItemReorder` event.\n   *\n   * If a list of items is passed, the list will be reordered and returned in the\n   * proper order.\n   *\n   * If no parameters are passed or if `true` is passed in, the reorder will complete\n   * and the item will remain in the position it was dragged to. If `false` is passed,\n   * the reorder will complete and the item will bounce back to its original position.\n   *\n   * @param listOrReorder A list of items to be sorted and returned in the new order or a\n   * boolean of whether or not the reorder should reposition the item.\n   */\n  complete(listOrReorder) {\n    return Promise.resolve(this.completeReorder(listOrReorder));\n  }\n  canStart(ev) {\n    if (this.selectedItemEl || this.state !== 0 /* ReorderGroupState.Idle */) {\n      return false;\n    }\n    const target = ev.event.target;\n    const reorderEl = target.closest('ion-reorder');\n    if (!reorderEl) {\n      return false;\n    }\n    const item = findReorderItem(reorderEl, this.el);\n    if (!item) {\n      return false;\n    }\n    ev.data = item;\n    return true;\n  }\n  onStart(ev) {\n    ev.event.preventDefault();\n    const item = (this.selectedItemEl = ev.data);\n    const heights = this.cachedHeights;\n    heights.length = 0;\n    const el = this.el;\n    const children = el.children;\n    if (!children || children.length === 0) {\n      return;\n    }\n    let sum = 0;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      sum += child.offsetHeight;\n      heights.push(sum);\n      child.$ionIndex = i;\n    }\n    const box = el.getBoundingClientRect();\n    this.containerTop = box.top;\n    this.containerBottom = box.bottom;\n    if (this.scrollEl) {\n      const scrollBox = this.scrollEl.getBoundingClientRect();\n      this.scrollElInitial = this.scrollEl.scrollTop;\n      this.scrollElTop = scrollBox.top + AUTO_SCROLL_MARGIN;\n      this.scrollElBottom = scrollBox.bottom - AUTO_SCROLL_MARGIN;\n    }\n    else {\n      this.scrollElInitial = 0;\n      this.scrollElTop = 0;\n      this.scrollElBottom = 0;\n    }\n    this.lastToIndex = indexForItem(item);\n    this.selectedItemHeight = item.offsetHeight;\n    this.state = 1 /* ReorderGroupState.Active */;\n    item.classList.add(ITEM_REORDER_SELECTED);\n    hapticSelectionStart();\n  }\n  onMove(ev) {\n    const selectedItem = this.selectedItemEl;\n    if (!selectedItem) {\n      return;\n    }\n    // Scroll if we reach the scroll margins\n    const scroll = this.autoscroll(ev.currentY);\n    // // Get coordinate\n    const top = this.containerTop - scroll;\n    const bottom = this.containerBottom - scroll;\n    const currentY = Math.max(top, Math.min(ev.currentY, bottom));\n    const deltaY = scroll + currentY - ev.startY;\n    const normalizedY = currentY - top;\n    const toIndex = this.itemIndexForTop(normalizedY);\n    if (toIndex !== this.lastToIndex) {\n      const fromIndex = indexForItem(selectedItem);\n      this.lastToIndex = toIndex;\n      hapticSelectionChanged();\n      this.reorderMove(fromIndex, toIndex);\n    }\n    // Update selected item position\n    selectedItem.style.transform = `translateY(${deltaY}px)`;\n  }\n  onEnd() {\n    const selectedItemEl = this.selectedItemEl;\n    this.state = 2 /* ReorderGroupState.Complete */;\n    if (!selectedItemEl) {\n      this.state = 0 /* ReorderGroupState.Idle */;\n      return;\n    }\n    const toIndex = this.lastToIndex;\n    const fromIndex = indexForItem(selectedItemEl);\n    if (toIndex === fromIndex) {\n      this.completeReorder();\n    }\n    else {\n      this.ionItemReorder.emit({\n        from: fromIndex,\n        to: toIndex,\n        complete: this.completeReorder.bind(this),\n      });\n    }\n    hapticSelectionEnd();\n  }\n  completeReorder(listOrReorder) {\n    const selectedItemEl = this.selectedItemEl;\n    if (selectedItemEl && this.state === 2 /* ReorderGroupState.Complete */) {\n      const children = this.el.children;\n      const len = children.length;\n      const toIndex = this.lastToIndex;\n      const fromIndex = indexForItem(selectedItemEl);\n      /**\n       * insertBefore and setting the transform\n       * needs to happen in the same frame otherwise\n       * there will be a duplicate transition. This primarily\n       * impacts Firefox where insertBefore and transform operations\n       * are happening in two separate frames.\n       */\n      raf(() => {\n        if (toIndex !== fromIndex && (listOrReorder === undefined || listOrReorder === true)) {\n          const ref = fromIndex < toIndex ? children[toIndex + 1] : children[toIndex];\n          this.el.insertBefore(selectedItemEl, ref);\n        }\n        for (let i = 0; i < len; i++) {\n          children[i].style['transform'] = '';\n        }\n      });\n      if (Array.isArray(listOrReorder)) {\n        listOrReorder = reorderArray(listOrReorder, fromIndex, toIndex);\n      }\n      selectedItemEl.style.transition = '';\n      selectedItemEl.classList.remove(ITEM_REORDER_SELECTED);\n      this.selectedItemEl = undefined;\n      this.state = 0 /* ReorderGroupState.Idle */;\n    }\n    return listOrReorder;\n  }\n  itemIndexForTop(deltaY) {\n    const heights = this.cachedHeights;\n    for (let i = 0; i < heights.length; i++) {\n      if (heights[i] > deltaY) {\n        return i;\n      }\n    }\n    return heights.length - 1;\n  }\n  /********* DOM WRITE ********* */\n  reorderMove(fromIndex, toIndex) {\n    const itemHeight = this.selectedItemHeight;\n    const children = this.el.children;\n    for (let i = 0; i < children.length; i++) {\n      const style = children[i].style;\n      let value = '';\n      if (i > fromIndex && i <= toIndex) {\n        value = `translateY(${-itemHeight}px)`;\n      }\n      else if (i < fromIndex && i >= toIndex) {\n        value = `translateY(${itemHeight}px)`;\n      }\n      style['transform'] = value;\n    }\n  }\n  autoscroll(posY) {\n    if (!this.scrollEl) {\n      return 0;\n    }\n    let amount = 0;\n    if (posY < this.scrollElTop) {\n      amount = -SCROLL_JUMP;\n    }\n    else if (posY > this.scrollElBottom) {\n      amount = SCROLL_JUMP;\n    }\n    if (amount !== 0) {\n      this.scrollEl.scrollBy(0, amount);\n    }\n    return this.scrollEl.scrollTop - this.scrollElInitial;\n  }\n  render() {\n    const mode = getIonMode(this);\n    return (h(Host, { class: {\n        [mode]: true,\n        'reorder-enabled': !this.disabled,\n        'reorder-list-active': this.state !== 0 /* ReorderGroupState.Idle */,\n      } }));\n  }\n  static get is() { return \"ion-reorder-group\"; }\n  static get originalStyleUrls() {\n    return {\n      \"$\": [\"reorder-group.scss\"]\n    };\n  }\n  static get styleUrls() {\n    return {\n      \"$\": [\"reorder-group.css\"]\n    };\n  }\n  static get properties() {\n    return {\n      \"disabled\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, the reorder will be hidden.\"\n        },\n        \"attribute\": \"disabled\",\n        \"reflect\": false,\n        \"defaultValue\": \"true\"\n      }\n    };\n  }\n  static get states() {\n    return {\n      \"state\": {}\n    };\n  }\n  static get events() {\n    return [{\n        \"method\": \"ionItemReorder\",\n        \"name\": \"ionItemReorder\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Event that needs to be listened to in order to complete the reorder action.\\nOnce the event has been emitted, the `complete()` method then needs\\nto be called in order to finalize the reorder action.\"\n        },\n        \"complexType\": {\n          \"original\": \"ItemReorderEventDetail\",\n          \"resolved\": \"ItemReorderEventDetail\",\n          \"references\": {\n            \"ItemReorderEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"./reorder-group-interface\"\n            }\n          }\n        }\n      }];\n  }\n  static get methods() {\n    return {\n      \"complete\": {\n        \"complexType\": {\n          \"signature\": \"(listOrReorder?: boolean | any[]) => Promise<any>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"listOrReorder A list of items to be sorted and returned in the new order or a\\nboolean of whether or not the reorder should reposition the item.\"\n                }],\n              \"text\": \"A list of items to be sorted and returned in the new order or a\\nboolean of whether or not the reorder should reposition the item.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<any>\"\n        },\n        \"docs\": {\n          \"text\": \"Completes the reorder operation. Must be called by the `ionItemReorder` event.\\n\\nIf a list of items is passed, the list will be reordered and returned in the\\nproper order.\\n\\nIf no parameters are passed or if `true` is passed in, the reorder will complete\\nand the item will remain in the position it was dragged to. If `false` is passed,\\nthe reorder will complete and the item will bounce back to its original position.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"listOrReorder A list of items to be sorted and returned in the new order or a\\nboolean of whether or not the reorder should reposition the item.\"\n            }]\n        }\n      }\n    };\n  }\n  static get elementRef() { return \"el\"; }\n  static get watchers() {\n    return [{\n        \"propName\": \"disabled\",\n        \"methodName\": \"disabledChanged\"\n      }];\n  }\n}\nconst indexForItem = (element) => {\n  return element['$ionIndex'];\n};\nconst findReorderItem = (node, container) => {\n  let parent;\n  while (node) {\n    parent = node.parentElement;\n    if (parent === container) {\n      return node;\n    }\n    node = parent;\n  }\n  return undefined;\n};\nconst AUTO_SCROLL_MARGIN = 60;\nconst SCROLL_JUMP = 10;\nconst ITEM_REORDER_SELECTED = 'reorder-selected';\nconst reorderArray = (array, from, to) => {\n  const element = array[from];\n  array.splice(from, 1);\n  array.splice(to, 0, element);\n  return array.slice();\n};\n"],"version":3}