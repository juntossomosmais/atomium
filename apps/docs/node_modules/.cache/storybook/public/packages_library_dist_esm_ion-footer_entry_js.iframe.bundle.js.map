{"version":3,"file":"packages_library_dist_esm_ion-footer_entry_js.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7HA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChCA;ACAA;ACWA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA","sources":["webpack://atomium-docs/../../node_modules/@ionic/core/dist/collection/utils/logging/index.js","webpack://atomium-docs/../../node_modules/@ionic/core/dist/collection/utils/window/index.js","webpack://atomium-docs/../../node_modules/@ionic/core/dist/collection/utils/content/index.js","webpack://atomium-docs/../../node_modules/@ionic/core/dist/collection/components/footer/footer.utils.js","webpack://atomium-docs/../../node_modules/@ionic/core/dist/collection/components/footer/footer.ios.css","webpack://atomium-docs/../../node_modules/@ionic/core/dist/collection/components/footer/footer.md.css","webpack://atomium-docs/../../node_modules/@ionic/core/dist/collection/components/footer/footer.js","webpack://atomium-docs/../../node_modules/@ionic/core/dist/collection/utils/keyboard/keyboard-controller.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n/**\n * Logs a warning to the console with an Ionic prefix\n * to indicate the library that is warning the developer.\n *\n * @param message - The string message to be logged to the console.\n */\nexport const printIonWarning = (message, ...params) => {\n  return console.warn(`[Ionic Warning]: ${message}`, ...params);\n};\n/*\n * Logs an error to the console with an Ionic prefix\n * to indicate the library that is warning the developer.\n *\n * @param message - The string message to be logged to the console.\n * @param params - Additional arguments to supply to the console.error.\n */\nexport const printIonError = (message, ...params) => {\n  return console.error(`[Ionic Error]: ${message}`, ...params);\n};\n/**\n * Prints an error informing developers that an implementation requires an element to be used\n * within a specific selector.\n *\n * @param el The web component element this is requiring the element.\n * @param targetSelectors The selector or selectors that were not found.\n */\nexport const printRequiredElementError = (el, ...targetSelectors) => {\n  return console.error(`<${el.tagName.toLowerCase()}> must be used inside ${targetSelectors.join(' or ')}.`);\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n/**\n * When accessing the window, it is important\n * to account for SSR applications where the\n * window is not available. Code that accesses\n * window when it is not available will crash.\n * Even checking if `window === undefined` will cause\n * apps to crash in SSR.\n *\n * Use win below to access an SSR-safe version\n * of the window.\n *\n * Example 1:\n * Before:\n * if (window.innerWidth > 768) { ... }\n *\n * After:\n * import { win } from 'path/to/this/file';\n * if (win?.innerWidth > 768) { ... }\n *\n * Note: Code inside of this if-block will\n * not run in an SSR environment.\n */\nexport const win = typeof window !== 'undefined' ? window : undefined;\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { componentOnReady } from '../helpers';\nimport { printRequiredElementError } from '../logging';\nconst ION_CONTENT_TAG_NAME = 'ION-CONTENT';\nexport const ION_CONTENT_ELEMENT_SELECTOR = 'ion-content';\nexport const ION_CONTENT_CLASS_SELECTOR = '.ion-content-scroll-host';\n/**\n * Selector used for implementations reliant on `<ion-content>` for scroll event changes.\n *\n * Developers should use the `.ion-content-scroll-host` selector to target the element emitting\n * scroll events. With virtual scroll implementations this will be the host element for\n * the scroll viewport.\n */\nconst ION_CONTENT_SELECTOR = `${ION_CONTENT_ELEMENT_SELECTOR}, ${ION_CONTENT_CLASS_SELECTOR}`;\nexport const isIonContent = (el) => el.tagName === ION_CONTENT_TAG_NAME;\n/**\n * Waits for the element host fully initialize before\n * returning the inner scroll element.\n *\n * For `ion-content` the scroll target will be the result\n * of the `getScrollElement` function.\n *\n * For custom implementations it will be the element host\n * or a selector within the host, if supplied through `scrollTarget`.\n */\nexport const getScrollElement = async (el) => {\n  if (isIonContent(el)) {\n    await new Promise((resolve) => componentOnReady(el, resolve));\n    return el.getScrollElement();\n  }\n  return el;\n};\n/**\n * Queries the element matching the selector for IonContent.\n * See ION_CONTENT_SELECTOR for the selector used.\n */\nexport const findIonContent = (el) => {\n  /**\n   * First we try to query the custom scroll host selector in cases where\n   * the implementation is using an outer `ion-content` with an inner custom\n   * scroll container.\n   */\n  const customContentHost = el.querySelector(ION_CONTENT_CLASS_SELECTOR);\n  if (customContentHost) {\n    return customContentHost;\n  }\n  return el.querySelector(ION_CONTENT_SELECTOR);\n};\n/**\n * Queries the closest element matching the selector for IonContent.\n */\nexport const findClosestIonContent = (el) => {\n  return el.closest(ION_CONTENT_SELECTOR);\n};\n/**\n * Scrolls to the top of the element. If an `ion-content` is found, it will scroll\n * using the public API `scrollToTop` with a duration.\n */\n// TODO(FW-2832): type\nexport const scrollToTop = (el, durationMs) => {\n  if (isIonContent(el)) {\n    const content = el;\n    return content.scrollToTop(durationMs);\n  }\n  return Promise.resolve(el.scrollTo({\n    top: 0,\n    left: 0,\n    behavior: durationMs > 0 ? 'smooth' : 'auto',\n  }));\n};\n/**\n * Scrolls by a specified X/Y distance in the component. If an `ion-content` is found, it will scroll\n * using the public API `scrollByPoint` with a duration.\n */\nexport const scrollByPoint = (el, x, y, durationMs) => {\n  if (isIonContent(el)) {\n    const content = el;\n    return content.scrollByPoint(x, y, durationMs);\n  }\n  return Promise.resolve(el.scrollBy({\n    top: y,\n    left: x,\n    behavior: durationMs > 0 ? 'smooth' : 'auto',\n  }));\n};\n/**\n * Prints an error informing developers that an implementation requires an element to be used\n * within either the `ion-content` selector or the `.ion-content-scroll-host` class.\n */\nexport const printIonContentErrorMsg = (el) => {\n  return printRequiredElementError(el, ION_CONTENT_ELEMENT_SELECTOR);\n};\n/**\n * Several components in Ionic need to prevent scrolling\n * during a gesture (card modal, range, item sliding, etc).\n * Use this utility to account for ion-content and custom content hosts.\n */\nexport const disableContentScrollY = (contentEl) => {\n  if (isIonContent(contentEl)) {\n    const ionContent = contentEl;\n    const initialScrollY = ionContent.scrollY;\n    ionContent.scrollY = false;\n    /**\n     * This should be passed into resetContentScrollY\n     * so that we can revert ion-content's scrollY to the\n     * correct state. For example, if scrollY = false\n     * initially, we do not want to enable scrolling\n     * when we call resetContentScrollY.\n     */\n    return initialScrollY;\n  }\n  else {\n    contentEl.style.setProperty('overflow', 'hidden');\n    return true;\n  }\n};\nexport const resetContentScrollY = (contentEl, initialScrollY) => {\n  if (isIonContent(contentEl)) {\n    contentEl.scrollY = initialScrollY;\n  }\n  else {\n    contentEl.style.removeProperty('overflow');\n  }\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { readTask, writeTask } from '@stencil/core';\nimport { clamp } from '../../utils/helpers';\nexport const handleFooterFade = (scrollEl, baseEl) => {\n  readTask(() => {\n    const scrollTop = scrollEl.scrollTop;\n    const maxScroll = scrollEl.scrollHeight - scrollEl.clientHeight;\n    /**\n     * Toolbar background will fade\n     * out over fadeDuration in pixels.\n     */\n    const fadeDuration = 10;\n    /**\n     * Begin fading out maxScroll - 30px\n     * from the bottom of the content.\n     * Also determine how close we are\n     * to starting the fade. If we are\n     * before the starting point, the\n     * scale value will get clamped to 0.\n     * If we are after the maxScroll (rubber\n     * band scrolling), the scale value will\n     * get clamped to 1.\n     */\n    const fadeStart = maxScroll - fadeDuration;\n    const distanceToStart = scrollTop - fadeStart;\n    const scale = clamp(0, 1 - distanceToStart / fadeDuration, 1);\n    writeTask(() => {\n      baseEl.style.setProperty('--opacity-scale', scale.toString());\n    });\n  });\n};\n","ion-footer {\n  display: block;\n  position: relative;\n  order: 1;\n  width: 100%;\n  z-index: 10;\n}\n\nion-footer.footer-toolbar-padding ion-toolbar:last-of-type {\n  padding-bottom: var(--ion-safe-area-bottom, 0);\n}\n\n.footer-ios ion-toolbar:first-of-type {\n  --border-width: 0.55px 0 0;\n}\n\n@supports (backdrop-filter: blur(0)) {\n  .footer-background {\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    position: absolute;\n    backdrop-filter: saturate(180%) blur(20px);\n  }\n  .footer-translucent-ios ion-toolbar {\n    --opacity: .8;\n  }\n}\n.footer-ios.ion-no-border ion-toolbar:first-of-type {\n  --border-width: 0;\n}\n\n.footer-collapse-fade ion-toolbar {\n  --opacity-scale: inherit;\n}","ion-footer {\n  display: block;\n  position: relative;\n  order: 1;\n  width: 100%;\n  z-index: 10;\n}\n\nion-footer.footer-toolbar-padding ion-toolbar:last-of-type {\n  padding-bottom: var(--ion-safe-area-bottom, 0);\n}\n\n.footer-md::before {\n  top: -2px;\n  bottom: auto;\n  background-position: left 0 top 0;\n  position: absolute;\n  width: 100%;\n  height: 2px;\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAHBAMAAADzDtBxAAAAD1BMVEUAAAAAAAAAAAAAAAAAAABPDueNAAAABXRSTlMUCS0gBIh/TXEAAAAaSURBVAjXYxCEAgY4UIICBmMogMsgFLtAAQCNSwXZKOdPxgAAAABJRU5ErkJggg==\");\n  background-repeat: repeat-x;\n  content: \"\";\n}\n@supports (inset-inline-start: 0) {\n  .footer-md::before {\n    inset-inline-start: 0;\n  }\n}\n@supports not (inset-inline-start: 0) {\n  .footer-md::before {\n    left: 0;\n  }\n  [dir=rtl] .footer-md::before, :host-context([dir=rtl]) .footer-md::before {\n    left: unset;\n    right: unset;\n    right: 0;\n  }\n}\n[dir=rtl] .footer-md::before, :host-context([dir=rtl]) .footer-md::before {\n  background-position: right 0 top 0;\n}\n\n.footer-md.ion-no-border::before {\n  display: none;\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, h } from '@stencil/core';\nimport { getIonMode } from '../../global/ionic-global';\nimport { findIonContent, getScrollElement, printIonContentErrorMsg } from '../../utils/content';\nimport { createKeyboardController } from '../../utils/keyboard/keyboard-controller';\nimport { handleFooterFade } from './footer.utils';\n/**\n * @virtualProp {\"ios\" | \"md\"} mode - The mode determines which platform styles to use.\n */\nexport class Footer {\n  constructor() {\n    this.keyboardCtrl = null;\n    this.checkCollapsibleFooter = () => {\n      const mode = getIonMode(this);\n      if (mode !== 'ios') {\n        return;\n      }\n      const { collapse } = this;\n      const hasFade = collapse === 'fade';\n      this.destroyCollapsibleFooter();\n      if (hasFade) {\n        const pageEl = this.el.closest('ion-app,ion-page,.ion-page,page-inner');\n        const contentEl = pageEl ? findIonContent(pageEl) : null;\n        if (!contentEl) {\n          printIonContentErrorMsg(this.el);\n          return;\n        }\n        this.setupFadeFooter(contentEl);\n      }\n    };\n    this.setupFadeFooter = async (contentEl) => {\n      const scrollEl = (this.scrollEl = await getScrollElement(contentEl));\n      /**\n       * Handle fading of toolbars on scroll\n       */\n      this.contentScrollCallback = () => {\n        handleFooterFade(scrollEl, this.el);\n      };\n      scrollEl.addEventListener('scroll', this.contentScrollCallback);\n      handleFooterFade(scrollEl, this.el);\n    };\n    this.keyboardVisible = false;\n    this.collapse = undefined;\n    this.translucent = false;\n  }\n  componentDidLoad() {\n    this.checkCollapsibleFooter();\n  }\n  componentDidUpdate() {\n    this.checkCollapsibleFooter();\n  }\n  connectedCallback() {\n    this.keyboardCtrl = createKeyboardController((keyboardOpen) => {\n      this.keyboardVisible = keyboardOpen; // trigger re-render by updating state\n    });\n  }\n  disconnectedCallback() {\n    if (this.keyboardCtrl) {\n      this.keyboardCtrl.destroy();\n    }\n  }\n  destroyCollapsibleFooter() {\n    if (this.scrollEl && this.contentScrollCallback) {\n      this.scrollEl.removeEventListener('scroll', this.contentScrollCallback);\n      this.contentScrollCallback = undefined;\n    }\n  }\n  render() {\n    const { translucent, collapse } = this;\n    const mode = getIonMode(this);\n    const tabs = this.el.closest('ion-tabs');\n    const tabBar = tabs === null || tabs === void 0 ? void 0 : tabs.querySelector(':scope > ion-tab-bar');\n    return (h(Host, { role: \"contentinfo\", class: {\n        [mode]: true,\n        // Used internally for styling\n        [`footer-${mode}`]: true,\n        [`footer-translucent`]: translucent,\n        [`footer-translucent-${mode}`]: translucent,\n        ['footer-toolbar-padding']: !this.keyboardVisible && (!tabBar || tabBar.slot !== 'bottom'),\n        [`footer-collapse-${collapse}`]: collapse !== undefined,\n      } }, mode === 'ios' && translucent && h(\"div\", { class: \"footer-background\" }), h(\"slot\", null)));\n  }\n  static get is() { return \"ion-footer\"; }\n  static get originalStyleUrls() {\n    return {\n      \"ios\": [\"footer.ios.scss\"],\n      \"md\": [\"footer.md.scss\"]\n    };\n  }\n  static get styleUrls() {\n    return {\n      \"ios\": [\"footer.ios.css\"],\n      \"md\": [\"footer.md.css\"]\n    };\n  }\n  static get properties() {\n    return {\n      \"collapse\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"'fade'\",\n          \"resolved\": \"\\\"fade\\\" | undefined\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Describes the scroll effect that will be applied to the footer.\\nOnly applies in iOS mode.\"\n        },\n        \"attribute\": \"collapse\",\n        \"reflect\": false\n      },\n      \"translucent\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, the footer will be translucent.\\nOnly applies when the mode is `\\\"ios\\\"` and the device supports\\n[`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).\\n\\nNote: In order to scroll content behind the footer, the `fullscreen`\\nattribute needs to be set on the content.\"\n        },\n        \"attribute\": \"translucent\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      }\n    };\n  }\n  static get states() {\n    return {\n      \"keyboardVisible\": {}\n    };\n  }\n  static get elementRef() { return \"el\"; }\n}\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { win } from '../window';\n/**\n * Creates a controller that tracks and reacts to opening or closing the keyboard.\n *\n * @internal\n * @param keyboardChangeCallback A function to call when the keyboard opens or closes.\n */\nexport const createKeyboardController = (keyboardChangeCallback) => {\n  let keyboardWillShowHandler;\n  let keyboardWillHideHandler;\n  let keyboardVisible;\n  const init = () => {\n    keyboardWillShowHandler = () => {\n      keyboardVisible = true;\n      if (keyboardChangeCallback)\n        keyboardChangeCallback(true);\n    };\n    keyboardWillHideHandler = () => {\n      keyboardVisible = false;\n      if (keyboardChangeCallback)\n        keyboardChangeCallback(false);\n    };\n    win === null || win === void 0 ? void 0 : win.addEventListener('keyboardWillShow', keyboardWillShowHandler);\n    win === null || win === void 0 ? void 0 : win.addEventListener('keyboardWillHide', keyboardWillHideHandler);\n  };\n  const destroy = () => {\n    win === null || win === void 0 ? void 0 : win.removeEventListener('keyboardWillShow', keyboardWillShowHandler);\n    win === null || win === void 0 ? void 0 : win.removeEventListener('keyboardWillHide', keyboardWillHideHandler);\n    keyboardWillShowHandler = keyboardWillHideHandler = undefined;\n  };\n  const isKeyboardVisible = () => keyboardVisible;\n  init();\n  return { init, destroy, isKeyboardVisible };\n};\n"],"names":[],"sourceRoot":""}