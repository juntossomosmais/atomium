"use strict";
(self["webpackChunkatomium_storybook"] = self["webpackChunkatomium_storybook"] || []).push([["library_dist_esm_ion-router-outlet_entry_js"],{

/***/ "../library/dist/esm/cubic-bezier-1aed87b5.js":
/*!****************************************************!*\
  !*** ../library/dist/esm/cubic-bezier-1aed87b5.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "g": () => (/* binding */ getTimeGivenProgression)
/* harmony export */ });
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
/**
 * Based on:
 * https://stackoverflow.com/questions/7348009/y-coordinate-for-a-given-x-cubic-bezier
 * https://math.stackexchange.com/questions/26846/is-there-an-explicit-form-for-cubic-b%C3%A9zier-curves
 */
/**
 * EXPERIMENTAL
 * Given a cubic-bezier curve, get the x value (time) given
 * the y value (progression).
 * Ex: cubic-bezier(0.32, 0.72, 0, 1);
 * P0: (0, 0)
 * P1: (0.32, 0.72)
 * P2: (0, 1)
 * P3: (1, 1)
 *
 * If you give a cubic bezier curve that never reaches the
 * provided progression, this function will return an empty array.
 */
const getTimeGivenProgression = (p0, p1, p2, p3, progression) => {
  return solveCubicBezier(p0[1], p1[1], p2[1], p3[1], progression).map(tValue => {
    return solveCubicParametricEquation(p0[0], p1[0], p2[0], p3[0], tValue);
  });
};
/**
 * Solve a cubic equation in one dimension (time)
 */
const solveCubicParametricEquation = (p0, p1, p2, p3, t) => {
  const partA = 3 * p1 * Math.pow(t - 1, 2);
  const partB = -3 * p2 * t + 3 * p2 + p3 * t;
  const partC = p0 * Math.pow(t - 1, 3);
  return t * (partA + t * partB) - partC;
};
/**
 * Find the `t` value for a cubic bezier using Cardano's formula
 */
const solveCubicBezier = (p0, p1, p2, p3, refPoint) => {
  p0 -= refPoint;
  p1 -= refPoint;
  p2 -= refPoint;
  p3 -= refPoint;
  const roots = solveCubicEquation(p3 - 3 * p2 + 3 * p1 - p0, 3 * p2 - 6 * p1 + 3 * p0, 3 * p1 - 3 * p0, p0);
  return roots.filter(root => root >= 0 && root <= 1);
};
const solveQuadraticEquation = (a, b, c) => {
  const discriminant = b * b - 4 * a * c;
  if (discriminant < 0) {
    return [];
  } else {
    return [(-b + Math.sqrt(discriminant)) / (2 * a), (-b - Math.sqrt(discriminant)) / (2 * a)];
  }
};
const solveCubicEquation = (a, b, c, d) => {
  if (a === 0) {
    return solveQuadraticEquation(b, c, d);
  }
  b /= a;
  c /= a;
  d /= a;
  const p = (3 * c - b * b) / 3;
  const q = (2 * b * b * b - 9 * b * c + 27 * d) / 27;
  if (p === 0) {
    return [Math.pow(-q, 1 / 3)];
  } else if (q === 0) {
    return [Math.sqrt(-p), -Math.sqrt(-p)];
  }
  const discriminant = Math.pow(q / 2, 2) + Math.pow(p / 3, 3);
  if (discriminant === 0) {
    return [Math.pow(q / 2, 1 / 2) - b / 3];
  } else if (discriminant > 0) {
    return [Math.pow(-(q / 2) + Math.sqrt(discriminant), 1 / 3) - Math.pow(q / 2 + Math.sqrt(discriminant), 1 / 3) - b / 3];
  }
  const r = Math.sqrt(Math.pow(-(p / 3), 3));
  const phi = Math.acos(-(q / (2 * Math.sqrt(Math.pow(-(p / 3), 3)))));
  const s = 2 * Math.pow(r, 1 / 3);
  return [s * Math.cos(phi / 3) - b / 3, s * Math.cos((phi + 2 * Math.PI) / 3) - b / 3, s * Math.cos((phi + 4 * Math.PI) / 3) - b / 3];
};


/***/ }),

/***/ "../library/dist/esm/ion-router-outlet.entry.js":
/*!******************************************************!*\
  !*** ../library/dist/esm/ion-router-outlet.entry.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ion_router_outlet": () => (/* binding */ RouterOutlet)
/* harmony export */ });
/* harmony import */ var _index_5797d131_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-5797d131.js */ "../library/dist/esm/index-5797d131.js");
/* harmony import */ var _ionic_global_060edf0f_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ionic-global-060edf0f.js */ "../library/dist/esm/ionic-global-060edf0f.js");
/* harmony import */ var _cubic_bezier_1aed87b5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cubic-bezier-1aed87b5.js */ "../library/dist/esm/cubic-bezier-1aed87b5.js");
/* harmony import */ var _framework_delegate_744af0db_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./framework-delegate-744af0db.js */ "../library/dist/esm/framework-delegate-744af0db.js");
/* harmony import */ var _helpers_50710f77_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers-50710f77.js */ "../library/dist/esm/helpers-50710f77.js");
/* harmony import */ var _index_da834e05_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-da834e05.js */ "../library/dist/esm/index-da834e05.js");






const routeOutletCss = ":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;overflow:hidden;z-index:0}";
const RouterOutlet = class {
  constructor(hostRef) {
    (0,_index_5797d131_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.ionNavWillLoad = (0,_index_5797d131_js__WEBPACK_IMPORTED_MODULE_0__.d)(this, "ionNavWillLoad", 7);
    this.ionNavWillChange = (0,_index_5797d131_js__WEBPACK_IMPORTED_MODULE_0__.d)(this, "ionNavWillChange", 3);
    this.ionNavDidChange = (0,_index_5797d131_js__WEBPACK_IMPORTED_MODULE_0__.d)(this, "ionNavDidChange", 3);
    this.gestureOrAnimationInProgress = false;
    this.mode = (0,_ionic_global_060edf0f_js__WEBPACK_IMPORTED_MODULE_1__.g)(this);
    this.animated = true;
  }
  swipeHandlerChanged() {
    if (this.gesture) {
      this.gesture.enable(this.swipeHandler !== undefined);
    }
  }
  async connectedCallback() {
    const onStart = () => {
      this.gestureOrAnimationInProgress = true;
      if (this.swipeHandler) {
        this.swipeHandler.onStart();
      }
    };
    this.gesture = (await Promise.all(/*! import() */[__webpack_require__.e("library_dist_esm_index-e65e72c8_js"), __webpack_require__.e("library_dist_esm_swipe-back-68fd4aa4_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ./swipe-back-68fd4aa4.js */ "../library/dist/esm/swipe-back-68fd4aa4.js"))).createSwipeBackGesture(this.el, () => !this.gestureOrAnimationInProgress && !!this.swipeHandler && this.swipeHandler.canStart(), () => onStart(), step => {
      var _a;
      return (_a = this.ani) === null || _a === void 0 ? void 0 : _a.progressStep(step);
    }, (shouldComplete, step, dur) => {
      if (this.ani) {
        this.ani.onFinish(() => {
          this.gestureOrAnimationInProgress = false;
          if (this.swipeHandler) {
            this.swipeHandler.onEnd(shouldComplete);
          }
        }, {
          oneTimeCallback: true
        });
        let newStepValue = shouldComplete ? -0.001 : 0.001;
        if (!shouldComplete) {
          this.ani.easing('cubic-bezier(1, 0, 0.68, 0.28)');
          newStepValue += (0,_cubic_bezier_1aed87b5_js__WEBPACK_IMPORTED_MODULE_3__.g)([0, 0], [1, 0], [0.68, 0.28], [1, 1], step)[0];
        } else {
          newStepValue += (0,_cubic_bezier_1aed87b5_js__WEBPACK_IMPORTED_MODULE_3__.g)([0, 0], [0.32, 0.72], [0, 1], [1, 1], step)[0];
        }
        this.ani.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);
      } else {
        this.gestureOrAnimationInProgress = false;
      }
    });
    this.swipeHandlerChanged();
  }
  componentWillLoad() {
    this.ionNavWillLoad.emit();
  }
  disconnectedCallback() {
    if (this.gesture) {
      this.gesture.destroy();
      this.gesture = undefined;
    }
  }
  async commit(enteringEl, leavingEl, opts) {
    const unlock = await this.lock();
    let changed = false;
    try {
      changed = await this.transition(enteringEl, leavingEl, opts);
    } catch (e) {
      console.error(e);
    }
    unlock();
    return changed;
  }
  async setRouteId(id, params, direction, animation) {
    const changed = await this.setRoot(id, params, {
      duration: direction === 'root' ? 0 : undefined,
      direction: direction === 'back' ? 'back' : 'forward',
      animationBuilder: animation
    });
    return {
      changed,
      element: this.activeEl
    };
  }
  async getRouteId() {
    const active = this.activeEl;
    return active ? {
      id: active.tagName,
      element: active,
      params: this.activeParams
    } : undefined;
  }
  async setRoot(component, params, opts) {
    if (this.activeComponent === component && (0,_helpers_50710f77_js__WEBPACK_IMPORTED_MODULE_4__.s)(params, this.activeParams)) {
      return false;
    }
    const leavingEl = this.activeEl;
    const enteringEl = await (0,_framework_delegate_744af0db_js__WEBPACK_IMPORTED_MODULE_5__.a)(this.delegate, this.el, component, ['ion-page', 'ion-page-invisible'], params);
    this.activeComponent = component;
    this.activeEl = enteringEl;
    this.activeParams = params;
    await this.commit(enteringEl, leavingEl, opts);
    await (0,_framework_delegate_744af0db_js__WEBPACK_IMPORTED_MODULE_5__.d)(this.delegate, leavingEl);
    return true;
  }
  async transition(enteringEl, leavingEl, opts = {}) {
    if (leavingEl === enteringEl) {
      return false;
    }
    this.ionNavWillChange.emit();
    const {
      el,
      mode
    } = this;
    const animated = this.animated && _ionic_global_060edf0f_js__WEBPACK_IMPORTED_MODULE_1__.c.getBoolean('animated', true);
    const animationBuilder = opts.animationBuilder || this.animation || _ionic_global_060edf0f_js__WEBPACK_IMPORTED_MODULE_1__.c.get('navAnimation');
    await (0,_index_da834e05_js__WEBPACK_IMPORTED_MODULE_2__.t)(Object.assign(Object.assign({
      mode,
      animated,
      enteringEl,
      leavingEl,
      baseEl: el,
      progressCallback: opts.progressAnimation ? ani => {
        if (ani !== undefined && !this.gestureOrAnimationInProgress) {
          this.gestureOrAnimationInProgress = true;
          ani.onFinish(() => {
            this.gestureOrAnimationInProgress = false;
            if (this.swipeHandler) {
              this.swipeHandler.onEnd(false);
            }
          }, {
            oneTimeCallback: true
          });
          ani.progressEnd(0, 0, 0);
        } else {
          this.ani = ani;
        }
      } : undefined
    }, opts), {
      animationBuilder
    }));
    this.ionNavDidChange.emit();
    return true;
  }
  async lock() {
    const p = this.waitPromise;
    let resolve;
    this.waitPromise = new Promise(r => resolve = r);
    if (p !== undefined) {
      await p;
    }
    return resolve;
  }
  render() {
    return (0,_index_5797d131_js__WEBPACK_IMPORTED_MODULE_0__.h)("slot", null);
  }
  get el() {
    return (0,_index_5797d131_js__WEBPACK_IMPORTED_MODULE_0__.e)(this);
  }
  static get watchers() {
    return {
      "swipeHandler": ["swipeHandlerChanged"]
    };
  }
};
RouterOutlet.style = routeOutletCss;


/***/ })

}]);
//# sourceMappingURL=library_dist_esm_ion-router-outlet_entry_js.iframe.bundle.js.map