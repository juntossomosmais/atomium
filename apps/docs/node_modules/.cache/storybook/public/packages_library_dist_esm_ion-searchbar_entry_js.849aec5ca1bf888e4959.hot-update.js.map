{"version":3,"file":"packages_library_dist_esm_ion-searchbar_entry_js.849aec5ca1bf888e4959.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;ACAA;ACaA;AACA;;;;;;;;;AACA;AACA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAOA;AACA;AAOA;;;AAGA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAMA;AACA;;AAEA;AACA;;AAEA;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAKA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAMA;AACA;AACA;;;AAMA;AACA;;AAQA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;;AAKA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAMA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;;AAEA;AACA;;AAQA;AACA;AACA;;AAEA;;AAQA;AACA;AACA;;AAEA;;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","sources":["webpack://atomium-docs/../../node_modules/@ionic/core/dist/collection/components/searchbar/searchbar.ios.css","webpack://atomium-docs/../../node_modules/@ionic/core/dist/collection/components/searchbar/searchbar.md.css","webpack://atomium-docs/../../node_modules/@ionic/core/dist/collection/components/searchbar/searchbar.js"],"sourcesContent":[":host {\n  /**\n   * @prop --background: Background of the searchbar input\n   * @prop --box-shadow: Box shadow of the searchbar input\n   * @prop --border-radius: Border radius of the searchbar input\n   * @prop --cancel-button-color: Color of the searchbar cancel button\n   * @prop --clear-button-color: Color of the searchbar clear button\n   * @prop --color: Color of the searchbar text\n   * @prop --icon-color: Color of the searchbar icon\n   * @prop --placeholder-color: Color of the searchbar placeholder\n   * @prop --placeholder-font-style: Font style of the searchbar placeholder\n   * @prop --placeholder-font-weight: Font weight of the searchbar placeholder\n   * @prop --placeholder-opacity: Opacity of the searchbar placeholder\n   */\n  --placeholder-color: initial;\n  --placeholder-font-style: initial;\n  --placeholder-font-weight: initial;\n  --placeholder-opacity: 0.6;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  display: flex;\n  position: relative;\n  align-items: center;\n  width: 100%;\n  color: var(--color);\n  font-family: var(--ion-font-family, inherit);\n  box-sizing: border-box;\n}\n\n:host(.ion-color) {\n  color: var(--ion-color-contrast);\n}\n\n:host(.ion-color) .searchbar-input {\n  background: var(--ion-color-base);\n}\n\n:host(.ion-color) .searchbar-clear-button,\n:host(.ion-color) .searchbar-cancel-button,\n:host(.ion-color) .searchbar-search-icon {\n  color: inherit;\n}\n\n.searchbar-search-icon {\n  color: var(--icon-color);\n  pointer-events: none;\n}\n\n.searchbar-input-container {\n  display: block;\n  position: relative;\n  flex-shrink: 1;\n  width: 100%;\n}\n\n.searchbar-input {\n  font-family: inherit;\n  font-size: inherit;\n  font-style: inherit;\n  font-weight: inherit;\n  letter-spacing: inherit;\n  text-decoration: inherit;\n  text-indent: inherit;\n  text-overflow: inherit;\n  text-transform: inherit;\n  text-align: inherit;\n  white-space: inherit;\n  color: inherit;\n  border-radius: var(--border-radius);\n  display: block;\n  width: 100%;\n  border: 0;\n  outline: none;\n  background: var(--background);\n  font-family: inherit;\n  box-shadow: var(--box-shadow);\n  box-sizing: border-box;\n  appearance: none;\n}\n.searchbar-input::placeholder {\n  color: var(--placeholder-color);\n  font-family: inherit;\n  font-style: var(--placeholder-font-style);\n  font-weight: var(--placeholder-font-weight);\n  opacity: var(--placeholder-opacity);\n}\n.searchbar-input::-webkit-search-cancel-button, .searchbar-input::-ms-clear {\n  display: none;\n}\n\n.searchbar-cancel-button {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n  display: none;\n  height: 100%;\n  border: 0;\n  outline: none;\n  color: var(--cancel-button-color);\n  cursor: pointer;\n  appearance: none;\n}\n\n.searchbar-cancel-button > div {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 100%;\n}\n\n.searchbar-clear-button {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  padding-bottom: 0;\n  display: none;\n  min-height: 0;\n  outline: none;\n  color: var(--clear-button-color);\n  appearance: none;\n}\n\n/**\n * Normally, we would not want to use :focus\n * here because that would mean tapping the button\n * on mobile would focus it (and keep it focused).\n * However, the clear button always disappears after\n * being activated, so we never get to that state.\n */\n.searchbar-clear-button:focus {\n  opacity: 0.5;\n}\n\n:host(.searchbar-has-value.searchbar-should-show-clear) .searchbar-clear-button {\n  display: block;\n}\n\n:host(.searchbar-disabled) {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n}\n\n:host {\n  --background: rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.07);\n  --border-radius: 10px;\n  --box-shadow: none;\n  --cancel-button-color: var(--ion-color-primary, #3880ff);\n  --clear-button-color: var(--ion-color-step-600, #666666);\n  --color: var(--ion-text-color, #000);\n  --icon-color: var(--ion-color-step-600, #666666);\n  -webkit-padding-start: 12px;\n  padding-inline-start: 12px;\n  -webkit-padding-end: 12px;\n  padding-inline-end: 12px;\n  padding-top: 12px;\n  padding-bottom: 12px;\n  height: 60px;\n  contain: strict;\n}\n\n.searchbar-input-container {\n  height: 36px;\n}\n\n.searchbar-search-icon {\n  -webkit-margin-start: calc(50% - 60px);\n  margin-inline-start: calc(50% - 60px);\n  top: 0;\n  position: absolute;\n  width: 22px;\n  height: 100%;\n  contain: strict;\n}\n@supports (inset-inline-start: 0) {\n  .searchbar-search-icon {\n    inset-inline-start: 5px;\n  }\n}\n@supports not (inset-inline-start: 0) {\n  .searchbar-search-icon {\n    left: 5px;\n  }\n  [dir=rtl] .searchbar-search-icon, :host-context([dir=rtl]) .searchbar-search-icon {\n    left: unset;\n    right: unset;\n    right: 5px;\n  }\n}\n\n.searchbar-input {\n  -webkit-padding-start: 28px;\n  padding-inline-start: 28px;\n  -webkit-padding-end: 28px;\n  padding-inline-end: 28px;\n  padding-top: 0;\n  padding-bottom: 0;\n  height: 100%;\n  font-size: 17px;\n  font-weight: 400;\n  contain: strict;\n}\n\n.searchbar-clear-button {\n  top: 0;\n  background-position: center;\n  position: absolute;\n  width: 30px;\n  height: 100%;\n  border: 0;\n  background-color: transparent;\n}\n@supports (inset-inline-start: 0) {\n  .searchbar-clear-button {\n    inset-inline-end: 0;\n  }\n}\n@supports not (inset-inline-start: 0) {\n  .searchbar-clear-button {\n    right: 0;\n  }\n  [dir=rtl] .searchbar-clear-button, :host-context([dir=rtl]) .searchbar-clear-button {\n    left: unset;\n    right: unset;\n    left: 0;\n  }\n}\n\n.searchbar-clear-icon {\n  width: 18px;\n  height: 100%;\n}\n\n.searchbar-cancel-button {\n  -webkit-padding-start: 8px;\n  padding-inline-start: 8px;\n  -webkit-padding-end: 0;\n  padding-inline-end: 0;\n  padding-top: 0;\n  padding-bottom: 0;\n  flex-shrink: 0;\n  background-color: transparent;\n  font-size: 16px;\n}\n\n:host(.searchbar-left-aligned) .searchbar-search-icon {\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n}\n\n:host(.searchbar-left-aligned) .searchbar-input {\n  -webkit-padding-start: 30px;\n  padding-inline-start: 30px;\n}\n\n:host(.searchbar-has-focus) .searchbar-cancel-button,\n:host(.searchbar-should-show-cancel) .searchbar-cancel-button,\n:host(.searchbar-animated) .searchbar-cancel-button {\n  display: block;\n}\n\n:host(.searchbar-animated) .searchbar-search-icon,\n:host(.searchbar-animated) .searchbar-input {\n  transition: all 300ms ease;\n}\n\n:host(.searchbar-animated.searchbar-has-focus) .searchbar-cancel-button,\n:host(.searchbar-animated.searchbar-should-show-cancel) .searchbar-cancel-button {\n  opacity: 1;\n  pointer-events: auto;\n}\n\n:host(.searchbar-animated) .searchbar-cancel-button {\n  -webkit-margin-end: -100%;\n  margin-inline-end: -100%;\n  transform: translate3d(0,  0,  0);\n  transition: all 300ms ease;\n  opacity: 0;\n  pointer-events: none;\n}\n\n:host(.searchbar-no-animate) .searchbar-search-icon,\n:host(.searchbar-no-animate) .searchbar-input,\n:host(.searchbar-no-animate) .searchbar-cancel-button {\n  transition-duration: 0ms;\n}\n\n:host(.ion-color) .searchbar-cancel-button {\n  color: var(--ion-color-base);\n}\n\n@media (any-hover: hover) {\n  :host(.ion-color) .searchbar-cancel-button:hover {\n    color: var(--ion-color-tint);\n  }\n}\n:host-context(ion-toolbar) {\n  padding-top: 1px;\n  padding-bottom: 15px;\n  height: 52px;\n}\n\n:host-context(ion-toolbar.ion-color):not(.ion-color) {\n  color: inherit;\n}\n\n:host-context(ion-toolbar.ion-color):not(.ion-color) .searchbar-cancel-button {\n  color: currentColor;\n}\n\n:host-context(ion-toolbar.ion-color) .searchbar-search-icon {\n  color: currentColor;\n  opacity: 0.5;\n}\n\n:host-context(ion-toolbar.ion-color):not(.ion-color) .searchbar-input {\n  background: rgba(var(--ion-color-contrast-rgb), 0.07);\n  color: currentColor;\n}\n\n:host-context(ion-toolbar.ion-color):not(.ion-color) .searchbar-clear-button {\n  color: currentColor;\n  opacity: 0.5;\n}",":host {\n  /**\n   * @prop --background: Background of the searchbar input\n   * @prop --box-shadow: Box shadow of the searchbar input\n   * @prop --border-radius: Border radius of the searchbar input\n   * @prop --cancel-button-color: Color of the searchbar cancel button\n   * @prop --clear-button-color: Color of the searchbar clear button\n   * @prop --color: Color of the searchbar text\n   * @prop --icon-color: Color of the searchbar icon\n   * @prop --placeholder-color: Color of the searchbar placeholder\n   * @prop --placeholder-font-style: Font style of the searchbar placeholder\n   * @prop --placeholder-font-weight: Font weight of the searchbar placeholder\n   * @prop --placeholder-opacity: Opacity of the searchbar placeholder\n   */\n  --placeholder-color: initial;\n  --placeholder-font-style: initial;\n  --placeholder-font-weight: initial;\n  --placeholder-opacity: 0.6;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  display: flex;\n  position: relative;\n  align-items: center;\n  width: 100%;\n  color: var(--color);\n  font-family: var(--ion-font-family, inherit);\n  box-sizing: border-box;\n}\n\n:host(.ion-color) {\n  color: var(--ion-color-contrast);\n}\n\n:host(.ion-color) .searchbar-input {\n  background: var(--ion-color-base);\n}\n\n:host(.ion-color) .searchbar-clear-button,\n:host(.ion-color) .searchbar-cancel-button,\n:host(.ion-color) .searchbar-search-icon {\n  color: inherit;\n}\n\n.searchbar-search-icon {\n  color: var(--icon-color);\n  pointer-events: none;\n}\n\n.searchbar-input-container {\n  display: block;\n  position: relative;\n  flex-shrink: 1;\n  width: 100%;\n}\n\n.searchbar-input {\n  font-family: inherit;\n  font-size: inherit;\n  font-style: inherit;\n  font-weight: inherit;\n  letter-spacing: inherit;\n  text-decoration: inherit;\n  text-indent: inherit;\n  text-overflow: inherit;\n  text-transform: inherit;\n  text-align: inherit;\n  white-space: inherit;\n  color: inherit;\n  border-radius: var(--border-radius);\n  display: block;\n  width: 100%;\n  border: 0;\n  outline: none;\n  background: var(--background);\n  font-family: inherit;\n  box-shadow: var(--box-shadow);\n  box-sizing: border-box;\n  appearance: none;\n}\n.searchbar-input::placeholder {\n  color: var(--placeholder-color);\n  font-family: inherit;\n  font-style: var(--placeholder-font-style);\n  font-weight: var(--placeholder-font-weight);\n  opacity: var(--placeholder-opacity);\n}\n.searchbar-input::-webkit-search-cancel-button, .searchbar-input::-ms-clear {\n  display: none;\n}\n\n.searchbar-cancel-button {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n  display: none;\n  height: 100%;\n  border: 0;\n  outline: none;\n  color: var(--cancel-button-color);\n  cursor: pointer;\n  appearance: none;\n}\n\n.searchbar-cancel-button > div {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 100%;\n}\n\n.searchbar-clear-button {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  padding-bottom: 0;\n  display: none;\n  min-height: 0;\n  outline: none;\n  color: var(--clear-button-color);\n  appearance: none;\n}\n\n/**\n * Normally, we would not want to use :focus\n * here because that would mean tapping the button\n * on mobile would focus it (and keep it focused).\n * However, the clear button always disappears after\n * being activated, so we never get to that state.\n */\n.searchbar-clear-button:focus {\n  opacity: 0.5;\n}\n\n:host(.searchbar-has-value.searchbar-should-show-clear) .searchbar-clear-button {\n  display: block;\n}\n\n:host(.searchbar-disabled) {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n}\n\n:host {\n  --background: var(--ion-background-color, #fff);\n  --border-radius: 2px;\n  --box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 1px 5px 0 rgba(0, 0, 0, 0.12);\n  --cancel-button-color: var(--ion-color-step-900, #1a1a1a);\n  --clear-button-color: initial;\n  --color: var(--ion-color-step-850, #262626);\n  --icon-color: var(--ion-color-step-600, #666666);\n  -webkit-padding-start: 8px;\n  padding-inline-start: 8px;\n  -webkit-padding-end: 8px;\n  padding-inline-end: 8px;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  background: inherit;\n}\n\n.searchbar-search-icon {\n  top: 11px;\n  width: 21px;\n  height: 21px;\n}\n@supports (inset-inline-start: 0) {\n  .searchbar-search-icon {\n    inset-inline-start: 16px;\n  }\n}\n@supports not (inset-inline-start: 0) {\n  .searchbar-search-icon {\n    left: 16px;\n  }\n  [dir=rtl] .searchbar-search-icon, :host-context([dir=rtl]) .searchbar-search-icon {\n    left: unset;\n    right: unset;\n    right: 16px;\n  }\n}\n\n.searchbar-cancel-button {\n  top: 0;\n  background-color: transparent;\n  font-size: 1.6em;\n}\n@supports (inset-inline-start: 0) {\n  .searchbar-cancel-button {\n    inset-inline-start: 5px;\n  }\n}\n@supports not (inset-inline-start: 0) {\n  .searchbar-cancel-button {\n    left: 5px;\n  }\n  [dir=rtl] .searchbar-cancel-button, :host-context([dir=rtl]) .searchbar-cancel-button {\n    left: unset;\n    right: unset;\n    right: 5px;\n  }\n}\n\n.searchbar-search-icon,\n.searchbar-cancel-button {\n  position: absolute;\n}\n\n.searchbar-search-icon.ion-activated,\n.searchbar-cancel-button.ion-activated {\n  background-color: transparent;\n}\n\n.searchbar-input {\n  -webkit-padding-start: 55px;\n  padding-inline-start: 55px;\n  -webkit-padding-end: 55px;\n  padding-inline-end: 55px;\n  padding-top: 6px;\n  padding-bottom: 6px;\n  background-position: left 8px center;\n  height: auto;\n  font-size: 16px;\n  font-weight: 400;\n  line-height: 30px;\n}\n[dir=rtl] .searchbar-input, :host-context([dir=rtl]) .searchbar-input {\n  background-position: right 8px center;\n}\n\n.searchbar-clear-button {\n  top: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  padding-bottom: 0;\n  position: absolute;\n  height: 100%;\n  border: 0;\n  background-color: transparent;\n}\n@supports (inset-inline-start: 0) {\n  .searchbar-clear-button {\n    inset-inline-end: 13px;\n  }\n}\n@supports not (inset-inline-start: 0) {\n  .searchbar-clear-button {\n    right: 13px;\n  }\n  [dir=rtl] .searchbar-clear-button, :host-context([dir=rtl]) .searchbar-clear-button {\n    left: unset;\n    right: unset;\n    left: 13px;\n  }\n}\n\n.searchbar-clear-button.ion-activated {\n  background-color: transparent;\n}\n\n.searchbar-clear-icon {\n  width: 22px;\n  height: 100%;\n}\n\n:host(.searchbar-has-focus) .searchbar-search-icon {\n  display: block;\n}\n\n:host(.searchbar-has-focus) .searchbar-cancel-button,\n:host(.searchbar-should-show-cancel) .searchbar-cancel-button {\n  display: block;\n}\n\n:host(.searchbar-has-focus) .searchbar-cancel-button + .searchbar-search-icon,\n:host(.searchbar-should-show-cancel) .searchbar-cancel-button + .searchbar-search-icon {\n  display: none;\n}\n\n:host-context(ion-toolbar) {\n  -webkit-padding-start: 7px;\n  padding-inline-start: 7px;\n  -webkit-padding-end: 7px;\n  padding-inline-end: 7px;\n  padding-top: 3px;\n  padding-bottom: 3px;\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, forceUpdate, h } from '@stencil/core';\nimport { arrowBackSharp, closeCircle, closeSharp, searchOutline, searchSharp } from 'ionicons/icons';\nimport { config } from '../../global/config';\nimport { getIonMode } from '../../global/ionic-global';\nimport { debounceEvent, raf } from '../../utils/helpers';\nimport { isRTL } from '../../utils/rtl';\nimport { createColorClasses } from '../../utils/theme';\n/**\n * @virtualProp {\"ios\" | \"md\"} mode - The mode determines which platform styles to use.\n */\nexport class Searchbar {\n  constructor() {\n    this.isCancelVisible = false;\n    this.shouldAlignLeft = true;\n    /**\n     * Clears the input field and triggers the control change.\n     */\n    this.onClearInput = async (shouldFocus) => {\n      this.ionClear.emit();\n      return new Promise((resolve) => {\n        // setTimeout() fixes https://github.com/ionic-team/ionic/issues/7527\n        // wait for 4 frames\n        setTimeout(() => {\n          const value = this.getValue();\n          if (value !== '') {\n            this.value = '';\n            this.emitInputChange();\n            /**\n             * When tapping clear button\n             * ensure input is focused after\n             * clearing input so users\n             * can quickly start typing.\n             */\n            if (shouldFocus && !this.focused) {\n              this.setFocus();\n              /**\n               * The setFocus call above will clear focusedValue,\n               * but ionChange will never have gotten a chance to\n               * fire. Manually revert focusedValue so onBlur can\n               * compare against what was in the box before the clear.\n               */\n              this.focusedValue = value;\n            }\n          }\n          resolve();\n        }, 16 * 4);\n      });\n    };\n    /**\n     * Clears the input field and tells the input to blur since\n     * the clearInput function doesn't want the input to blur\n     * then calls the custom cancel function if the user passed one in.\n     */\n    this.onCancelSearchbar = async (ev) => {\n      if (ev) {\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n      this.ionCancel.emit();\n      // get cached values before clearing the input\n      const value = this.getValue();\n      const focused = this.focused;\n      await this.onClearInput();\n      /**\n       * If there used to be something in the box, and we weren't focused\n       * beforehand (meaning no blur fired that would already handle this),\n       * manually fire ionChange.\n       */\n      if (value && !focused) {\n        this.emitValueChange(ev);\n      }\n      if (this.nativeInput) {\n        this.nativeInput.blur();\n      }\n    };\n    /**\n     * Update the Searchbar input value when the input changes\n     */\n    this.onInput = (ev) => {\n      const input = ev.target;\n      if (input) {\n        this.value = input.value;\n      }\n      this.emitInputChange(ev);\n    };\n    this.onChange = (ev) => {\n      this.emitValueChange(ev);\n    };\n    /**\n     * Sets the Searchbar to not focused and checks if it should align left\n     * based on whether there is a value in the searchbar or not.\n     */\n    this.onBlur = (ev) => {\n      this.focused = false;\n      this.ionBlur.emit();\n      this.positionElements();\n      if (this.focusedValue !== this.value) {\n        this.emitValueChange(ev);\n      }\n      this.focusedValue = undefined;\n    };\n    /**\n     * Sets the Searchbar to focused and active on input focus.\n     */\n    this.onFocus = () => {\n      this.focused = true;\n      this.focusedValue = this.value;\n      this.ionFocus.emit();\n      this.positionElements();\n    };\n    this.focused = false;\n    this.noAnimate = true;\n    this.color = undefined;\n    this.animated = false;\n    this.autocomplete = 'off';\n    this.autocorrect = 'off';\n    this.cancelButtonIcon = config.get('backButtonIcon', arrowBackSharp);\n    this.cancelButtonText = 'Cancel';\n    this.clearIcon = undefined;\n    this.debounce = undefined;\n    this.disabled = false;\n    this.inputmode = undefined;\n    this.enterkeyhint = undefined;\n    this.placeholder = 'Search';\n    this.searchIcon = undefined;\n    this.showCancelButton = 'never';\n    this.showClearButton = 'always';\n    this.spellcheck = false;\n    this.type = 'search';\n    this.value = '';\n  }\n  debounceChanged() {\n    const { ionInput, debounce, originalIonInput } = this;\n    /**\n     * If debounce is undefined, we have to manually revert the ionInput emitter in case\n     * debounce used to be set to a number. Otherwise, the event would stay debounced.\n     */\n    this.ionInput = debounce === undefined ? originalIonInput !== null && originalIonInput !== void 0 ? originalIonInput : ionInput : debounceEvent(ionInput, debounce);\n  }\n  valueChanged() {\n    const inputEl = this.nativeInput;\n    const value = this.getValue();\n    if (inputEl && inputEl.value !== value) {\n      inputEl.value = value;\n    }\n  }\n  showCancelButtonChanged() {\n    requestAnimationFrame(() => {\n      this.positionElements();\n      forceUpdate(this);\n    });\n  }\n  connectedCallback() {\n    this.emitStyle();\n  }\n  componentDidLoad() {\n    this.originalIonInput = this.ionInput;\n    this.positionElements();\n    this.debounceChanged();\n    setTimeout(() => {\n      this.noAnimate = false;\n    }, 300);\n  }\n  emitStyle() {\n    this.ionStyle.emit({\n      searchbar: true,\n    });\n  }\n  /**\n   * Sets focus on the specified `ion-searchbar`. Use this method instead of the global\n   * `input.focus()`.\n   */\n  async setFocus() {\n    if (this.nativeInput) {\n      this.nativeInput.focus();\n    }\n  }\n  /**\n   * Returns the native `<input>` element used under the hood.\n   */\n  getInputElement() {\n    return Promise.resolve(this.nativeInput);\n  }\n  /**\n   * Emits an `ionChange` event.\n   *\n   * This API should be called for user committed changes.\n   * This API should not be used for external value changes.\n   */\n  emitValueChange(event) {\n    const { value } = this;\n    // Checks for both null and undefined values\n    const newValue = value == null ? value : value.toString();\n    // Emitting a value change should update the internal state for tracking the focused value\n    this.focusedValue = newValue;\n    this.ionChange.emit({ value: newValue, event });\n  }\n  /**\n   * Emits an `ionInput` event.\n   */\n  emitInputChange(event) {\n    const { value } = this;\n    this.ionInput.emit({ value, event });\n  }\n  /**\n   * Positions the input search icon, placeholder, and the cancel button\n   * based on the input value and if it is focused. (ios only)\n   */\n  positionElements() {\n    const value = this.getValue();\n    const prevAlignLeft = this.shouldAlignLeft;\n    const mode = getIonMode(this);\n    const shouldAlignLeft = !this.animated || value.trim() !== '' || !!this.focused;\n    this.shouldAlignLeft = shouldAlignLeft;\n    if (mode !== 'ios') {\n      return;\n    }\n    if (prevAlignLeft !== shouldAlignLeft) {\n      this.positionPlaceholder();\n    }\n    if (this.animated) {\n      this.positionCancelButton();\n    }\n  }\n  /**\n   * Positions the input placeholder\n   */\n  positionPlaceholder() {\n    const inputEl = this.nativeInput;\n    if (!inputEl) {\n      return;\n    }\n    const rtl = isRTL(this.el);\n    const iconEl = (this.el.shadowRoot || this.el).querySelector('.searchbar-search-icon');\n    if (this.shouldAlignLeft) {\n      inputEl.removeAttribute('style');\n      iconEl.removeAttribute('style');\n    }\n    else {\n      // Create a dummy span to get the placeholder width\n      const doc = document;\n      const tempSpan = doc.createElement('span');\n      tempSpan.innerText = this.placeholder || '';\n      doc.body.appendChild(tempSpan);\n      // Get the width of the span then remove it\n      raf(() => {\n        const textWidth = tempSpan.offsetWidth;\n        tempSpan.remove();\n        // Calculate the input padding\n        const inputLeft = 'calc(50% - ' + textWidth / 2 + 'px)';\n        // Calculate the icon margin\n        const iconLeft = 'calc(50% - ' + (textWidth / 2 + 30) + 'px)';\n        // Set the input padding start and icon margin start\n        if (rtl) {\n          inputEl.style.paddingRight = inputLeft;\n          iconEl.style.marginRight = iconLeft;\n        }\n        else {\n          inputEl.style.paddingLeft = inputLeft;\n          iconEl.style.marginLeft = iconLeft;\n        }\n      });\n    }\n  }\n  /**\n   * Show the iOS Cancel button on focus, hide it offscreen otherwise\n   */\n  positionCancelButton() {\n    const rtl = isRTL(this.el);\n    const cancelButton = (this.el.shadowRoot || this.el).querySelector('.searchbar-cancel-button');\n    const shouldShowCancel = this.shouldShowCancelButton();\n    if (cancelButton !== null && shouldShowCancel !== this.isCancelVisible) {\n      const cancelStyle = cancelButton.style;\n      this.isCancelVisible = shouldShowCancel;\n      if (shouldShowCancel) {\n        if (rtl) {\n          cancelStyle.marginLeft = '0';\n        }\n        else {\n          cancelStyle.marginRight = '0';\n        }\n      }\n      else {\n        const offset = cancelButton.offsetWidth;\n        if (offset > 0) {\n          if (rtl) {\n            cancelStyle.marginLeft = -offset + 'px';\n          }\n          else {\n            cancelStyle.marginRight = -offset + 'px';\n          }\n        }\n      }\n    }\n  }\n  getValue() {\n    return this.value || '';\n  }\n  hasValue() {\n    return this.getValue() !== '';\n  }\n  /**\n   * Determines whether or not the cancel button should be visible onscreen.\n   * Cancel button should be shown if one of two conditions applies:\n   * 1. `showCancelButton` is set to `always`.\n   * 2. `showCancelButton` is set to `focus`, and the searchbar has been focused.\n   */\n  shouldShowCancelButton() {\n    if (this.showCancelButton === 'never' || (this.showCancelButton === 'focus' && !this.focused)) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Determines whether or not the clear button should be visible onscreen.\n   * Clear button should be shown if one of two conditions applies:\n   * 1. `showClearButton` is set to `always`.\n   * 2. `showClearButton` is set to `focus`, and the searchbar has been focused.\n   */\n  shouldShowClearButton() {\n    if (this.showClearButton === 'never' || (this.showClearButton === 'focus' && !this.focused)) {\n      return false;\n    }\n    return true;\n  }\n  render() {\n    const { cancelButtonText } = this;\n    const animated = this.animated && config.getBoolean('animated', true);\n    const mode = getIonMode(this);\n    const clearIcon = this.clearIcon || (mode === 'ios' ? closeCircle : closeSharp);\n    const searchIcon = this.searchIcon || (mode === 'ios' ? searchOutline : searchSharp);\n    const shouldShowCancelButton = this.shouldShowCancelButton();\n    const cancelButton = this.showCancelButton !== 'never' && (h(\"button\", { \"aria-label\": cancelButtonText, \"aria-hidden\": shouldShowCancelButton ? undefined : 'true', type: \"button\", tabIndex: mode === 'ios' && !shouldShowCancelButton ? -1 : undefined, onMouseDown: this.onCancelSearchbar, onTouchStart: this.onCancelSearchbar, class: \"searchbar-cancel-button\" }, h(\"div\", { \"aria-hidden\": \"true\" }, mode === 'md' ? (h(\"ion-icon\", { \"aria-hidden\": \"true\", mode: mode, icon: this.cancelButtonIcon, lazy: false })) : (cancelButtonText))));\n    return (h(Host, { role: \"search\", \"aria-disabled\": this.disabled ? 'true' : null, class: createColorClasses(this.color, {\n        [mode]: true,\n        'searchbar-animated': animated,\n        'searchbar-disabled': this.disabled,\n        'searchbar-no-animate': animated && this.noAnimate,\n        'searchbar-has-value': this.hasValue(),\n        'searchbar-left-aligned': this.shouldAlignLeft,\n        'searchbar-has-focus': this.focused,\n        'searchbar-should-show-clear': this.shouldShowClearButton(),\n        'searchbar-should-show-cancel': this.shouldShowCancelButton(),\n      }) }, h(\"div\", { class: \"searchbar-input-container\" }, h(\"input\", { \"aria-label\": \"search text\", disabled: this.disabled, ref: (el) => (this.nativeInput = el), class: \"searchbar-input\", inputMode: this.inputmode, enterKeyHint: this.enterkeyhint, onInput: this.onInput, onChange: this.onChange, onBlur: this.onBlur, onFocus: this.onFocus, placeholder: this.placeholder, type: this.type, value: this.getValue(), autoComplete: this.autocomplete, autoCorrect: this.autocorrect, spellcheck: this.spellcheck }), mode === 'md' && cancelButton, h(\"ion-icon\", { \"aria-hidden\": \"true\", mode: mode, icon: searchIcon, lazy: false, class: \"searchbar-search-icon\" }), h(\"button\", { \"aria-label\": \"reset\", type: \"button\", \"no-blur\": true, class: \"searchbar-clear-button\", onPointerDown: (ev) => {\n        /**\n         * This prevents mobile browsers from\n         * blurring the input when the clear\n         * button is activated.\n         */\n        ev.preventDefault();\n      }, onClick: () => this.onClearInput(true) }, h(\"ion-icon\", { \"aria-hidden\": \"true\", mode: mode, icon: clearIcon, lazy: false, class: \"searchbar-clear-icon\" }))), mode === 'ios' && cancelButton));\n  }\n  static get is() { return \"ion-searchbar\"; }\n  static get encapsulation() { return \"scoped\"; }\n  static get originalStyleUrls() {\n    return {\n      \"ios\": [\"searchbar.ios.scss\"],\n      \"md\": [\"searchbar.md.scss\"]\n    };\n  }\n  static get styleUrls() {\n    return {\n      \"ios\": [\"searchbar.ios.css\"],\n      \"md\": [\"searchbar.md.css\"]\n    };\n  }\n  static get properties() {\n    return {\n      \"color\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"Color\",\n          \"resolved\": \"\\\"danger\\\" | \\\"dark\\\" | \\\"light\\\" | \\\"medium\\\" | \\\"primary\\\" | \\\"secondary\\\" | \\\"success\\\" | \\\"tertiary\\\" | \\\"warning\\\" | string & Record<never, never> | undefined\",\n          \"references\": {\n            \"Color\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"The color to use from your application's color palette.\\nDefault options are: `\\\"primary\\\"`, `\\\"secondary\\\"`, `\\\"tertiary\\\"`, `\\\"success\\\"`, `\\\"warning\\\"`, `\\\"danger\\\"`, `\\\"light\\\"`, `\\\"medium\\\"`, and `\\\"dark\\\"`.\\nFor more information on colors, see [theming](/docs/theming/basics).\"\n        },\n        \"attribute\": \"color\",\n        \"reflect\": true\n      },\n      \"animated\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, enable searchbar animation.\"\n        },\n        \"attribute\": \"animated\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      },\n      \"autocomplete\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"AutocompleteTypes\",\n          \"resolved\": \"\\\"name\\\" | \\\"email\\\" | \\\"tel\\\" | \\\"url\\\" | \\\"on\\\" | \\\"off\\\" | \\\"honorific-prefix\\\" | \\\"given-name\\\" | \\\"additional-name\\\" | \\\"family-name\\\" | \\\"honorific-suffix\\\" | \\\"nickname\\\" | \\\"username\\\" | \\\"new-password\\\" | \\\"current-password\\\" | \\\"one-time-code\\\" | \\\"organization-title\\\" | \\\"organization\\\" | \\\"street-address\\\" | \\\"address-line1\\\" | \\\"address-line2\\\" | \\\"address-line3\\\" | \\\"address-level4\\\" | \\\"address-level3\\\" | \\\"address-level2\\\" | \\\"address-level1\\\" | \\\"country\\\" | \\\"country-name\\\" | \\\"postal-code\\\" | \\\"cc-name\\\" | \\\"cc-given-name\\\" | \\\"cc-additional-name\\\" | \\\"cc-family-name\\\" | \\\"cc-number\\\" | \\\"cc-exp\\\" | \\\"cc-exp-month\\\" | \\\"cc-exp-year\\\" | \\\"cc-csc\\\" | \\\"cc-type\\\" | \\\"transaction-currency\\\" | \\\"transaction-amount\\\" | \\\"language\\\" | \\\"bday\\\" | \\\"bday-day\\\" | \\\"bday-month\\\" | \\\"bday-year\\\" | \\\"sex\\\" | \\\"tel-country-code\\\" | \\\"tel-national\\\" | \\\"tel-area-code\\\" | \\\"tel-local\\\" | \\\"tel-extension\\\" | \\\"impp\\\" | \\\"photo\\\"\",\n          \"references\": {\n            \"AutocompleteTypes\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Set the input's autocomplete property.\"\n        },\n        \"attribute\": \"autocomplete\",\n        \"reflect\": false,\n        \"defaultValue\": \"'off'\"\n      },\n      \"autocorrect\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"'on' | 'off'\",\n          \"resolved\": \"\\\"off\\\" | \\\"on\\\"\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Set the input's autocorrect property.\"\n        },\n        \"attribute\": \"autocorrect\",\n        \"reflect\": false,\n        \"defaultValue\": \"'off'\"\n      },\n      \"cancelButtonIcon\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"string\",\n          \"resolved\": \"string\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Set the cancel button icon. Only applies to `md` mode.\\nDefaults to `arrow-back-sharp`.\"\n        },\n        \"attribute\": \"cancel-button-icon\",\n        \"reflect\": false,\n        \"defaultValue\": \"config.get('backButtonIcon', arrowBackSharp) as string\"\n      },\n      \"cancelButtonText\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"string\",\n          \"resolved\": \"string\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Set the the cancel button text. Only applies to `ios` mode.\"\n        },\n        \"attribute\": \"cancel-button-text\",\n        \"reflect\": false,\n        \"defaultValue\": \"'Cancel'\"\n      },\n      \"clearIcon\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"string\",\n          \"resolved\": \"string | undefined\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Set the clear icon. Defaults to `close-circle` for `ios` and `close-sharp` for `md`.\"\n        },\n        \"attribute\": \"clear-icon\",\n        \"reflect\": false\n      },\n      \"debounce\": {\n        \"type\": \"number\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"number\",\n          \"resolved\": \"number | undefined\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Set the amount of time, in milliseconds, to wait to trigger the `ionInput` event after each keystroke.\"\n        },\n        \"attribute\": \"debounce\",\n        \"reflect\": false\n      },\n      \"disabled\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, the user cannot interact with the input.\"\n        },\n        \"attribute\": \"disabled\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      },\n      \"inputmode\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search'\",\n          \"resolved\": \"\\\"decimal\\\" | \\\"email\\\" | \\\"none\\\" | \\\"numeric\\\" | \\\"search\\\" | \\\"tel\\\" | \\\"text\\\" | \\\"url\\\" | undefined\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"A hint to the browser for which keyboard to display.\\nPossible values: `\\\"none\\\"`, `\\\"text\\\"`, `\\\"tel\\\"`, `\\\"url\\\"`,\\n`\\\"email\\\"`, `\\\"numeric\\\"`, `\\\"decimal\\\"`, and `\\\"search\\\"`.\"\n        },\n        \"attribute\": \"inputmode\",\n        \"reflect\": false\n      },\n      \"enterkeyhint\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send'\",\n          \"resolved\": \"\\\"done\\\" | \\\"enter\\\" | \\\"go\\\" | \\\"next\\\" | \\\"previous\\\" | \\\"search\\\" | \\\"send\\\" | undefined\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"A hint to the browser for which enter key to display.\\nPossible values: `\\\"enter\\\"`, `\\\"done\\\"`, `\\\"go\\\"`, `\\\"next\\\"`,\\n`\\\"previous\\\"`, `\\\"search\\\"`, and `\\\"send\\\"`.\"\n        },\n        \"attribute\": \"enterkeyhint\",\n        \"reflect\": false\n      },\n      \"placeholder\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"string\",\n          \"resolved\": \"string\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Set the input's placeholder.\\n`placeholder` can accept either plaintext or HTML as a string.\\nTo display characters normally reserved for HTML, they\\nmust be escaped. For example `<Ionic>` would become\\n`&lt;Ionic&gt;`\\n\\nFor more information: [Security Documentation](https://ionicframework.com/docs/faq/security)\"\n        },\n        \"attribute\": \"placeholder\",\n        \"reflect\": false,\n        \"defaultValue\": \"'Search'\"\n      },\n      \"searchIcon\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"string\",\n          \"resolved\": \"string | undefined\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"The icon to use as the search icon. Defaults to `search-outline` in\\n`ios` mode and `search-sharp` in `md` mode.\"\n        },\n        \"attribute\": \"search-icon\",\n        \"reflect\": false\n      },\n      \"showCancelButton\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"'never' | 'focus' | 'always'\",\n          \"resolved\": \"\\\"always\\\" | \\\"focus\\\" | \\\"never\\\"\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Sets the behavior for the cancel button. Defaults to `\\\"never\\\"`.\\nSetting to `\\\"focus\\\"` shows the cancel button on focus.\\nSetting to `\\\"never\\\"` hides the cancel button.\\nSetting to `\\\"always\\\"` shows the cancel button regardless\\nof focus state.\"\n        },\n        \"attribute\": \"show-cancel-button\",\n        \"reflect\": false,\n        \"defaultValue\": \"'never'\"\n      },\n      \"showClearButton\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"'never' | 'focus' | 'always'\",\n          \"resolved\": \"\\\"always\\\" | \\\"focus\\\" | \\\"never\\\"\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Sets the behavior for the clear button. Defaults to `\\\"focus\\\"`.\\nSetting to `\\\"focus\\\"` shows the clear button on focus if the\\ninput is not empty.\\nSetting to `\\\"never\\\"` hides the clear button.\\nSetting to `\\\"always\\\"` shows the clear button regardless\\nof focus state, but only if the input is not empty.\"\n        },\n        \"attribute\": \"show-clear-button\",\n        \"reflect\": false,\n        \"defaultValue\": \"'always'\"\n      },\n      \"spellcheck\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, enable spellcheck on the input.\"\n        },\n        \"attribute\": \"spellcheck\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      },\n      \"type\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"'text' | 'password' | 'email' | 'number' | 'search' | 'tel' | 'url'\",\n          \"resolved\": \"\\\"email\\\" | \\\"number\\\" | \\\"password\\\" | \\\"search\\\" | \\\"tel\\\" | \\\"text\\\" | \\\"url\\\"\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Set the type of the input.\"\n        },\n        \"attribute\": \"type\",\n        \"reflect\": false,\n        \"defaultValue\": \"'search'\"\n      },\n      \"value\": {\n        \"type\": \"string\",\n        \"mutable\": true,\n        \"complexType\": {\n          \"original\": \"string | null\",\n          \"resolved\": \"null | string | undefined\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"the value of the searchbar.\"\n        },\n        \"attribute\": \"value\",\n        \"reflect\": false,\n        \"defaultValue\": \"''\"\n      }\n    };\n  }\n  static get states() {\n    return {\n      \"focused\": {},\n      \"noAnimate\": {}\n    };\n  }\n  static get events() {\n    return [{\n        \"method\": \"ionInput\",\n        \"name\": \"ionInput\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the `value` of the `ion-searchbar` element has changed.\"\n        },\n        \"complexType\": {\n          \"original\": \"SearchbarInputEventDetail\",\n          \"resolved\": \"SearchbarInputEventDetail\",\n          \"references\": {\n            \"SearchbarInputEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"./searchbar-interface\"\n            }\n          }\n        }\n      }, {\n        \"method\": \"ionChange\",\n        \"name\": \"ionChange\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"The `ionChange` event is fired for `<ion-searchbar>` elements when the user\\nmodifies the element's value. Unlike the `ionInput` event, the `ionChange`\\nevent is not necessarily fired for each alteration to an element's value.\\n\\nThe `ionChange` event is fired when the value has been committed\\nby the user. This can happen when the element loses focus or\\nwhen the \\\"Enter\\\" key is pressed. `ionChange` can also fire\\nwhen clicking the clear or cancel buttons.\"\n        },\n        \"complexType\": {\n          \"original\": \"SearchbarChangeEventDetail\",\n          \"resolved\": \"SearchbarChangeEventDetail\",\n          \"references\": {\n            \"SearchbarChangeEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"./searchbar-interface\"\n            }\n          }\n        }\n      }, {\n        \"method\": \"ionCancel\",\n        \"name\": \"ionCancel\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the cancel button is clicked.\"\n        },\n        \"complexType\": {\n          \"original\": \"void\",\n          \"resolved\": \"void\",\n          \"references\": {}\n        }\n      }, {\n        \"method\": \"ionClear\",\n        \"name\": \"ionClear\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the clear input button is clicked.\"\n        },\n        \"complexType\": {\n          \"original\": \"void\",\n          \"resolved\": \"void\",\n          \"references\": {}\n        }\n      }, {\n        \"method\": \"ionBlur\",\n        \"name\": \"ionBlur\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the input loses focus.\"\n        },\n        \"complexType\": {\n          \"original\": \"void\",\n          \"resolved\": \"void\",\n          \"references\": {}\n        }\n      }, {\n        \"method\": \"ionFocus\",\n        \"name\": \"ionFocus\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the input has focus.\"\n        },\n        \"complexType\": {\n          \"original\": \"void\",\n          \"resolved\": \"void\",\n          \"references\": {}\n        }\n      }, {\n        \"method\": \"ionStyle\",\n        \"name\": \"ionStyle\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }],\n          \"text\": \"Emitted when the styles change.\"\n        },\n        \"complexType\": {\n          \"original\": \"StyleEventDetail\",\n          \"resolved\": \"StyleEventDetail\",\n          \"references\": {\n            \"StyleEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        }\n      }];\n  }\n  static get methods() {\n    return {\n      \"setFocus\": {\n        \"complexType\": {\n          \"signature\": \"() => Promise<void>\",\n          \"parameters\": [],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<void>\"\n        },\n        \"docs\": {\n          \"text\": \"Sets focus on the specified `ion-searchbar`. Use this method instead of the global\\n`input.focus()`.\",\n          \"tags\": []\n        }\n      },\n      \"getInputElement\": {\n        \"complexType\": {\n          \"signature\": \"() => Promise<HTMLInputElement>\",\n          \"parameters\": [],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"HTMLInputElement\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<HTMLInputElement>\"\n        },\n        \"docs\": {\n          \"text\": \"Returns the native `<input>` element used under the hood.\",\n          \"tags\": []\n        }\n      }\n    };\n  }\n  static get elementRef() { return \"el\"; }\n  static get watchers() {\n    return [{\n        \"propName\": \"debounce\",\n        \"methodName\": \"debounceChanged\"\n      }, {\n        \"propName\": \"value\",\n        \"methodName\": \"valueChanged\"\n      }, {\n        \"propName\": \"showCancelButton\",\n        \"methodName\": \"showCancelButtonChanged\"\n      }];\n  }\n}\n"],"names":[],"sourceRoot":""}