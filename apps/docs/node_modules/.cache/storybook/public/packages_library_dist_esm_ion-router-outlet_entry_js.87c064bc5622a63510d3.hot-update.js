"use strict";
globalThis["webpackHotUpdateatomium_docs"]("packages_library_dist_esm_ion-router-outlet_entry_js",{

/***/ "../../packages/library/dist/esm/index-29effbee.js":
/*!*********************************************************!*\
  !*** ../../packages/library/dist/esm/index-29effbee.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "L": () => (/* binding */ LIFECYCLE_WILL_UNLOAD),
/* harmony export */   "a": () => (/* binding */ LIFECYCLE_WILL_LEAVE),
/* harmony export */   "b": () => (/* binding */ LIFECYCLE_DID_LEAVE),
/* harmony export */   "d": () => (/* binding */ deepReady),
/* harmony export */   "g": () => (/* binding */ getIonPageElement),
/* harmony export */   "l": () => (/* binding */ lifecycle),
/* harmony export */   "s": () => (/* binding */ setPageHidden),
/* harmony export */   "t": () => (/* binding */ transition)
/* harmony export */ });
/* harmony import */ var _index_77c1beb5_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-77c1beb5.js */ "../../packages/library/dist/esm/index-77c1beb5.js");
/* harmony import */ var _helpers_937ea457_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers-937ea457.js */ "../../packages/library/dist/esm/helpers-937ea457.js");



/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const LIFECYCLE_WILL_ENTER = 'ionViewWillEnter';
const LIFECYCLE_DID_ENTER = 'ionViewDidEnter';
const LIFECYCLE_WILL_LEAVE = 'ionViewWillLeave';
const LIFECYCLE_DID_LEAVE = 'ionViewDidLeave';
const LIFECYCLE_WILL_UNLOAD = 'ionViewWillUnload';

/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const iosTransitionAnimation = () => Promise.all(/*! import() */[__webpack_require__.e("packages_library_dist_esm_animation-45b29945_js"), __webpack_require__.e("packages_library_dist_esm_ios_transition-5b527642_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ./ios.transition-5b527642.js */ "../../packages/library/dist/esm/ios.transition-5b527642.js"));
const mdTransitionAnimation = () => Promise.all(/*! import() */[__webpack_require__.e("packages_library_dist_esm_animation-45b29945_js"), __webpack_require__.e("packages_library_dist_esm_md_transition-a0f167b1_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ./md.transition-a0f167b1.js */ "../../packages/library/dist/esm/md.transition-a0f167b1.js"));
// TODO(FW-2832): types
const transition = opts => {
  return new Promise((resolve, reject) => {
    (0,_index_77c1beb5_js__WEBPACK_IMPORTED_MODULE_0__.w)(() => {
      beforeTransition(opts);
      runTransition(opts).then(result => {
        if (result.animation) {
          result.animation.destroy();
        }
        afterTransition(opts);
        resolve(result);
      }, error => {
        afterTransition(opts);
        reject(error);
      });
    });
  });
};
const beforeTransition = opts => {
  const enteringEl = opts.enteringEl;
  const leavingEl = opts.leavingEl;
  setZIndex(enteringEl, leavingEl, opts.direction);
  if (opts.showGoBack) {
    enteringEl.classList.add('can-go-back');
  } else {
    enteringEl.classList.remove('can-go-back');
  }
  setPageHidden(enteringEl, false);
  /**
   * When transitioning, the page should not
   * respond to click events. This resolves small
   * issues like users double tapping the ion-back-button.
   * These pointer events are removed in `afterTransition`.
   */
  enteringEl.style.setProperty('pointer-events', 'none');
  if (leavingEl) {
    setPageHidden(leavingEl, false);
    leavingEl.style.setProperty('pointer-events', 'none');
  }
};
const runTransition = async opts => {
  const animationBuilder = await getAnimationBuilder(opts);
  const ani = animationBuilder && _index_77c1beb5_js__WEBPACK_IMPORTED_MODULE_0__.B.isBrowser ? animation(animationBuilder, opts) : noAnimation(opts); // fast path for no animation
  return ani;
};
const afterTransition = opts => {
  const enteringEl = opts.enteringEl;
  const leavingEl = opts.leavingEl;
  enteringEl.classList.remove('ion-page-invisible');
  enteringEl.style.removeProperty('pointer-events');
  if (leavingEl !== undefined) {
    leavingEl.classList.remove('ion-page-invisible');
    leavingEl.style.removeProperty('pointer-events');
  }
};
const getAnimationBuilder = async opts => {
  if (!opts.leavingEl || !opts.animated || opts.duration === 0) {
    return undefined;
  }
  if (opts.animationBuilder) {
    return opts.animationBuilder;
  }
  const getAnimation = opts.mode === 'ios' ? (await iosTransitionAnimation()).iosTransitionAnimation : (await mdTransitionAnimation()).mdTransitionAnimation;
  return getAnimation;
};
const animation = async (animationBuilder, opts) => {
  await waitForReady(opts, true);
  const trans = animationBuilder(opts.baseEl, opts);
  fireWillEvents(opts.enteringEl, opts.leavingEl);
  const didComplete = await playTransition(trans, opts);
  if (opts.progressCallback) {
    opts.progressCallback(undefined);
  }
  if (didComplete) {
    fireDidEvents(opts.enteringEl, opts.leavingEl);
  }
  return {
    hasCompleted: didComplete,
    animation: trans
  };
};
const noAnimation = async opts => {
  const enteringEl = opts.enteringEl;
  const leavingEl = opts.leavingEl;
  await waitForReady(opts, false);
  fireWillEvents(enteringEl, leavingEl);
  fireDidEvents(enteringEl, leavingEl);
  return {
    hasCompleted: true
  };
};
const waitForReady = async (opts, defaultDeep) => {
  const deep = opts.deepWait !== undefined ? opts.deepWait : defaultDeep;
  if (deep) {
    await Promise.all([deepReady(opts.enteringEl), deepReady(opts.leavingEl)]);
  }
  await notifyViewReady(opts.viewIsReady, opts.enteringEl);
};
const notifyViewReady = async (viewIsReady, enteringEl) => {
  if (viewIsReady) {
    await viewIsReady(enteringEl);
  }
};
const playTransition = (trans, opts) => {
  const progressCallback = opts.progressCallback;
  const promise = new Promise(resolve => {
    trans.onFinish(currentStep => resolve(currentStep === 1));
  });
  // cool, let's do this, start the transition
  if (progressCallback) {
    // this is a swipe to go back, just get the transition progress ready
    // kick off the swipe animation start
    trans.progressStart(true);
    progressCallback(trans);
  } else {
    // only the top level transition should actually start "play"
    // kick it off and let it play through
    // ******** DOM WRITE ****************
    trans.play();
  }
  // create a callback for when the animation is done
  return promise;
};
const fireWillEvents = (enteringEl, leavingEl) => {
  lifecycle(leavingEl, LIFECYCLE_WILL_LEAVE);
  lifecycle(enteringEl, LIFECYCLE_WILL_ENTER);
};
const fireDidEvents = (enteringEl, leavingEl) => {
  lifecycle(enteringEl, LIFECYCLE_DID_ENTER);
  lifecycle(leavingEl, LIFECYCLE_DID_LEAVE);
};
const lifecycle = (el, eventName) => {
  if (el) {
    const ev = new CustomEvent(eventName, {
      bubbles: false,
      cancelable: false
    });
    el.dispatchEvent(ev);
  }
};
const deepReady = async el => {
  const element = el;
  if (element) {
    if (element.componentOnReady != null) {
      // eslint-disable-next-line custom-rules/no-component-on-ready-method
      const stencilEl = await element.componentOnReady();
      if (stencilEl != null) {
        return;
      }
      /**
       * Custom elements in Stencil will have __registerHost.
       */
    } else if (element.__registerHost != null) {
      /**
       * Non-lazy loaded custom elements need to wait
       * one frame for component to be loaded.
       */
      const waitForCustomElement = new Promise(resolve => (0,_helpers_937ea457_js__WEBPACK_IMPORTED_MODULE_1__.r)(resolve));
      await waitForCustomElement;
      return;
    }
    await Promise.all(Array.from(element.children).map(deepReady));
  }
};
const setPageHidden = (el, hidden) => {
  if (hidden) {
    el.setAttribute('aria-hidden', 'true');
    el.classList.add('ion-page-hidden');
  } else {
    el.hidden = false;
    el.removeAttribute('aria-hidden');
    el.classList.remove('ion-page-hidden');
  }
};
const setZIndex = (enteringEl, leavingEl, direction) => {
  if (enteringEl !== undefined) {
    enteringEl.style.zIndex = direction === 'back' ? '99' : '101';
  }
  if (leavingEl !== undefined) {
    leavingEl.style.zIndex = '100';
  }
};
const getIonPageElement = element => {
  if (element.classList.contains('ion-page')) {
    return element;
  }
  const ionPage = element.querySelector(':scope > .ion-page, :scope > ion-nav, :scope > ion-tabs');
  if (ionPage) {
    return ionPage;
  }
  // idk, return the original element so at least something animates and we don't have a null pointer
  return element;
};


/***/ }),

/***/ "../../packages/library/dist/esm/ion-router-outlet.entry.js":
/*!******************************************************************!*\
  !*** ../../packages/library/dist/esm/ion-router-outlet.entry.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ion_router_outlet": () => (/* binding */ RouterOutlet)
/* harmony export */ });
/* harmony import */ var _index_77c1beb5_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-77c1beb5.js */ "../../packages/library/dist/esm/index-77c1beb5.js");
/* harmony import */ var _ionic_global_98cbf2f6_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ionic-global-98cbf2f6.js */ "../../packages/library/dist/esm/ionic-global-98cbf2f6.js");
/* harmony import */ var _cubic_bezier_1aed87b5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cubic-bezier-1aed87b5.js */ "../../packages/library/dist/esm/cubic-bezier-1aed87b5.js");
/* harmony import */ var _framework_delegate_abaf8026_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./framework-delegate-abaf8026.js */ "../../packages/library/dist/esm/framework-delegate-abaf8026.js");
/* harmony import */ var _helpers_937ea457_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers-937ea457.js */ "../../packages/library/dist/esm/helpers-937ea457.js");
/* harmony import */ var _index_29effbee_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-29effbee.js */ "../../packages/library/dist/esm/index-29effbee.js");






const routeOutletCss = ":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;overflow:hidden;z-index:0}";
const RouterOutlet = class {
  constructor(hostRef) {
    (0,_index_77c1beb5_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.ionNavWillLoad = (0,_index_77c1beb5_js__WEBPACK_IMPORTED_MODULE_0__.d)(this, "ionNavWillLoad", 7);
    this.ionNavWillChange = (0,_index_77c1beb5_js__WEBPACK_IMPORTED_MODULE_0__.d)(this, "ionNavWillChange", 3);
    this.ionNavDidChange = (0,_index_77c1beb5_js__WEBPACK_IMPORTED_MODULE_0__.d)(this, "ionNavDidChange", 3);
    this.gestureOrAnimationInProgress = false;
    this.mode = (0,_ionic_global_98cbf2f6_js__WEBPACK_IMPORTED_MODULE_1__.g)(this);
    this.delegate = undefined;
    this.animated = true;
    this.animation = undefined;
    this.swipeHandler = undefined;
  }
  swipeHandlerChanged() {
    if (this.gesture) {
      this.gesture.enable(this.swipeHandler !== undefined);
    }
  }
  async connectedCallback() {
    const onStart = () => {
      this.gestureOrAnimationInProgress = true;
      if (this.swipeHandler) {
        this.swipeHandler.onStart();
      }
    };
    this.gesture = (await Promise.all(/*! import() */[__webpack_require__.e("packages_library_dist_esm_index-e65e72c8_js"), __webpack_require__.e("packages_library_dist_esm_swipe-back-fe7ee8ee_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ./swipe-back-fe7ee8ee.js */ "../../packages/library/dist/esm/swipe-back-fe7ee8ee.js"))).createSwipeBackGesture(this.el, () => !this.gestureOrAnimationInProgress && !!this.swipeHandler && this.swipeHandler.canStart(), () => onStart(), step => {
      var _a;
      return (_a = this.ani) === null || _a === void 0 ? void 0 : _a.progressStep(step);
    }, (shouldComplete, step, dur) => {
      if (this.ani) {
        this.ani.onFinish(() => {
          this.gestureOrAnimationInProgress = false;
          if (this.swipeHandler) {
            this.swipeHandler.onEnd(shouldComplete);
          }
        }, {
          oneTimeCallback: true
        });
        let newStepValue = shouldComplete ? -0.001 : 0.001;
        if (!shouldComplete) {
          this.ani.easing('cubic-bezier(1, 0, 0.68, 0.28)');
          newStepValue += (0,_cubic_bezier_1aed87b5_js__WEBPACK_IMPORTED_MODULE_3__.g)([0, 0], [1, 0], [0.68, 0.28], [1, 1], step)[0];
        } else {
          newStepValue += (0,_cubic_bezier_1aed87b5_js__WEBPACK_IMPORTED_MODULE_3__.g)([0, 0], [0.32, 0.72], [0, 1], [1, 1], step)[0];
        }
        this.ani.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);
      } else {
        this.gestureOrAnimationInProgress = false;
      }
    });
    this.swipeHandlerChanged();
  }
  componentWillLoad() {
    this.ionNavWillLoad.emit();
  }
  disconnectedCallback() {
    if (this.gesture) {
      this.gesture.destroy();
      this.gesture = undefined;
    }
  }
  async commit(enteringEl, leavingEl, opts) {
    const unlock = await this.lock();
    let changed = false;
    try {
      changed = await this.transition(enteringEl, leavingEl, opts);
    } catch (e) {
      console.error(e);
    }
    unlock();
    return changed;
  }
  async setRouteId(id, params, direction, animation) {
    const changed = await this.setRoot(id, params, {
      duration: direction === 'root' ? 0 : undefined,
      direction: direction === 'back' ? 'back' : 'forward',
      animationBuilder: animation
    });
    return {
      changed,
      element: this.activeEl
    };
  }
  async getRouteId() {
    const active = this.activeEl;
    return active ? {
      id: active.tagName,
      element: active,
      params: this.activeParams
    } : undefined;
  }
  async setRoot(component, params, opts) {
    if (this.activeComponent === component && (0,_helpers_937ea457_js__WEBPACK_IMPORTED_MODULE_4__.s)(params, this.activeParams)) {
      return false;
    }
    const leavingEl = this.activeEl;
    const enteringEl = await (0,_framework_delegate_abaf8026_js__WEBPACK_IMPORTED_MODULE_5__.a)(this.delegate, this.el, component, ['ion-page', 'ion-page-invisible'], params);
    this.activeComponent = component;
    this.activeEl = enteringEl;
    this.activeParams = params;
    await this.commit(enteringEl, leavingEl, opts);
    await (0,_framework_delegate_abaf8026_js__WEBPACK_IMPORTED_MODULE_5__.d)(this.delegate, leavingEl);
    return true;
  }
  async transition(enteringEl, leavingEl, opts = {}) {
    if (leavingEl === enteringEl) {
      return false;
    }
    this.ionNavWillChange.emit();
    const {
      el,
      mode
    } = this;
    const animated = this.animated && _ionic_global_98cbf2f6_js__WEBPACK_IMPORTED_MODULE_1__.c.getBoolean('animated', true);
    const animationBuilder = opts.animationBuilder || this.animation || _ionic_global_98cbf2f6_js__WEBPACK_IMPORTED_MODULE_1__.c.get('navAnimation');
    await (0,_index_29effbee_js__WEBPACK_IMPORTED_MODULE_2__.t)(Object.assign(Object.assign({
      mode,
      animated,
      enteringEl,
      leavingEl,
      baseEl: el,
      deepWait: (0,_helpers_937ea457_js__WEBPACK_IMPORTED_MODULE_4__.l)(el),
      progressCallback: opts.progressAnimation ? ani => {
        if (ani !== undefined && !this.gestureOrAnimationInProgress) {
          this.gestureOrAnimationInProgress = true;
          ani.onFinish(() => {
            this.gestureOrAnimationInProgress = false;
            if (this.swipeHandler) {
              this.swipeHandler.onEnd(false);
            }
          }, {
            oneTimeCallback: true
          });
          ani.progressEnd(0, 0, 0);
        } else {
          this.ani = ani;
        }
      } : undefined
    }, opts), {
      animationBuilder
    }));
    this.ionNavDidChange.emit();
    return true;
  }
  async lock() {
    const p = this.waitPromise;
    let resolve;
    this.waitPromise = new Promise(r => resolve = r);
    if (p !== undefined) {
      await p;
    }
    return resolve;
  }
  render() {
    return (0,_index_77c1beb5_js__WEBPACK_IMPORTED_MODULE_0__.h)("slot", null);
  }
  get el() {
    return (0,_index_77c1beb5_js__WEBPACK_IMPORTED_MODULE_0__.e)(this);
  }
  static get watchers() {
    return {
      "swipeHandler": ["swipeHandlerChanged"]
    };
  }
};
RouterOutlet.style = routeOutletCss;


/***/ })

});
//# sourceMappingURL=packages_library_dist_esm_ion-router-outlet_entry_js.87c064bc5622a63510d3.hot-update.js.map