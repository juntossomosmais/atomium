{"version":3,"file":"library_dist_esm_ion-range_entry_js.iframe.bundle.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/BA;ACAA;ACwBA;AACA;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAKA;AAIA;AAIA;AAIA;AAKA;AAKA;AAKA;AAIA;AAKA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;AAIA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;;AAEA;AAKA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAOA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAAA;AAAA;;AAEA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;;AAEA;AAGA;AACA;AACA;AACA;;AAEA;AAEA;;AAGA;AACA;AACA;AAEA;;AAGA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAQA;AACA;AACA;AAQA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;AA6aA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACj6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://atomium-storybook/../../node_modules/@ionic/core/dist/collection/utils/rtl/dir.js","webpack://atomium-storybook/../../node_modules/@ionic/core/dist/collection/utils/content/index.js","webpack://atomium-storybook/../../node_modules/@ionic/core/dist/collection/utils/logging/index.js","webpack://atomium-storybook/../../node_modules/@ionic/core/dist/collection/components/range/range.ios.css","webpack://atomium-storybook/../../node_modules/@ionic/core/dist/collection/components/range/range.md.css","webpack://atomium-storybook/../../node_modules/@ionic/core/dist/collection/components/range/range.js","webpack://atomium-storybook/../../node_modules/@ionic/core/dist/collection/utils/theme.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n/**\n * Returns `true` if the document or host element\n * has a `dir` set to `rtl`. The host value will always\n * take priority over the root document value.\n */\nexport const isRTL = (hostEl) => {\n  if (hostEl) {\n    if (hostEl.dir !== '') {\n      return hostEl.dir.toLowerCase() === 'rtl';\n    }\n  }\n  return (document === null || document === void 0 ? void 0 : document.dir.toLowerCase()) === 'rtl';\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { componentOnReady } from '../helpers';\nimport { printRequiredElementError } from '../logging';\nconst ION_CONTENT_TAG_NAME = 'ION-CONTENT';\nexport const ION_CONTENT_ELEMENT_SELECTOR = 'ion-content';\nexport const ION_CONTENT_CLASS_SELECTOR = '.ion-content-scroll-host';\n/**\n * Selector used for implementations reliant on `<ion-content>` for scroll event changes.\n *\n * Developers should use the `.ion-content-scroll-host` selector to target the element emitting\n * scroll events. With virtual scroll implementations this will be the host element for\n * the scroll viewport.\n */\nconst ION_CONTENT_SELECTOR = `${ION_CONTENT_ELEMENT_SELECTOR}, ${ION_CONTENT_CLASS_SELECTOR}`;\nexport const isIonContent = (el) => el.tagName === ION_CONTENT_TAG_NAME;\n/**\n * Waits for the element host fully initialize before\n * returning the inner scroll element.\n *\n * For `ion-content` the scroll target will be the result\n * of the `getScrollElement` function.\n *\n * For custom implementations it will be the element host\n * or a selector within the host, if supplied through `scrollTarget`.\n */\nexport const getScrollElement = async (el) => {\n  if (isIonContent(el)) {\n    await new Promise((resolve) => componentOnReady(el, resolve));\n    return el.getScrollElement();\n  }\n  return el;\n};\n/**\n * Queries the element matching the selector for IonContent.\n * See ION_CONTENT_SELECTOR for the selector used.\n */\nexport const findIonContent = (el) => {\n  /**\n   * First we try to query the custom scroll host selector in cases where\n   * the implementation is using an outer `ion-content` with an inner custom\n   * scroll container.\n   */\n  const customContentHost = el.querySelector(ION_CONTENT_CLASS_SELECTOR);\n  if (customContentHost) {\n    return customContentHost;\n  }\n  return el.querySelector(ION_CONTENT_SELECTOR);\n};\n/**\n * Queries the closest element matching the selector for IonContent.\n */\nexport const findClosestIonContent = (el) => {\n  return el.closest(ION_CONTENT_SELECTOR);\n};\n/**\n * Scrolls to the top of the element. If an `ion-content` is found, it will scroll\n * using the public API `scrollToTop` with a duration.\n */\n// TODO(FW-2832): type\nexport const scrollToTop = (el, durationMs) => {\n  if (isIonContent(el)) {\n    const content = el;\n    return content.scrollToTop(durationMs);\n  }\n  return Promise.resolve(el.scrollTo({\n    top: 0,\n    left: 0,\n    behavior: durationMs > 0 ? 'smooth' : 'auto',\n  }));\n};\n/**\n * Scrolls by a specified X/Y distance in the component. If an `ion-content` is found, it will scroll\n * using the public API `scrollByPoint` with a duration.\n */\nexport const scrollByPoint = (el, x, y, durationMs) => {\n  if (isIonContent(el)) {\n    const content = el;\n    return content.scrollByPoint(x, y, durationMs);\n  }\n  return Promise.resolve(el.scrollBy({\n    top: y,\n    left: x,\n    behavior: durationMs > 0 ? 'smooth' : 'auto',\n  }));\n};\n/**\n * Prints an error informing developers that an implementation requires an element to be used\n * within either the `ion-content` selector or the `.ion-content-scroll-host` class.\n */\nexport const printIonContentErrorMsg = (el) => {\n  return printRequiredElementError(el, ION_CONTENT_ELEMENT_SELECTOR);\n};\n/**\n * Several components in Ionic need to prevent scrolling\n * during a gesture (card modal, range, item sliding, etc).\n * Use this utility to account for ion-content and custom content hosts.\n */\nexport const disableContentScrollY = (contentEl) => {\n  if (isIonContent(contentEl)) {\n    const ionContent = contentEl;\n    const initialScrollY = ionContent.scrollY;\n    ionContent.scrollY = false;\n    /**\n     * This should be passed into resetContentScrollY\n     * so that we can revert ion-content's scrollY to the\n     * correct state. For example, if scrollY = false\n     * initially, we do not want to enable scrolling\n     * when we call resetContentScrollY.\n     */\n    return initialScrollY;\n  }\n  else {\n    contentEl.style.setProperty('overflow', 'hidden');\n    return true;\n  }\n};\nexport const resetContentScrollY = (contentEl, initialScrollY) => {\n  if (isIonContent(contentEl)) {\n    contentEl.scrollY = initialScrollY;\n  }\n  else {\n    contentEl.style.removeProperty('overflow');\n  }\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n/**\n * Logs a warning to the console with an Ionic prefix\n * to indicate the library that is warning the developer.\n *\n * @param message - The string message to be logged to the console.\n */\nexport const printIonWarning = (message, ...params) => {\n  return console.warn(`[Ionic Warning]: ${message}`, ...params);\n};\n/*\n * Logs an error to the console with an Ionic prefix\n * to indicate the library that is warning the developer.\n *\n * @param message - The string message to be logged to the console.\n * @param params - Additional arguments to supply to the console.error.\n */\nexport const printIonError = (message, ...params) => {\n  return console.error(`[Ionic Error]: ${message}`, ...params);\n};\n/**\n * Prints an error informing developers that an implementation requires an element to be used\n * within a specific selector.\n *\n * @param el The web component element this is requiring the element.\n * @param targetSelectors The selector or selectors that were not found.\n */\nexport const printRequiredElementError = (el, ...targetSelectors) => {\n  return console.error(`<${el.tagName.toLowerCase()}> must be used inside ${targetSelectors.join(' or ')}.`);\n};\n",":host {\n  /**\n   * @prop --bar-background: Background of the range bar\n   * @prop --bar-background-active: Background of the active range bar\n   * @prop --bar-height: Height of the range bar\n   * @prop --bar-border-radius: Border radius of the range bar\n   * @prop --height: Height of the range\n   * @prop --knob-background: Background of the range knob\n   * @prop --knob-border-radius: Border radius of the range knob\n   * @prop --knob-box-shadow: Box shadow of the range knob\n   * @prop --knob-size: Size of the range knob\n   * @prop --pin-background: Background of the range pin (only available in MD mode)\n   * @prop --pin-color: Color of the range pin (only available in MD mode)\n   */\n  --knob-handle-size: calc(var(--knob-size) * 2);\n  display: flex;\n  position: relative;\n  flex: 3;\n  align-items: center;\n  font-family: var(--ion-font-family, inherit);\n  user-select: none;\n  z-index: 2;\n}\n\n:host(.range-disabled) {\n  pointer-events: none;\n}\n\n::slotted(ion-label) {\n  flex: initial;\n}\n\n::slotted(ion-icon[slot]) {\n  font-size: 24px;\n}\n\n.range-slider {\n  position: relative;\n  flex: 1;\n  width: 100%;\n  height: var(--height);\n  contain: size layout style;\n  cursor: grab;\n  touch-action: pan-y;\n}\n\n:host(.range-pressed) .range-slider {\n  cursor: grabbing;\n}\n\n.range-pin {\n  position: absolute;\n  background: var(--ion-color-base);\n  color: var(--ion-color-contrast);\n  text-align: center;\n  box-sizing: border-box;\n}\n\n.range-knob-handle {\n  left: 0;\n  top: calc((var(--height) - var(--knob-handle-size)) / 2);\n  margin-left: calc(0px - var(--knob-handle-size) / 2);\n  position: absolute;\n  width: var(--knob-handle-size);\n  height: var(--knob-handle-size);\n  text-align: center;\n}\n[dir=rtl] .range-knob-handle, :host-context([dir=rtl]) .range-knob-handle {\n  left: unset;\n  right: unset;\n  right: 0;\n}\n\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  .range-knob-handle {\n    margin-left: unset;\n    -webkit-margin-start: calc(0px - var(--knob-handle-size) / 2);\n    margin-inline-start: calc(0px - var(--knob-handle-size) / 2);\n  }\n}\n[dir=rtl] .range-knob-handle, :host-context([dir=rtl]) .range-knob-handle {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n.range-knob-handle:active, .range-knob-handle:focus {\n  outline: none;\n}\n\n.range-bar {\n  border-radius: var(--bar-border-radius);\n  left: 0;\n  top: calc((var(--height) - var(--bar-height)) / 2);\n  position: absolute;\n  width: 100%;\n  height: var(--bar-height);\n  background: var(--bar-background);\n  pointer-events: none;\n}\n[dir=rtl] .range-bar, :host-context([dir=rtl]) .range-bar {\n  left: unset;\n  right: unset;\n  right: 0;\n}\n\n[dir=rtl] .range-bar, :host-context([dir=rtl]) .range-bar {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n.range-knob {\n  border-radius: var(--knob-border-radius);\n  left: calc(50% - var(--knob-size) / 2);\n  top: calc(50% - var(--knob-size) / 2);\n  position: absolute;\n  width: var(--knob-size);\n  height: var(--knob-size);\n  background: var(--knob-background);\n  box-shadow: var(--knob-box-shadow);\n  z-index: 2;\n  pointer-events: none;\n}\n[dir=rtl] .range-knob, :host-context([dir=rtl]) .range-knob {\n  left: unset;\n  right: unset;\n  right: calc(50% - var(--knob-size) / 2);\n}\n\n[dir=rtl] .range-knob, :host-context([dir=rtl]) .range-knob {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n:host(.range-pressed) .range-bar-active {\n  will-change: left, right;\n}\n\n:host(.in-item) {\n  width: 100%;\n}\n\n:host(.in-item) ::slotted(ion-label) {\n  align-self: center;\n}\n\n:host {\n  --knob-border-radius: 50%;\n  --knob-background: #ffffff;\n  --knob-box-shadow: 0 3px 1px rgba(0, 0, 0, 0.1), 0 4px 8px rgba(0, 0, 0, 0.13), 0 0 0 1px rgba(0, 0, 0, 0.02);\n  --knob-size: 28px;\n  --bar-height: 2px;\n  --bar-background: rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.1);\n  --bar-background-active: var(--ion-color-primary, #3880ff);\n  --bar-border-radius: 0;\n  --height: 42px;\n  padding-left: 16px;\n  padding-right: 16px;\n  padding-top: 8px;\n  padding-bottom: 8px;\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  :host {\n    padding-left: unset;\n    padding-right: unset;\n    -webkit-padding-start: 16px;\n    padding-inline-start: 16px;\n    -webkit-padding-end: 16px;\n    padding-inline-end: 16px;\n  }\n}\n\n:host(.ion-color) .range-bar-active,\n:host(.ion-color) .range-tick-active {\n  background: var(--ion-color-base);\n}\n\n::slotted([slot=start]) {\n  margin-left: 0;\n  margin-right: 16px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  ::slotted([slot=start]) {\n    margin-left: unset;\n    margin-right: unset;\n    -webkit-margin-start: 0;\n    margin-inline-start: 0;\n    -webkit-margin-end: 16px;\n    margin-inline-end: 16px;\n  }\n}\n\n::slotted([slot=end]) {\n  margin-left: 16px;\n  margin-right: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  ::slotted([slot=end]) {\n    margin-left: unset;\n    margin-right: unset;\n    -webkit-margin-start: 16px;\n    margin-inline-start: 16px;\n    -webkit-margin-end: 0;\n    margin-inline-end: 0;\n  }\n}\n\n:host(.range-has-pin) {\n  padding-top: 20px;\n}\n.range-bar-active {\n  bottom: 0;\n  width: auto;\n  background: var(--bar-background-active);\n}\n\n.range-tick {\n  margin-left: -1px;\n  border-radius: 0;\n  position: absolute;\n  top: 18px;\n  width: 2px;\n  height: 8px;\n  background: rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.1);\n  pointer-events: none;\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  .range-tick {\n    margin-left: unset;\n    -webkit-margin-start: -1px;\n    margin-inline-start: -1px;\n  }\n}\n\n.range-tick-active {\n  background: var(--bar-background-active);\n}\n\n.range-pin {\n  transform: translate3d(0,  28px,  0) scale(0.01);\n  padding-left: 8px;\n  padding-right: 8px;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  display: inline-block;\n  position: relative;\n  top: -20px;\n  min-width: 28px;\n  transition: transform 120ms ease;\n  background: transparent;\n  color: var(--ion-text-color, #000);\n  font-size: 12px;\n  text-align: center;\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  .range-pin {\n    padding-left: unset;\n    padding-right: unset;\n    -webkit-padding-start: 8px;\n    padding-inline-start: 8px;\n    -webkit-padding-end: 8px;\n    padding-inline-end: 8px;\n  }\n}\n\n.range-knob-pressed .range-pin,\n.range-knob-handle.ion-focused .range-pin {\n  transform: translate3d(0,  0,  0) scale(1);\n}\n\n:host(.range-disabled) {\n  opacity: 0.5;\n}",":host {\n  /**\n   * @prop --bar-background: Background of the range bar\n   * @prop --bar-background-active: Background of the active range bar\n   * @prop --bar-height: Height of the range bar\n   * @prop --bar-border-radius: Border radius of the range bar\n   * @prop --height: Height of the range\n   * @prop --knob-background: Background of the range knob\n   * @prop --knob-border-radius: Border radius of the range knob\n   * @prop --knob-box-shadow: Box shadow of the range knob\n   * @prop --knob-size: Size of the range knob\n   * @prop --pin-background: Background of the range pin (only available in MD mode)\n   * @prop --pin-color: Color of the range pin (only available in MD mode)\n   */\n  --knob-handle-size: calc(var(--knob-size) * 2);\n  display: flex;\n  position: relative;\n  flex: 3;\n  align-items: center;\n  font-family: var(--ion-font-family, inherit);\n  user-select: none;\n  z-index: 2;\n}\n\n:host(.range-disabled) {\n  pointer-events: none;\n}\n\n::slotted(ion-label) {\n  flex: initial;\n}\n\n::slotted(ion-icon[slot]) {\n  font-size: 24px;\n}\n\n.range-slider {\n  position: relative;\n  flex: 1;\n  width: 100%;\n  height: var(--height);\n  contain: size layout style;\n  cursor: grab;\n  touch-action: pan-y;\n}\n\n:host(.range-pressed) .range-slider {\n  cursor: grabbing;\n}\n\n.range-pin {\n  position: absolute;\n  background: var(--ion-color-base);\n  color: var(--ion-color-contrast);\n  text-align: center;\n  box-sizing: border-box;\n}\n\n.range-knob-handle {\n  left: 0;\n  top: calc((var(--height) - var(--knob-handle-size)) / 2);\n  margin-left: calc(0px - var(--knob-handle-size) / 2);\n  position: absolute;\n  width: var(--knob-handle-size);\n  height: var(--knob-handle-size);\n  text-align: center;\n}\n[dir=rtl] .range-knob-handle, :host-context([dir=rtl]) .range-knob-handle {\n  left: unset;\n  right: unset;\n  right: 0;\n}\n\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  .range-knob-handle {\n    margin-left: unset;\n    -webkit-margin-start: calc(0px - var(--knob-handle-size) / 2);\n    margin-inline-start: calc(0px - var(--knob-handle-size) / 2);\n  }\n}\n[dir=rtl] .range-knob-handle, :host-context([dir=rtl]) .range-knob-handle {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n.range-knob-handle:active, .range-knob-handle:focus {\n  outline: none;\n}\n\n.range-bar {\n  border-radius: var(--bar-border-radius);\n  left: 0;\n  top: calc((var(--height) - var(--bar-height)) / 2);\n  position: absolute;\n  width: 100%;\n  height: var(--bar-height);\n  background: var(--bar-background);\n  pointer-events: none;\n}\n[dir=rtl] .range-bar, :host-context([dir=rtl]) .range-bar {\n  left: unset;\n  right: unset;\n  right: 0;\n}\n\n[dir=rtl] .range-bar, :host-context([dir=rtl]) .range-bar {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n.range-knob {\n  border-radius: var(--knob-border-radius);\n  left: calc(50% - var(--knob-size) / 2);\n  top: calc(50% - var(--knob-size) / 2);\n  position: absolute;\n  width: var(--knob-size);\n  height: var(--knob-size);\n  background: var(--knob-background);\n  box-shadow: var(--knob-box-shadow);\n  z-index: 2;\n  pointer-events: none;\n}\n[dir=rtl] .range-knob, :host-context([dir=rtl]) .range-knob {\n  left: unset;\n  right: unset;\n  right: calc(50% - var(--knob-size) / 2);\n}\n\n[dir=rtl] .range-knob, :host-context([dir=rtl]) .range-knob {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n:host(.range-pressed) .range-bar-active {\n  will-change: left, right;\n}\n\n:host(.in-item) {\n  width: 100%;\n}\n\n:host(.in-item) ::slotted(ion-label) {\n  align-self: center;\n}\n\n:host {\n  --knob-border-radius: 50%;\n  --knob-background: var(--bar-background-active);\n  --knob-box-shadow: none;\n  --knob-size: 18px;\n  --bar-height: 2px;\n  --bar-background: rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.26);\n  --bar-background-active: var(--ion-color-primary, #3880ff);\n  --bar-border-radius: 0;\n  --height: 42px;\n  --pin-background: var(--ion-color-primary, #3880ff);\n  --pin-color: var(--ion-color-primary-contrast, #fff);\n  padding-left: 14px;\n  padding-right: 14px;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  font-size: 12px;\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  :host {\n    padding-left: unset;\n    padding-right: unset;\n    -webkit-padding-start: 14px;\n    padding-inline-start: 14px;\n    -webkit-padding-end: 14px;\n    padding-inline-end: 14px;\n  }\n}\n\n:host(.ion-color) .range-bar {\n  background: rgba(var(--ion-color-base-rgb), 0.26);\n}\n\n:host(.ion-color) .range-bar-active,\n:host(.ion-color) .range-knob,\n:host(.ion-color) .range-knob::before,\n:host(.ion-color) .range-pin,\n:host(.ion-color) .range-pin::before,\n:host(.ion-color) .range-tick {\n  background: var(--ion-color-base);\n  color: var(--ion-color-contrast);\n}\n\n::slotted([slot=start]) {\n  margin-left: 0;\n  margin-right: 14px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  ::slotted([slot=start]) {\n    margin-left: unset;\n    margin-right: unset;\n    -webkit-margin-start: 0;\n    margin-inline-start: 0;\n    -webkit-margin-end: 14px;\n    margin-inline-end: 14px;\n  }\n}\n\n::slotted([slot=end]) {\n  margin-left: 14px;\n  margin-right: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  ::slotted([slot=end]) {\n    margin-left: unset;\n    margin-right: unset;\n    -webkit-margin-start: 14px;\n    margin-inline-start: 14px;\n    -webkit-margin-end: 0;\n    margin-inline-end: 0;\n  }\n}\n\n:host(.range-has-pin) {\n  padding-top: 28px;\n}\n.range-bar-active {\n  bottom: 0;\n  width: auto;\n  background: var(--bar-background-active);\n}\n\n.range-knob {\n  transform: scale(0.67);\n  transition-duration: 120ms;\n  transition-property: transform, background-color, border;\n  transition-timing-function: ease;\n  z-index: 2;\n}\n.range-knob::before {\n  border-radius: 50%;\n  left: 0;\n  position: absolute;\n  width: var(--knob-size);\n  height: var(--knob-size);\n  transform: scale(1);\n  transition: 0.267s cubic-bezier(0, 0, 0.58, 1);\n  background: var(--knob-background);\n  content: \"\";\n  opacity: 0.13;\n  pointer-events: none;\n}\n[dir=rtl] .range-knob::before, :host-context([dir=rtl]) .range-knob::before {\n  left: unset;\n  right: unset;\n  right: 0;\n}\n\n.range-tick {\n  position: absolute;\n  top: calc((var(--height) - var(--bar-height)) / 2);\n  width: var(--bar-height);\n  height: var(--bar-height);\n  background: var(--bar-background-active);\n  z-index: 1;\n  pointer-events: none;\n}\n\n.range-tick-active {\n  background: transparent;\n}\n\n.range-pin {\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  border-radius: 50%;\n  transform: translate3d(0,  0,  0) scale(0.01);\n  display: inline-block;\n  position: relative;\n  min-width: 28px;\n  height: 28px;\n  transition: transform 120ms ease, background 120ms ease;\n  background: var(--pin-background);\n  color: var(--pin-color);\n  text-align: center;\n}\n.range-pin::before {\n  left: 50%;\n  top: 3px;\n  margin-left: -13px;\n  /* stylelint-disable-next-line property-disallowed-list */\n  border-radius: 50% 50% 50% 0;\n  position: absolute;\n  width: 26px;\n  height: 26px;\n  transform: rotate(-45deg);\n  transition: background 120ms ease;\n  background: var(--pin-background);\n  content: \"\";\n  z-index: -1;\n}\n[dir=rtl] .range-pin::before, :host-context([dir=rtl]) .range-pin::before {\n  left: unset;\n  right: unset;\n  right: 50%;\n}\n\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  .range-pin::before {\n    margin-left: unset;\n    -webkit-margin-start: -13px;\n    margin-inline-start: -13px;\n  }\n}\n[dir=rtl] .range-pin::before, :host-context([dir=rtl]) .range-pin::before {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n.range-knob-pressed .range-pin,\n.range-knob-handle.ion-focused .range-pin {\n  transform: translate3d(0,  -24px,  0) scale(1);\n}\n\n@media (any-hover: hover) {\n  .range-knob-handle:hover .range-knob:before {\n    transform: scale(2);\n    opacity: 0.13;\n  }\n}\n.range-knob-handle.ion-activated .range-knob:before, .range-knob-handle.ion-focused .range-knob:before, .range-knob-handle.range-knob-pressed .range-knob:before {\n  transform: scale(2);\n}\n.range-knob-handle.ion-focused .range-knob::before {\n  opacity: 0.13;\n}\n.range-knob-handle.ion-activated .range-knob::before, .range-knob-handle.range-knob-pressed .range-knob::before {\n  opacity: 0.25;\n}\n\n:host(:not(.range-has-pin)) .range-knob-pressed .range-knob,\n:host(:not(.range-has-pin)) .range-knob-handle.ion-focused .range-knob {\n  transform: scale(1);\n}\n\n:host(.range-disabled) .range-bar-active,\n:host(.range-disabled) .range-bar,\n:host(.range-disabled) .range-tick {\n  background-color: var(--ion-color-step-250, #bfbfbf);\n}\n\n:host(.range-disabled) .range-knob {\n  transform: scale(0.55);\n  outline: 5px solid #fff;\n  background-color: var(--ion-color-step-250, #bfbfbf);\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, h } from '@stencil/core';\nimport { getIonMode } from '../../global/ionic-global';\nimport { findClosestIonContent, disableContentScrollY, resetContentScrollY } from '../../utils/content';\nimport { inheritAriaAttributes, clamp, debounceEvent, getAriaLabel, renderHiddenInput } from '../../utils/helpers';\nimport { printIonWarning } from '../../utils/logging';\nimport { isRTL } from '../../utils/rtl';\nimport { createColorClasses, hostContext } from '../../utils/theme';\n// TODO(FW-2832): types\n/**\n * @virtualProp {\"ios\" | \"md\"} mode - The mode determines which platform styles to use.\n *\n * @slot start - Content is placed to the left of the range slider in LTR, and to the right in RTL.\n * @slot end - Content is placed to the right of the range slider in LTR, and to the left in RTL.\n *\n * @part tick - An inactive tick mark.\n * @part tick-active - An active tick mark.\n * @part pin - The counter that appears above a knob.\n * @part knob - The handle that is used to drag the range.\n * @part bar - The inactive part of the bar.\n * @part bar-active - The active part of the bar.\n */\nexport class Range {\n  constructor() {\n    this.didLoad = false;\n    this.noUpdate = false;\n    this.hasFocus = false;\n    this.inheritedAttributes = {};\n    this.contentEl = null;\n    this.initialContentScrollY = true;\n    this.ratioA = 0;\n    this.ratioB = 0;\n    /**\n     * How long, in milliseconds, to wait to trigger the\n     * `ionChange` event after each change in the range value.\n     * This also impacts form bindings such as `ngModel` or `v-model`.\n     */\n    this.debounce = 0;\n    // TODO: In Ionic Framework v6 this should initialize to this.rangeId like the other form components do.\n    /**\n     * The name of the control, which is submitted with the form data.\n     */\n    this.name = '';\n    /**\n     * Show two knobs.\n     */\n    this.dualKnobs = false;\n    /**\n     * Minimum integer value of the range.\n     */\n    this.min = 0;\n    /**\n     * Maximum integer value of the range.\n     */\n    this.max = 100;\n    /**\n     * If `true`, a pin with integer value is shown when the knob\n     * is pressed.\n     */\n    this.pin = false;\n    /**\n     * A callback used to format the pin text.\n     * By default the pin text is set to `Math.round(value)`.\n     */\n    this.pinFormatter = (value) => Math.round(value);\n    /**\n     * If `true`, the knob snaps to tick marks evenly spaced based\n     * on the step property value.\n     */\n    this.snaps = false;\n    /**\n     * Specifies the value granularity.\n     */\n    this.step = 1;\n    /**\n     * If `true`, tick marks are displayed based on the step value.\n     * Only applies when `snaps` is `true`.\n     */\n    this.ticks = true;\n    /**\n     * If `true`, the user cannot interact with the range.\n     */\n    this.disabled = false;\n    /**\n     * the value of the range.\n     */\n    this.value = 0;\n    this.clampBounds = (value) => {\n      return clamp(this.min, value, this.max);\n    };\n    this.ensureValueInBounds = (value) => {\n      if (this.dualKnobs) {\n        return {\n          lower: this.clampBounds(value.lower),\n          upper: this.clampBounds(value.upper),\n        };\n      }\n      else {\n        return this.clampBounds(value);\n      }\n    };\n    this.setupGesture = async () => {\n      const rangeSlider = this.rangeSlider;\n      if (rangeSlider) {\n        this.gesture = (await import('../../utils/gesture')).createGesture({\n          el: rangeSlider,\n          gestureName: 'range',\n          gesturePriority: 100,\n          threshold: 0,\n          onStart: (ev) => this.onStart(ev),\n          onMove: (ev) => this.onMove(ev),\n          onEnd: (ev) => this.onEnd(ev),\n        });\n        this.gesture.enable(!this.disabled);\n      }\n    };\n    this.handleKeyboard = (knob, isIncrease) => {\n      const { ensureValueInBounds } = this;\n      let step = this.step;\n      step = step > 0 ? step : 1;\n      step = step / (this.max - this.min);\n      if (!isIncrease) {\n        step *= -1;\n      }\n      if (knob === 'A') {\n        this.ratioA = clamp(0, this.ratioA + step, 1);\n      }\n      else {\n        this.ratioB = clamp(0, this.ratioB + step, 1);\n      }\n      this.ionKnobMoveStart.emit({ value: ensureValueInBounds(this.value) });\n      this.updateValue();\n      this.ionKnobMoveEnd.emit({ value: ensureValueInBounds(this.value) });\n    };\n    this.onBlur = () => {\n      if (this.hasFocus) {\n        this.hasFocus = false;\n        this.ionBlur.emit();\n        this.emitStyle();\n      }\n    };\n    this.onFocus = () => {\n      if (!this.hasFocus) {\n        this.hasFocus = true;\n        this.ionFocus.emit();\n        this.emitStyle();\n      }\n    };\n  }\n  debounceChanged() {\n    this.ionChange = debounceEvent(this.ionChange, this.debounce);\n  }\n  minChanged() {\n    if (!this.noUpdate) {\n      this.updateRatio();\n    }\n  }\n  maxChanged() {\n    if (!this.noUpdate) {\n      this.updateRatio();\n    }\n  }\n  activeBarStartChanged() {\n    const { activeBarStart } = this;\n    if (activeBarStart !== undefined) {\n      if (activeBarStart > this.max) {\n        printIonWarning(`Range: The value of activeBarStart (${activeBarStart}) is greater than the max (${this.max}). Valid values are greater than or equal to the min value and less than or equal to the max value.`, this.el);\n        this.activeBarStart = this.max;\n      }\n      else if (activeBarStart < this.min) {\n        printIonWarning(`Range: The value of activeBarStart (${activeBarStart}) is less than the min (${this.min}). Valid values are greater than or equal to the min value and less than or equal to the max value.`, this.el);\n        this.activeBarStart = this.min;\n      }\n    }\n  }\n  disabledChanged() {\n    if (this.gesture) {\n      this.gesture.enable(!this.disabled);\n    }\n    this.emitStyle();\n  }\n  valueChanged(value) {\n    if (!this.noUpdate) {\n      this.updateRatio();\n    }\n    value = this.ensureValueInBounds(value);\n    this.ionChange.emit({ value });\n  }\n  componentWillLoad() {\n    /**\n     * If user has custom ID set then we should\n     * not assign the default incrementing ID.\n     */\n    this.rangeId = this.el.hasAttribute('id') ? this.el.getAttribute('id') : `ion-r-${rangeIds++}`;\n    this.inheritedAttributes = inheritAriaAttributes(this.el);\n  }\n  componentDidLoad() {\n    this.setupGesture();\n    this.didLoad = true;\n  }\n  connectedCallback() {\n    this.updateRatio();\n    this.debounceChanged();\n    this.disabledChanged();\n    this.activeBarStartChanged();\n    /**\n     * If we have not yet rendered\n     * ion-range, then rangeSlider is not defined.\n     * But if we are moving ion-range via appendChild,\n     * then rangeSlider will be defined.\n     */\n    if (this.didLoad) {\n      this.setupGesture();\n    }\n    this.contentEl = findClosestIonContent(this.el);\n  }\n  disconnectedCallback() {\n    if (this.gesture) {\n      this.gesture.destroy();\n      this.gesture = undefined;\n    }\n  }\n  getValue() {\n    var _a;\n    const value = (_a = this.value) !== null && _a !== void 0 ? _a : 0;\n    if (this.dualKnobs) {\n      if (typeof value === 'object') {\n        return value;\n      }\n      return {\n        lower: 0,\n        upper: value,\n      };\n    }\n    else {\n      if (typeof value === 'object') {\n        return value.upper;\n      }\n      return value;\n    }\n  }\n  emitStyle() {\n    this.ionStyle.emit({\n      interactive: true,\n      'interactive-disabled': this.disabled,\n    });\n  }\n  onStart(detail) {\n    const { contentEl } = this;\n    if (contentEl) {\n      this.initialContentScrollY = disableContentScrollY(contentEl);\n    }\n    const rect = (this.rect = this.rangeSlider.getBoundingClientRect());\n    const currentX = detail.currentX;\n    // figure out which knob they started closer to\n    let ratio = clamp(0, (currentX - rect.left) / rect.width, 1);\n    if (isRTL(this.el)) {\n      ratio = 1 - ratio;\n    }\n    this.pressedKnob = !this.dualKnobs || Math.abs(this.ratioA - ratio) < Math.abs(this.ratioB - ratio) ? 'A' : 'B';\n    this.setFocus(this.pressedKnob);\n    // update the active knob's position\n    this.update(currentX);\n    this.ionKnobMoveStart.emit({ value: this.ensureValueInBounds(this.value) });\n  }\n  onMove(detail) {\n    this.update(detail.currentX);\n  }\n  onEnd(detail) {\n    const { contentEl, initialContentScrollY } = this;\n    if (contentEl) {\n      resetContentScrollY(contentEl, initialContentScrollY);\n    }\n    this.update(detail.currentX);\n    this.pressedKnob = undefined;\n    this.ionKnobMoveEnd.emit({ value: this.ensureValueInBounds(this.value) });\n  }\n  update(currentX) {\n    // figure out where the pointer is currently at\n    // update the knob being interacted with\n    const rect = this.rect;\n    let ratio = clamp(0, (currentX - rect.left) / rect.width, 1);\n    if (isRTL(this.el)) {\n      ratio = 1 - ratio;\n    }\n    if (this.snaps) {\n      // snaps the ratio to the current value\n      ratio = valueToRatio(ratioToValue(ratio, this.min, this.max, this.step), this.min, this.max);\n    }\n    // update which knob is pressed\n    if (this.pressedKnob === 'A') {\n      this.ratioA = ratio;\n    }\n    else {\n      this.ratioB = ratio;\n    }\n    // Update input value\n    this.updateValue();\n  }\n  get valA() {\n    return ratioToValue(this.ratioA, this.min, this.max, this.step);\n  }\n  get valB() {\n    return ratioToValue(this.ratioB, this.min, this.max, this.step);\n  }\n  get ratioLower() {\n    if (this.dualKnobs) {\n      return Math.min(this.ratioA, this.ratioB);\n    }\n    const { activeBarStart } = this;\n    if (activeBarStart == null) {\n      return 0;\n    }\n    return valueToRatio(activeBarStart, this.min, this.max);\n  }\n  get ratioUpper() {\n    if (this.dualKnobs) {\n      return Math.max(this.ratioA, this.ratioB);\n    }\n    return this.ratioA;\n  }\n  updateRatio() {\n    const value = this.getValue();\n    const { min, max } = this;\n    if (this.dualKnobs) {\n      this.ratioA = valueToRatio(value.lower, min, max);\n      this.ratioB = valueToRatio(value.upper, min, max);\n    }\n    else {\n      this.ratioA = valueToRatio(value, min, max);\n    }\n  }\n  updateValue() {\n    this.noUpdate = true;\n    const { valA, valB } = this;\n    this.value = !this.dualKnobs\n      ? valA\n      : {\n        lower: Math.min(valA, valB),\n        upper: Math.max(valA, valB),\n      };\n    this.noUpdate = false;\n  }\n  setFocus(knob) {\n    if (this.el.shadowRoot) {\n      const knobEl = this.el.shadowRoot.querySelector(knob === 'A' ? '.range-knob-a' : '.range-knob-b');\n      if (knobEl) {\n        knobEl.focus();\n      }\n    }\n  }\n  render() {\n    var _a;\n    const { min, max, step, el, handleKeyboard, pressedKnob, disabled, pin, ratioLower, ratioUpper, inheritedAttributes, rangeId, pinFormatter, } = this;\n    /**\n     * Look for external label, ion-label, or aria-labelledby.\n     * If none, see if user placed an aria-label on the host\n     * and use that instead.\n     */\n    let { labelText } = getAriaLabel(el, rangeId);\n    if (labelText === undefined || labelText === null) {\n      labelText = inheritedAttributes['aria-label'];\n    }\n    const mode = getIonMode(this);\n    let barStart = `${ratioLower * 100}%`;\n    let barEnd = `${100 - ratioUpper * 100}%`;\n    const rtl = isRTL(this.el);\n    const start = rtl ? 'right' : 'left';\n    const end = rtl ? 'left' : 'right';\n    const tickStyle = (tick) => {\n      return {\n        [start]: tick[start],\n      };\n    };\n    if (this.dualKnobs === false) {\n      /**\n       * When the value is less than the activeBarStart or the min value,\n       * the knob will display at the start of the active bar.\n       */\n      if (this.valA < ((_a = this.activeBarStart) !== null && _a !== void 0 ? _a : this.min)) {\n        /**\n         * Sets the bar positions relative to the upper and lower limits.\n         * Converts the ratio values into percentages, used as offsets for left/right styles.\n         *\n         * The ratioUpper refers to the knob position on the bar.\n         * The ratioLower refers to the end position of the active bar (the value).\n         */\n        barStart = `${ratioUpper * 100}%`;\n        barEnd = `${100 - ratioLower * 100}%`;\n      }\n      else {\n        /**\n         * Otherwise, the knob will display at the end of the active bar.\n         *\n         * The ratioLower refers to the start position of the active bar (the value).\n         * The ratioUpper refers to the knob position on the bar.\n         */\n        barStart = `${ratioLower * 100}%`;\n        barEnd = `${100 - ratioUpper * 100}%`;\n      }\n    }\n    const barStyle = {\n      [start]: barStart,\n      [end]: barEnd,\n    };\n    const ticks = [];\n    if (this.snaps && this.ticks) {\n      for (let value = min; value <= max; value += step) {\n        const ratio = valueToRatio(value, min, max);\n        const ratioMin = Math.min(ratioLower, ratioUpper);\n        const ratioMax = Math.max(ratioLower, ratioUpper);\n        const tick = {\n          ratio,\n          /**\n           * Sets the tick mark as active when the tick is between the min bounds and the knob.\n           * When using activeBarStart, the tick mark will be active between the knob and activeBarStart.\n           */\n          active: ratio >= ratioMin && ratio <= ratioMax,\n        };\n        tick[start] = `${ratio * 100}%`;\n        ticks.push(tick);\n      }\n    }\n    renderHiddenInput(true, el, this.name, JSON.stringify(this.getValue()), disabled);\n    return (h(Host, { onFocusin: this.onFocus, onFocusout: this.onBlur, id: rangeId, class: createColorClasses(this.color, {\n        [mode]: true,\n        'in-item': hostContext('ion-item', el),\n        'range-disabled': disabled,\n        'range-pressed': pressedKnob !== undefined,\n        'range-has-pin': pin,\n      }) }, h(\"slot\", { name: \"start\" }), h(\"div\", { class: \"range-slider\", ref: (rangeEl) => (this.rangeSlider = rangeEl) }, ticks.map((tick) => (h(\"div\", { style: tickStyle(tick), role: \"presentation\", class: {\n        'range-tick': true,\n        'range-tick-active': tick.active,\n      }, part: tick.active ? 'tick-active' : 'tick' }))), h(\"div\", { class: \"range-bar\", role: \"presentation\", part: \"bar\" }), h(\"div\", { class: \"range-bar range-bar-active\", role: \"presentation\", style: barStyle, part: \"bar-active\" }), renderKnob(rtl, {\n      knob: 'A',\n      pressed: pressedKnob === 'A',\n      value: this.valA,\n      ratio: this.ratioA,\n      pin,\n      pinFormatter,\n      disabled,\n      handleKeyboard,\n      min,\n      max,\n      labelText,\n    }), this.dualKnobs &&\n      renderKnob(rtl, {\n        knob: 'B',\n        pressed: pressedKnob === 'B',\n        value: this.valB,\n        ratio: this.ratioB,\n        pin,\n        pinFormatter,\n        disabled,\n        handleKeyboard,\n        min,\n        max,\n        labelText,\n      })), h(\"slot\", { name: \"end\" })));\n  }\n  static get is() { return \"ion-range\"; }\n  static get encapsulation() { return \"shadow\"; }\n  static get originalStyleUrls() {\n    return {\n      \"ios\": [\"range.ios.scss\"],\n      \"md\": [\"range.md.scss\"]\n    };\n  }\n  static get styleUrls() {\n    return {\n      \"ios\": [\"range.ios.css\"],\n      \"md\": [\"range.md.css\"]\n    };\n  }\n  static get properties() {\n    return {\n      \"color\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"Color\",\n          \"resolved\": \"\\\"danger\\\" | \\\"dark\\\" | \\\"light\\\" | \\\"medium\\\" | \\\"primary\\\" | \\\"secondary\\\" | \\\"success\\\" | \\\"tertiary\\\" | \\\"warning\\\" | string & Record<never, never> | undefined\",\n          \"references\": {\n            \"Color\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"The color to use from your application's color palette.\\nDefault options are: `\\\"primary\\\"`, `\\\"secondary\\\"`, `\\\"tertiary\\\"`, `\\\"success\\\"`, `\\\"warning\\\"`, `\\\"danger\\\"`, `\\\"light\\\"`, `\\\"medium\\\"`, and `\\\"dark\\\"`.\\nFor more information on colors, see [theming](/docs/theming/basics).\"\n        },\n        \"attribute\": \"color\",\n        \"reflect\": true\n      },\n      \"debounce\": {\n        \"type\": \"number\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"number\",\n          \"resolved\": \"number\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"How long, in milliseconds, to wait to trigger the\\n`ionChange` event after each change in the range value.\\nThis also impacts form bindings such as `ngModel` or `v-model`.\"\n        },\n        \"attribute\": \"debounce\",\n        \"reflect\": false,\n        \"defaultValue\": \"0\"\n      },\n      \"name\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"string\",\n          \"resolved\": \"string\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"The name of the control, which is submitted with the form data.\"\n        },\n        \"attribute\": \"name\",\n        \"reflect\": false,\n        \"defaultValue\": \"''\"\n      },\n      \"dualKnobs\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Show two knobs.\"\n        },\n        \"attribute\": \"dual-knobs\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      },\n      \"min\": {\n        \"type\": \"number\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"number\",\n          \"resolved\": \"number\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Minimum integer value of the range.\"\n        },\n        \"attribute\": \"min\",\n        \"reflect\": false,\n        \"defaultValue\": \"0\"\n      },\n      \"max\": {\n        \"type\": \"number\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"number\",\n          \"resolved\": \"number\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Maximum integer value of the range.\"\n        },\n        \"attribute\": \"max\",\n        \"reflect\": false,\n        \"defaultValue\": \"100\"\n      },\n      \"pin\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, a pin with integer value is shown when the knob\\nis pressed.\"\n        },\n        \"attribute\": \"pin\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      },\n      \"pinFormatter\": {\n        \"type\": \"unknown\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"PinFormatter\",\n          \"resolved\": \"(value: number) => string | number\",\n          \"references\": {\n            \"PinFormatter\": {\n              \"location\": \"import\",\n              \"path\": \"./range-interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"A callback used to format the pin text.\\nBy default the pin text is set to `Math.round(value)`.\"\n        },\n        \"defaultValue\": \"(value: number): number => Math.round(value)\"\n      },\n      \"snaps\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, the knob snaps to tick marks evenly spaced based\\non the step property value.\"\n        },\n        \"attribute\": \"snaps\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      },\n      \"step\": {\n        \"type\": \"number\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"number\",\n          \"resolved\": \"number\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Specifies the value granularity.\"\n        },\n        \"attribute\": \"step\",\n        \"reflect\": false,\n        \"defaultValue\": \"1\"\n      },\n      \"ticks\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, tick marks are displayed based on the step value.\\nOnly applies when `snaps` is `true`.\"\n        },\n        \"attribute\": \"ticks\",\n        \"reflect\": false,\n        \"defaultValue\": \"true\"\n      },\n      \"activeBarStart\": {\n        \"type\": \"number\",\n        \"mutable\": true,\n        \"complexType\": {\n          \"original\": \"number\",\n          \"resolved\": \"number | undefined\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"The start position of the range active bar. This feature is only available with a single knob (dualKnobs=\\\"false\\\").\\nValid values are greater than or equal to the min value and less than or equal to the max value.\"\n        },\n        \"attribute\": \"active-bar-start\",\n        \"reflect\": false\n      },\n      \"disabled\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, the user cannot interact with the range.\"\n        },\n        \"attribute\": \"disabled\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      },\n      \"value\": {\n        \"type\": \"number\",\n        \"mutable\": true,\n        \"complexType\": {\n          \"original\": \"RangeValue\",\n          \"resolved\": \"number | { lower: number; upper: number; }\",\n          \"references\": {\n            \"RangeValue\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"the value of the range.\"\n        },\n        \"attribute\": \"value\",\n        \"reflect\": false,\n        \"defaultValue\": \"0\"\n      }\n    };\n  }\n  static get states() {\n    return {\n      \"ratioA\": {},\n      \"ratioB\": {},\n      \"pressedKnob\": {}\n    };\n  }\n  static get events() {\n    return [{\n        \"method\": \"ionChange\",\n        \"name\": \"ionChange\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the value property has changed.\"\n        },\n        \"complexType\": {\n          \"original\": \"RangeChangeEventDetail\",\n          \"resolved\": \"RangeChangeEventDetail\",\n          \"references\": {\n            \"RangeChangeEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        }\n      }, {\n        \"method\": \"ionStyle\",\n        \"name\": \"ionStyle\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }],\n          \"text\": \"Emitted when the styles change.\"\n        },\n        \"complexType\": {\n          \"original\": \"StyleEventDetail\",\n          \"resolved\": \"StyleEventDetail\",\n          \"references\": {\n            \"StyleEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        }\n      }, {\n        \"method\": \"ionFocus\",\n        \"name\": \"ionFocus\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the range has focus.\"\n        },\n        \"complexType\": {\n          \"original\": \"void\",\n          \"resolved\": \"void\",\n          \"references\": {}\n        }\n      }, {\n        \"method\": \"ionBlur\",\n        \"name\": \"ionBlur\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the range loses focus.\"\n        },\n        \"complexType\": {\n          \"original\": \"void\",\n          \"resolved\": \"void\",\n          \"references\": {}\n        }\n      }, {\n        \"method\": \"ionKnobMoveStart\",\n        \"name\": \"ionKnobMoveStart\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the user starts moving the range knob, whether through\\nmouse drag, touch gesture, or keyboard interaction.\"\n        },\n        \"complexType\": {\n          \"original\": \"RangeKnobMoveStartEventDetail\",\n          \"resolved\": \"RangeKnobMoveStartEventDetail\",\n          \"references\": {\n            \"RangeKnobMoveStartEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        }\n      }, {\n        \"method\": \"ionKnobMoveEnd\",\n        \"name\": \"ionKnobMoveEnd\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the user finishes moving the range knob, whether through\\nmouse drag, touch gesture, or keyboard interaction.\"\n        },\n        \"complexType\": {\n          \"original\": \"RangeKnobMoveEndEventDetail\",\n          \"resolved\": \"RangeKnobMoveEndEventDetail\",\n          \"references\": {\n            \"RangeKnobMoveEndEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        }\n      }];\n  }\n  static get elementRef() { return \"el\"; }\n  static get watchers() {\n    return [{\n        \"propName\": \"debounce\",\n        \"methodName\": \"debounceChanged\"\n      }, {\n        \"propName\": \"min\",\n        \"methodName\": \"minChanged\"\n      }, {\n        \"propName\": \"max\",\n        \"methodName\": \"maxChanged\"\n      }, {\n        \"propName\": \"activeBarStart\",\n        \"methodName\": \"activeBarStartChanged\"\n      }, {\n        \"propName\": \"disabled\",\n        \"methodName\": \"disabledChanged\"\n      }, {\n        \"propName\": \"value\",\n        \"methodName\": \"valueChanged\"\n      }];\n  }\n}\nconst renderKnob = (rtl, { knob, value, ratio, min, max, disabled, pressed, pin, handleKeyboard, labelText, pinFormatter }) => {\n  const start = rtl ? 'right' : 'left';\n  const knobStyle = () => {\n    const style = {};\n    style[start] = `${ratio * 100}%`;\n    return style;\n  };\n  return (h(\"div\", { onKeyDown: (ev) => {\n      const key = ev.key;\n      if (key === 'ArrowLeft' || key === 'ArrowDown') {\n        handleKeyboard(knob, false);\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n      else if (key === 'ArrowRight' || key === 'ArrowUp') {\n        handleKeyboard(knob, true);\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }, class: {\n      'range-knob-handle': true,\n      'range-knob-a': knob === 'A',\n      'range-knob-b': knob === 'B',\n      'range-knob-pressed': pressed,\n      'range-knob-min': value === min,\n      'range-knob-max': value === max,\n      'ion-activatable': true,\n      'ion-focusable': true,\n    }, style: knobStyle(), role: \"slider\", tabindex: disabled ? -1 : 0, \"aria-label\": labelText, \"aria-valuemin\": min, \"aria-valuemax\": max, \"aria-disabled\": disabled ? 'true' : null, \"aria-valuenow\": value }, pin && (h(\"div\", { class: \"range-pin\", role: \"presentation\", part: \"pin\" }, pinFormatter(value))), h(\"div\", { class: \"range-knob\", role: \"presentation\", part: \"knob\" })));\n};\nconst ratioToValue = (ratio, min, max, step) => {\n  let value = (max - min) * ratio;\n  if (step > 0) {\n    value = Math.round(value / step) * step + min;\n  }\n  return clamp(min, value, max);\n};\nconst valueToRatio = (value, min, max) => {\n  return clamp(0, (value - min) / (max - min), 1);\n};\nlet rangeIds = 0;\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nexport const hostContext = (selector, el) => {\n  return el.closest(selector) !== null;\n};\n/**\n * Create the mode and color classes for the component based on the classes passed in\n */\nexport const createColorClasses = (color, cssClassMap) => {\n  return typeof color === 'string' && color.length > 0\n    ? Object.assign({ 'ion-color': true, [`ion-color-${color}`]: true }, cssClassMap) : cssClassMap;\n};\nexport const getClassList = (classes) => {\n  if (classes !== undefined) {\n    const array = Array.isArray(classes) ? classes : classes.split(' ');\n    return array\n      .filter((c) => c != null)\n      .map((c) => c.trim())\n      .filter((c) => c !== '');\n  }\n  return [];\n};\nexport const getClassMap = (classes) => {\n  const map = {};\n  getClassList(classes).forEach((c) => (map[c] = true));\n  return map;\n};\nconst SCHEME = /^[a-z][a-z0-9+\\-.]*:/;\nexport const openURL = async (url, ev, direction, animation) => {\n  if (url != null && url[0] !== '#' && !SCHEME.test(url)) {\n    const router = document.querySelector('ion-router');\n    if (router) {\n      if (ev != null) {\n        ev.preventDefault();\n      }\n      return router.push(url, direction, animation);\n    }\n  }\n  return false;\n};\n"],"names":[],"sourceRoot":""}