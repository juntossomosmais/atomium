"use strict";
(globalThis["webpackChunk_atomium_docs"] = globalThis["webpackChunk_atomium_docs"] || []).push([["packages_core_dist_esm_ion-router-outlet_entry_js"],{

/***/ "../../packages/core/dist/esm/cubic-bezier-1aed87b5.js":
/*!*************************************************************!*\
  !*** ../../packages/core/dist/esm/cubic-bezier-1aed87b5.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "g": () => (/* binding */ getTimeGivenProgression)
/* harmony export */ });
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
/**
 * Based on:
 * https://stackoverflow.com/questions/7348009/y-coordinate-for-a-given-x-cubic-bezier
 * https://math.stackexchange.com/questions/26846/is-there-an-explicit-form-for-cubic-b%C3%A9zier-curves
 */
/**
 * EXPERIMENTAL
 * Given a cubic-bezier curve, get the x value (time) given
 * the y value (progression).
 * Ex: cubic-bezier(0.32, 0.72, 0, 1);
 * P0: (0, 0)
 * P1: (0.32, 0.72)
 * P2: (0, 1)
 * P3: (1, 1)
 *
 * If you give a cubic bezier curve that never reaches the
 * provided progression, this function will return an empty array.
 */
const getTimeGivenProgression = (p0, p1, p2, p3, progression) => {
  return solveCubicBezier(p0[1], p1[1], p2[1], p3[1], progression).map(tValue => {
    return solveCubicParametricEquation(p0[0], p1[0], p2[0], p3[0], tValue);
  });
};
/**
 * Solve a cubic equation in one dimension (time)
 */
const solveCubicParametricEquation = (p0, p1, p2, p3, t) => {
  const partA = 3 * p1 * Math.pow(t - 1, 2);
  const partB = -3 * p2 * t + 3 * p2 + p3 * t;
  const partC = p0 * Math.pow(t - 1, 3);
  return t * (partA + t * partB) - partC;
};
/**
 * Find the `t` value for a cubic bezier using Cardano's formula
 */
const solveCubicBezier = (p0, p1, p2, p3, refPoint) => {
  p0 -= refPoint;
  p1 -= refPoint;
  p2 -= refPoint;
  p3 -= refPoint;
  const roots = solveCubicEquation(p3 - 3 * p2 + 3 * p1 - p0, 3 * p2 - 6 * p1 + 3 * p0, 3 * p1 - 3 * p0, p0);
  return roots.filter(root => root >= 0 && root <= 1);
};
const solveQuadraticEquation = (a, b, c) => {
  const discriminant = b * b - 4 * a * c;
  if (discriminant < 0) {
    return [];
  } else {
    return [(-b + Math.sqrt(discriminant)) / (2 * a), (-b - Math.sqrt(discriminant)) / (2 * a)];
  }
};
const solveCubicEquation = (a, b, c, d) => {
  if (a === 0) {
    return solveQuadraticEquation(b, c, d);
  }
  b /= a;
  c /= a;
  d /= a;
  const p = (3 * c - b * b) / 3;
  const q = (2 * b * b * b - 9 * b * c + 27 * d) / 27;
  if (p === 0) {
    return [Math.pow(-q, 1 / 3)];
  } else if (q === 0) {
    return [Math.sqrt(-p), -Math.sqrt(-p)];
  }
  const discriminant = Math.pow(q / 2, 2) + Math.pow(p / 3, 3);
  if (discriminant === 0) {
    return [Math.pow(q / 2, 1 / 2) - b / 3];
  } else if (discriminant > 0) {
    return [Math.pow(-(q / 2) + Math.sqrt(discriminant), 1 / 3) - Math.pow(q / 2 + Math.sqrt(discriminant), 1 / 3) - b / 3];
  }
  const r = Math.sqrt(Math.pow(-(p / 3), 3));
  const phi = Math.acos(-(q / (2 * Math.sqrt(Math.pow(-(p / 3), 3)))));
  const s = 2 * Math.pow(r, 1 / 3);
  return [s * Math.cos(phi / 3) - b / 3, s * Math.cos((phi + 2 * Math.PI) / 3) - b / 3, s * Math.cos((phi + 4 * Math.PI) / 3) - b / 3];
};


/***/ }),

/***/ "../../packages/core/dist/esm/framework-delegate-abaf8026.js":
/*!*******************************************************************!*\
  !*** ../../packages/core/dist/esm/framework-delegate-abaf8026.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "C": () => (/* binding */ CoreDelegate),
/* harmony export */   "a": () => (/* binding */ attachComponent),
/* harmony export */   "d": () => (/* binding */ detachComponent)
/* harmony export */ });
/* harmony import */ var _helpers_937ea457_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers-937ea457.js */ "../../packages/core/dist/esm/helpers-937ea457.js");


/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
// TODO(FW-2832): types
const attachComponent = async (delegate, container, component, cssClasses, componentProps, inline) => {
  var _a;
  if (delegate) {
    return delegate.attachViewToDom(container, component, componentProps, cssClasses);
  }
  if (!inline && typeof component !== 'string' && !(component instanceof HTMLElement)) {
    throw new Error('framework delegate is missing');
  }
  const el = typeof component === 'string' ? (_a = container.ownerDocument) === null || _a === void 0 ? void 0 : _a.createElement(component) : component;
  if (cssClasses) {
    cssClasses.forEach(c => el.classList.add(c));
  }
  if (componentProps) {
    Object.assign(el, componentProps);
  }
  container.appendChild(el);
  await new Promise(resolve => (0,_helpers_937ea457_js__WEBPACK_IMPORTED_MODULE_0__.d)(el, resolve));
  return el;
};
const detachComponent = (delegate, element) => {
  if (element) {
    if (delegate) {
      const container = element.parentElement;
      return delegate.removeViewFromDom(container, element);
    }
    element.remove();
  }
  return Promise.resolve();
};
const CoreDelegate = () => {
  let BaseComponent;
  let Reference;
  const attachViewToDom = async (parentElement, userComponent, userComponentProps = {}, cssClasses = []) => {
    var _a, _b;
    BaseComponent = parentElement;
    /**
     * If passing in a component via the `component` props
     * we need to append it inside of our overlay component.
     */
    if (userComponent) {
      /**
       * If passing in the tag name, create
       * the element otherwise just get a reference
       * to the component.
       */
      const el = typeof userComponent === 'string' ? (_a = BaseComponent.ownerDocument) === null || _a === void 0 ? void 0 : _a.createElement(userComponent) : userComponent;
      /**
       * Add any css classes passed in
       * via the cssClasses prop on the overlay.
       */
      cssClasses.forEach(c => el.classList.add(c));
      /**
       * Add any props passed in
       * via the componentProps prop on the overlay.
       */
      Object.assign(el, userComponentProps);
      /**
       * Finally, append the component
       * inside of the overlay component.
       */
      BaseComponent.appendChild(el);
      await new Promise(resolve => (0,_helpers_937ea457_js__WEBPACK_IMPORTED_MODULE_0__.d)(el, resolve));
    } else if (BaseComponent.children.length > 0 && (BaseComponent.tagName === 'ION-MODAL' || BaseComponent.tagName === 'ION-POPOVER')) {
      /**
       * The delegate host wrapper el is only needed for modals and popovers
       * because they allow the dev to provide custom content to the overlay.
       */
      const root = BaseComponent.children[0];
      if (!root.classList.contains('ion-delegate-host')) {
        /**
         * If the root element is not a delegate host, it means
         * that the overlay has not been presented yet and we need
         * to create the containing element with the specified classes.
         */
        const el = (_b = BaseComponent.ownerDocument) === null || _b === void 0 ? void 0 : _b.createElement('div');
        // Add a class to track if the root element was created by the delegate.
        el.classList.add('ion-delegate-host');
        cssClasses.forEach(c => el.classList.add(c));
        // Move each child from the original template to the new parent element.
        el.append(...BaseComponent.children);
        // Append the new parent element to the original parent element.
        BaseComponent.appendChild(el);
      }
    }
    /**
     * Get the root of the app and
     * add the overlay there.
     */
    const app = document.querySelector('ion-app') || document.body;
    /**
     * Create a placeholder comment so that
     * we can return this component to where
     * it was previously.
     */
    Reference = document.createComment('ionic teleport');
    BaseComponent.parentNode.insertBefore(Reference, BaseComponent);
    app.appendChild(BaseComponent);
    return BaseComponent;
  };
  const removeViewFromDom = () => {
    /**
     * Return component to where it was previously in the DOM.
     */
    if (BaseComponent && Reference) {
      Reference.parentNode.insertBefore(BaseComponent, Reference);
      Reference.remove();
    }
    return Promise.resolve();
  };
  return {
    attachViewToDom,
    removeViewFromDom
  };
};


/***/ }),

/***/ "../../packages/core/dist/esm/index-aae540f5.js":
/*!******************************************************!*\
  !*** ../../packages/core/dist/esm/index-aae540f5.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "L": () => (/* binding */ LIFECYCLE_WILL_UNLOAD),
/* harmony export */   "a": () => (/* binding */ LIFECYCLE_WILL_LEAVE),
/* harmony export */   "b": () => (/* binding */ LIFECYCLE_DID_LEAVE),
/* harmony export */   "d": () => (/* binding */ deepReady),
/* harmony export */   "g": () => (/* binding */ getIonPageElement),
/* harmony export */   "l": () => (/* binding */ lifecycle),
/* harmony export */   "s": () => (/* binding */ setPageHidden),
/* harmony export */   "t": () => (/* binding */ transition)
/* harmony export */ });
/* harmony import */ var _index_a869d52d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-a869d52d.js */ "../../packages/core/dist/esm/index-a869d52d.js");
/* harmony import */ var _helpers_937ea457_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers-937ea457.js */ "../../packages/core/dist/esm/helpers-937ea457.js");



/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const LIFECYCLE_WILL_ENTER = 'ionViewWillEnter';
const LIFECYCLE_DID_ENTER = 'ionViewDidEnter';
const LIFECYCLE_WILL_LEAVE = 'ionViewWillLeave';
const LIFECYCLE_DID_LEAVE = 'ionViewDidLeave';
const LIFECYCLE_WILL_UNLOAD = 'ionViewWillUnload';

/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const iosTransitionAnimation = () => Promise.all(/*! import() */[__webpack_require__.e("packages_core_dist_esm_animation-45b29945_js"), __webpack_require__.e("packages_core_dist_esm_ios_transition-532ea63b_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ./ios.transition-532ea63b.js */ "../../packages/core/dist/esm/ios.transition-532ea63b.js"));
const mdTransitionAnimation = () => Promise.all(/*! import() */[__webpack_require__.e("packages_core_dist_esm_animation-45b29945_js"), __webpack_require__.e("packages_core_dist_esm_md_transition-ec22a222_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ./md.transition-ec22a222.js */ "../../packages/core/dist/esm/md.transition-ec22a222.js"));
// TODO(FW-2832): types
const transition = opts => {
  return new Promise((resolve, reject) => {
    (0,_index_a869d52d_js__WEBPACK_IMPORTED_MODULE_0__.w)(() => {
      beforeTransition(opts);
      runTransition(opts).then(result => {
        if (result.animation) {
          result.animation.destroy();
        }
        afterTransition(opts);
        resolve(result);
      }, error => {
        afterTransition(opts);
        reject(error);
      });
    });
  });
};
const beforeTransition = opts => {
  const enteringEl = opts.enteringEl;
  const leavingEl = opts.leavingEl;
  setZIndex(enteringEl, leavingEl, opts.direction);
  if (opts.showGoBack) {
    enteringEl.classList.add('can-go-back');
  } else {
    enteringEl.classList.remove('can-go-back');
  }
  setPageHidden(enteringEl, false);
  /**
   * When transitioning, the page should not
   * respond to click events. This resolves small
   * issues like users double tapping the ion-back-button.
   * These pointer events are removed in `afterTransition`.
   */
  enteringEl.style.setProperty('pointer-events', 'none');
  if (leavingEl) {
    setPageHidden(leavingEl, false);
    leavingEl.style.setProperty('pointer-events', 'none');
  }
};
const runTransition = async opts => {
  const animationBuilder = await getAnimationBuilder(opts);
  const ani = animationBuilder && _index_a869d52d_js__WEBPACK_IMPORTED_MODULE_0__.B.isBrowser ? animation(animationBuilder, opts) : noAnimation(opts); // fast path for no animation
  return ani;
};
const afterTransition = opts => {
  const enteringEl = opts.enteringEl;
  const leavingEl = opts.leavingEl;
  enteringEl.classList.remove('ion-page-invisible');
  enteringEl.style.removeProperty('pointer-events');
  if (leavingEl !== undefined) {
    leavingEl.classList.remove('ion-page-invisible');
    leavingEl.style.removeProperty('pointer-events');
  }
};
const getAnimationBuilder = async opts => {
  if (!opts.leavingEl || !opts.animated || opts.duration === 0) {
    return undefined;
  }
  if (opts.animationBuilder) {
    return opts.animationBuilder;
  }
  const getAnimation = opts.mode === 'ios' ? (await iosTransitionAnimation()).iosTransitionAnimation : (await mdTransitionAnimation()).mdTransitionAnimation;
  return getAnimation;
};
const animation = async (animationBuilder, opts) => {
  await waitForReady(opts, true);
  const trans = animationBuilder(opts.baseEl, opts);
  fireWillEvents(opts.enteringEl, opts.leavingEl);
  const didComplete = await playTransition(trans, opts);
  if (opts.progressCallback) {
    opts.progressCallback(undefined);
  }
  if (didComplete) {
    fireDidEvents(opts.enteringEl, opts.leavingEl);
  }
  return {
    hasCompleted: didComplete,
    animation: trans
  };
};
const noAnimation = async opts => {
  const enteringEl = opts.enteringEl;
  const leavingEl = opts.leavingEl;
  await waitForReady(opts, false);
  fireWillEvents(enteringEl, leavingEl);
  fireDidEvents(enteringEl, leavingEl);
  return {
    hasCompleted: true
  };
};
const waitForReady = async (opts, defaultDeep) => {
  const deep = opts.deepWait !== undefined ? opts.deepWait : defaultDeep;
  if (deep) {
    await Promise.all([deepReady(opts.enteringEl), deepReady(opts.leavingEl)]);
  }
  await notifyViewReady(opts.viewIsReady, opts.enteringEl);
};
const notifyViewReady = async (viewIsReady, enteringEl) => {
  if (viewIsReady) {
    await viewIsReady(enteringEl);
  }
};
const playTransition = (trans, opts) => {
  const progressCallback = opts.progressCallback;
  const promise = new Promise(resolve => {
    trans.onFinish(currentStep => resolve(currentStep === 1));
  });
  // cool, let's do this, start the transition
  if (progressCallback) {
    // this is a swipe to go back, just get the transition progress ready
    // kick off the swipe animation start
    trans.progressStart(true);
    progressCallback(trans);
  } else {
    // only the top level transition should actually start "play"
    // kick it off and let it play through
    // ******** DOM WRITE ****************
    trans.play();
  }
  // create a callback for when the animation is done
  return promise;
};
const fireWillEvents = (enteringEl, leavingEl) => {
  lifecycle(leavingEl, LIFECYCLE_WILL_LEAVE);
  lifecycle(enteringEl, LIFECYCLE_WILL_ENTER);
};
const fireDidEvents = (enteringEl, leavingEl) => {
  lifecycle(enteringEl, LIFECYCLE_DID_ENTER);
  lifecycle(leavingEl, LIFECYCLE_DID_LEAVE);
};
const lifecycle = (el, eventName) => {
  if (el) {
    const ev = new CustomEvent(eventName, {
      bubbles: false,
      cancelable: false
    });
    el.dispatchEvent(ev);
  }
};
const deepReady = async el => {
  const element = el;
  if (element) {
    if (element.componentOnReady != null) {
      // eslint-disable-next-line custom-rules/no-component-on-ready-method
      const stencilEl = await element.componentOnReady();
      if (stencilEl != null) {
        return;
      }
      /**
       * Custom elements in Stencil will have __registerHost.
       */
    } else if (element.__registerHost != null) {
      /**
       * Non-lazy loaded custom elements need to wait
       * one frame for component to be loaded.
       */
      const waitForCustomElement = new Promise(resolve => (0,_helpers_937ea457_js__WEBPACK_IMPORTED_MODULE_1__.r)(resolve));
      await waitForCustomElement;
      return;
    }
    await Promise.all(Array.from(element.children).map(deepReady));
  }
};
const setPageHidden = (el, hidden) => {
  if (hidden) {
    el.setAttribute('aria-hidden', 'true');
    el.classList.add('ion-page-hidden');
  } else {
    el.hidden = false;
    el.removeAttribute('aria-hidden');
    el.classList.remove('ion-page-hidden');
  }
};
const setZIndex = (enteringEl, leavingEl, direction) => {
  if (enteringEl !== undefined) {
    enteringEl.style.zIndex = direction === 'back' ? '99' : '101';
  }
  if (leavingEl !== undefined) {
    leavingEl.style.zIndex = '100';
  }
};
const getIonPageElement = element => {
  if (element.classList.contains('ion-page')) {
    return element;
  }
  const ionPage = element.querySelector(':scope > .ion-page, :scope > ion-nav, :scope > ion-tabs');
  if (ionPage) {
    return ionPage;
  }
  // idk, return the original element so at least something animates and we don't have a null pointer
  return element;
};


/***/ }),

/***/ "../../packages/core/dist/esm/ion-router-outlet.entry.js":
/*!***************************************************************!*\
  !*** ../../packages/core/dist/esm/ion-router-outlet.entry.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ion_router_outlet": () => (/* binding */ RouterOutlet)
/* harmony export */ });
/* harmony import */ var _index_a869d52d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-a869d52d.js */ "../../packages/core/dist/esm/index-a869d52d.js");
/* harmony import */ var _ionic_global_4a637317_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ionic-global-4a637317.js */ "../../packages/core/dist/esm/ionic-global-4a637317.js");
/* harmony import */ var _cubic_bezier_1aed87b5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cubic-bezier-1aed87b5.js */ "../../packages/core/dist/esm/cubic-bezier-1aed87b5.js");
/* harmony import */ var _framework_delegate_abaf8026_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./framework-delegate-abaf8026.js */ "../../packages/core/dist/esm/framework-delegate-abaf8026.js");
/* harmony import */ var _helpers_937ea457_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers-937ea457.js */ "../../packages/core/dist/esm/helpers-937ea457.js");
/* harmony import */ var _index_aae540f5_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-aae540f5.js */ "../../packages/core/dist/esm/index-aae540f5.js");






const routeOutletCss = ":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;overflow:hidden;z-index:0}";
const RouterOutlet = class {
  constructor(hostRef) {
    (0,_index_a869d52d_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.ionNavWillLoad = (0,_index_a869d52d_js__WEBPACK_IMPORTED_MODULE_0__.d)(this, "ionNavWillLoad", 7);
    this.ionNavWillChange = (0,_index_a869d52d_js__WEBPACK_IMPORTED_MODULE_0__.d)(this, "ionNavWillChange", 3);
    this.ionNavDidChange = (0,_index_a869d52d_js__WEBPACK_IMPORTED_MODULE_0__.d)(this, "ionNavDidChange", 3);
    this.gestureOrAnimationInProgress = false;
    this.mode = (0,_ionic_global_4a637317_js__WEBPACK_IMPORTED_MODULE_1__.g)(this);
    this.delegate = undefined;
    this.animated = true;
    this.animation = undefined;
    this.swipeHandler = undefined;
  }
  swipeHandlerChanged() {
    if (this.gesture) {
      this.gesture.enable(this.swipeHandler !== undefined);
    }
  }
  async connectedCallback() {
    const onStart = () => {
      this.gestureOrAnimationInProgress = true;
      if (this.swipeHandler) {
        this.swipeHandler.onStart();
      }
    };
    this.gesture = (await Promise.all(/*! import() */[__webpack_require__.e("packages_core_dist_esm_index-e65e72c8_js"), __webpack_require__.e("packages_core_dist_esm_swipe-back-fe7ee8ee_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ./swipe-back-fe7ee8ee.js */ "../../packages/core/dist/esm/swipe-back-fe7ee8ee.js"))).createSwipeBackGesture(this.el, () => !this.gestureOrAnimationInProgress && !!this.swipeHandler && this.swipeHandler.canStart(), () => onStart(), step => {
      var _a;
      return (_a = this.ani) === null || _a === void 0 ? void 0 : _a.progressStep(step);
    }, (shouldComplete, step, dur) => {
      if (this.ani) {
        this.ani.onFinish(() => {
          this.gestureOrAnimationInProgress = false;
          if (this.swipeHandler) {
            this.swipeHandler.onEnd(shouldComplete);
          }
        }, {
          oneTimeCallback: true
        });
        let newStepValue = shouldComplete ? -0.001 : 0.001;
        if (!shouldComplete) {
          this.ani.easing('cubic-bezier(1, 0, 0.68, 0.28)');
          newStepValue += (0,_cubic_bezier_1aed87b5_js__WEBPACK_IMPORTED_MODULE_3__.g)([0, 0], [1, 0], [0.68, 0.28], [1, 1], step)[0];
        } else {
          newStepValue += (0,_cubic_bezier_1aed87b5_js__WEBPACK_IMPORTED_MODULE_3__.g)([0, 0], [0.32, 0.72], [0, 1], [1, 1], step)[0];
        }
        this.ani.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);
      } else {
        this.gestureOrAnimationInProgress = false;
      }
    });
    this.swipeHandlerChanged();
  }
  componentWillLoad() {
    this.ionNavWillLoad.emit();
  }
  disconnectedCallback() {
    if (this.gesture) {
      this.gesture.destroy();
      this.gesture = undefined;
    }
  }
  async commit(enteringEl, leavingEl, opts) {
    const unlock = await this.lock();
    let changed = false;
    try {
      changed = await this.transition(enteringEl, leavingEl, opts);
    } catch (e) {
      console.error(e);
    }
    unlock();
    return changed;
  }
  async setRouteId(id, params, direction, animation) {
    const changed = await this.setRoot(id, params, {
      duration: direction === 'root' ? 0 : undefined,
      direction: direction === 'back' ? 'back' : 'forward',
      animationBuilder: animation
    });
    return {
      changed,
      element: this.activeEl
    };
  }
  async getRouteId() {
    const active = this.activeEl;
    return active ? {
      id: active.tagName,
      element: active,
      params: this.activeParams
    } : undefined;
  }
  async setRoot(component, params, opts) {
    if (this.activeComponent === component && (0,_helpers_937ea457_js__WEBPACK_IMPORTED_MODULE_4__.s)(params, this.activeParams)) {
      return false;
    }
    const leavingEl = this.activeEl;
    const enteringEl = await (0,_framework_delegate_abaf8026_js__WEBPACK_IMPORTED_MODULE_5__.a)(this.delegate, this.el, component, ['ion-page', 'ion-page-invisible'], params);
    this.activeComponent = component;
    this.activeEl = enteringEl;
    this.activeParams = params;
    await this.commit(enteringEl, leavingEl, opts);
    await (0,_framework_delegate_abaf8026_js__WEBPACK_IMPORTED_MODULE_5__.d)(this.delegate, leavingEl);
    return true;
  }
  async transition(enteringEl, leavingEl, opts = {}) {
    if (leavingEl === enteringEl) {
      return false;
    }
    this.ionNavWillChange.emit();
    const {
      el,
      mode
    } = this;
    const animated = this.animated && _ionic_global_4a637317_js__WEBPACK_IMPORTED_MODULE_1__.c.getBoolean('animated', true);
    const animationBuilder = opts.animationBuilder || this.animation || _ionic_global_4a637317_js__WEBPACK_IMPORTED_MODULE_1__.c.get('navAnimation');
    await (0,_index_aae540f5_js__WEBPACK_IMPORTED_MODULE_2__.t)(Object.assign(Object.assign({
      mode,
      animated,
      enteringEl,
      leavingEl,
      baseEl: el,
      deepWait: (0,_helpers_937ea457_js__WEBPACK_IMPORTED_MODULE_4__.l)(el),
      progressCallback: opts.progressAnimation ? ani => {
        if (ani !== undefined && !this.gestureOrAnimationInProgress) {
          this.gestureOrAnimationInProgress = true;
          ani.onFinish(() => {
            this.gestureOrAnimationInProgress = false;
            if (this.swipeHandler) {
              this.swipeHandler.onEnd(false);
            }
          }, {
            oneTimeCallback: true
          });
          ani.progressEnd(0, 0, 0);
        } else {
          this.ani = ani;
        }
      } : undefined
    }, opts), {
      animationBuilder
    }));
    this.ionNavDidChange.emit();
    return true;
  }
  async lock() {
    const p = this.waitPromise;
    let resolve;
    this.waitPromise = new Promise(r => resolve = r);
    if (p !== undefined) {
      await p;
    }
    return resolve;
  }
  render() {
    return (0,_index_a869d52d_js__WEBPACK_IMPORTED_MODULE_0__.h)("slot", null);
  }
  get el() {
    return (0,_index_a869d52d_js__WEBPACK_IMPORTED_MODULE_0__.e)(this);
  }
  static get watchers() {
    return {
      "swipeHandler": ["swipeHandlerChanged"]
    };
  }
};
RouterOutlet.style = routeOutletCss;


/***/ })

}]);
//# sourceMappingURL=packages_core_dist_esm_ion-router-outlet_entry_js.iframe.bundle.js.map