import { Meta } from '@storybook/blocks'

<Meta title="Docs/Architecture Decision Records/ADR 0004: Why a Monorepo?" />

# ADR 0004: Why a Monorepo?

üóìÔ∏è 2023-03 ¬∑ ‚úçÔ∏è [@felipefialho](https://twitter.com/felipefialho_)

## Context

We need to choose an architecture for our project that enables us to efficiently manage our codebase and share resources between packages.

## Decision Drivers

* We need to be able to independently version each package.
* We need to share code and configuration between packages.
* We need to share dependencies between packages.
* We need a centralized documentation for our Design System.

## Considered Options

* **[Monorepo](https://monorepo.tools/)**: A monorepo is a software development practice where multiple projects are stored in the same repository. In the context of a design system, this means that all the packages (e.g., UI components, typography, color scheme, etc.) are kept in a single repository and versioned together. This approach allows for easy sharing of code, configuration, and dependencies between packages, and provides a centralized location for documentation and tooling. It can also simplify the development workflow by enabling atomic commits, shared testing, and a unified deployment pipeline.

* **Separate Repositories**: This refers to the practice of keeping each package (e.g., UI components, typography, color scheme, etc.) in a separate repository. Each package has its own versioning and development lifecycle, and can be developed and deployed independently of the others. However, this approach can lead to code duplication, configuration fragmentation, and dependency management issues, especially if multiple packages need to share common code or dependencies. It also makes it harder to maintain a centralized documentation and tooling, as these would need to be replicated across multiple repositories.

## Decision

We have decided to use a **Monorepo as our architecture of choice**. With a Monorepo, we can easily share code, configuration, and dependencies between packages while also allowing for independent versioning of each package. Additionally, a Monorepo enables us to maintain a centralized documentation for our Design System.

In contrast, using separate repositories for each package and documentation would lead to duplication of code and configuration and make maintenance more difficult.

Overall, a Monorepo aligns well with our needs for an efficient and scalable architecture.
